-- Tests parameterized nonterminals in combination with:
-- visit functions
-- case expressions
-- bang patterns

MODULE {Main} {} {}

optpragmas
{
{-# OPTIONS_GHC -fglasgow-exts #-}
}

PRAGMA strictdata
PRAGMA bangpats
PRAGMA optimize


DATA A b c
  | A
      b : (B {b})
      c : (C {c})

DATA B b
  | B
      x : {b}

DATA C c
  | C
      x : {c}

WRAPPER A


ATTR B [ | | bsGath USE {++} {[]} : {[@b]} ]
ATTR C [ | | csGath USE {++} {[]} : {[@c]} ]

SEM B
  | B
      loc.bsGath : {[@b]}
      loc.bsGath = [@x]

SEM C
  | C
      loc.csGath : {[@c]}
      loc.csGath = [@x]


ATTR B [ bs : {[@b]} | | ]
ATTR C [ cs : {[@c]} | | ]

SEM A
  | A
      b.bs = @b.bsGath
      c.cs = @c.csGath


ATTR A B C [ | | count USE {+} {0} : Int ]

SEM B
  | B
      lhs.count = length @lhs.bs

SEM C
  | C
      lhs.count = length @lhs.cs


{
valA :: A String Bool
valA
  = A_A (B_B "") (C_C False)

main :: IO ()
main
  = let inh = Inh_A {}
        sem = sem_A valA
        syn = wrap_A sem inh
    in putStrLn ("count: " ++ show (count_Syn_A syn))
}

