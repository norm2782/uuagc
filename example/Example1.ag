-- UUAGC Example 1: Calculate the sum of a tree of integers
--
-- first preprocess with:   uuagc -dcfH Example1.ag
-- then compile with:       ghc Example1.hs
-- finally run with:        ./Example1


-- With a data declaration we define the syntax of our datatype.
-- A data declaration is quite similar to a Haskall data declaration, but:
-- * each field has a name
-- * all alternatives are preceded with a "|" (even the first one)

data Tree
   | Node  left  :: Tree
           right :: Tree
   | Tip   value :: Int

-- With an attr declaration we specify attributes, that is the values 
-- we want to calculate in our tree walk.
-- The syn (synthesized) keyword defines a bottom-up attribute

attr Tree
   syn sum :: Int

-- With a sem declaration we specify the semantics.
-- For each constructor we have an assignment that states how the
-- sum for the left hand side (lhs) can be calculated from the fields
-- and/or the attributes of the right hand side.
-- A field can be referred to by an @ and the field name (as in @value),
-- an attribute by selecting from a field with a "dot" notation (as in @left.sum).
-- These items can be combined by any Haskell expression (in this case just a + ).

sem Tree
  | Node  lhs.sum  =  @left.sum + @right.sum
  | Tip   lhs.sum  =  @value

-- The main program as well as some test data are written in Haskell.
-- It is written here enclosed in braces, as text in braces is
-- not touched by the preprocessor and passed unchanged to the Haskell compiler.

{
main :: IO ()
main = print (show test)

-- We can define an example tree structure by using the type Tree 
-- and the constructors Node and Tip introduced by the DATA declaration.
testTree :: Tree
testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))

-- A function sem_Tree is generated by the preprocessor.
-- It can be used to determine the semantics of our example structure.
test :: Int
test = sem_Tree testTree
}
-- output of the program will be "6"
