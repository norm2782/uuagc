-- UUAGC Example 2: Multiple attributes, and wrappers
--
-- first preprocess with:   uuagc -dcfsw Example2.ag
-- then compile with:       ghc Example2.hs
-- finally run with:        ./main


DATA Tree
   | Node  left:  Tree   right: Tree
   | Tip   value: Int

-- We define three bottom-up, or "synthesized" attributes.
-- As of yet, we still don't have top-down, or "inherited" attributes.
-- Types of attributes can be any Haskell type, including the
-- ones generated by from this file, but if they are
-- not a simple name they must be escaped by braces.

ATTR Tree [
          |
          | sum: Int   max: Int   front: {[Int]}   copy: Tree
          ]

-- In SEM declarations we define the values for all four attributes
-- for both constructores.
-- For each constructor we can give multiple assignments at once,
-- but we can also distribute assignments in separate SEM declarations.
-- Constructors and their assignments may appear in any order.
-- If, for a particular constructor, we have multiple assignments sharing
-- the same target field, we may omit the field name (as in .max).

SEM Tree
  | Tip   lhs.max  =  @value
          lhs.sum  =  @value
  | Node  lhs.sum  =  @left.sum   +   @right.sum
             .max  =  @left.max `max` @right.max
          
SEM Tree
  | Node  lhs.front = @left.front ++ @right.front
          lhs.copy  = Node @left.copy @right.copy
  | Tip   lhs.front = [ @value ]
          lhs.copy  = Tip @value


{
main :: IO ()
main = print (show result)

testTree :: Tree
testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))

-- Because we declared four synthesized attributes, calling sem_Tree now returns a quadruple.
-- The order of the elements of this quadruple is unspecified.
-- To be able to use it in signatures, the type of the full quadruple is available 
-- as T_Tree (as an effect of the -s option).

test :: T_Tree
test = sem_Tree testTree

-- If we are interested in a particular element of the quadruple, we can run the
-- preprocessor with -w option. This will generate a function wrap_Tree, which takes:
--  * the semantics of the tree (which is the quadruple of unknown order)
--  * an additional argument for initializing inherited attributes (currently just the constant Inh_Tree)
-- and returns
--  * the four synthesized attributes again, but now as a value of datatype with named fields
-- From the result of wrap_Tree, we can select the desired attribute by name.

result :: [Int]
result = front_Syn_Tree (wrap_Tree test Inh_Tree)
}
-- output of the program will be "[1,2,3]"