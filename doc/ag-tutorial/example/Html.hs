

-- UUAGC 0.9.38.6 (Html.ag)


module Main(main) where

import UU.Parsing
import UU.Scanner.Token
import UU.Scanner.TokenParser
import UU.Scanner.GenTokenOrd()
import UU.Scanner.GenTokenSymbol()
import UU.Scanner.TokenShow()
import UU.Scanner.Position
import Data.List
import UU.Pretty
import System.Environment
import System.IO
import Data.Char

-- Evil, ugly handcrafted scanner.
-- For Haskell-like languages, you can use UU.Scanner (or Alex)
scanBlock :: Pos -> String -> [Token]
scanBlock _ "" = [] 
scanBlock p ('\\' : 'e' : 'n' : 'd' : r)
  = reserved "end" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 't' : 'o' : 'c' : r)
  = reserved "toc" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 'i' : 'n' : 'd' : 'e' : 'x' : r)
  = reserved "index" p : scanBlock (advc 6 p) r
scanBlock p1 ('\\' : 'k' : 'e' : 'y' : 'w' : 'o' : 'r' : 'd' : r)
  = let p2 = advc 8 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "keyword" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'p' : 'a' : 'r' : 'a' : 'g' : 'r' : 'a' : 'p' : 'h' : r)
  = let p2 = advc 10 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "paragraph" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'b' : 'e' : 'g' : 'i' : 'n' : '{' : r1)
  = let p2 = advc 7 p1
        (p3,r2,s1) = untilChar False '}' p2 r1
        p4 = adv p3 (head r2)
        r3 = tail r2
    in   reserved "begin" p1 : valueToken TkString s1 p2 : scanBlock p4 r3
scanBlock p ('\\' : r)
  = errToken "Non-command character \\" p : scanBlock (advc 1 p) r
scanBlock p (c : r)
  | isSpace c = scanBlock (adv p c) r
  | otherwise = errToken ("Unexpected character " ++ show c) p : scanBlock (adv p c) r

untilChar :: Bool -> Char -> Pos -> String -> (Pos, String, String)
untilChar eofAllowed c p s
  = let (l,r) = span (/= c) s
    in if null r && not eofAllowed
       then error "Unexpected EOF"
       else (foldl adv p l, r, l)


-- Parser with starting nonterminal Root
-- Semantic functions generated by UUAG
pRoot :: Parser Token T_Root
pRoot
  = sem_Root_Root <$> pDocs

pDocs :: Parser Token T_Docs
pDocs
  = pFoldr_gr (sem_Docs_Cons, sem_Docs_Nil) pDoc

pDoc :: Parser Token T_Doc
pDoc
  =   sem_Doc_Section   <$ pKey "begin" <*> pString <*> pDocs <* pKey "end"
  <|> sem_Doc_Paragraph <$ pKey "paragraph" <*> pString <* pKey "end"
  <|> sem_Doc_Toc       <$ pKey "toc"
  <|> sem_Doc_Index     <$ pKey "index"
  <|> sem_Doc_Keyword   <$ pKey "keyword" <*> (trim <$> pString) <* pKey "end"

trim :: String -> String
trim
  = (reverse . trimAtFront . reverse) . trimAtFront
  where trimAtFront = dropWhile isSpace


main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: html <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParser toks
       let output = pretty $ transform $ sem
       writeFile dest output

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

runParser :: [Token] -> IO T_Root
runParser
  = parseIOMessage show pRoot

transform :: T_Root -> PP_Doc
transform sem
  = let inh = Inh_Root {}
        syn = wrap_Root sem inh
    in html_Syn_Root syn

augment :: PP_Doc -> PP_Doc
augment doc
  = "<html lang=\"en\"><head><title>Generated HTML document</title></head><body>" >-< doc >-< "</body></html>"

pretty :: PP_Doc -> String
pretty doc
  = disp doc 10000 ""


aHref :: PP a => String -> a -> PP_Doc
aHref bookmark txt
  = "<a href=\"#" >|< bookmark >|< "\">" >|< txt >|< "</a>"

aName :: String -> PP_Doc
aName bookmark
  = "<a name=\"" >|< bookmark >|< "\"/>"

li :: PP a => a -> PP_Doc
li txt
  = "<li>" >|< txt >|< "</li>"

ul :: PP a => a -> PP_Doc
ul txt
  = "<ul>" >|< txt >|< "</ul>"

p :: PP a => a -> PP_Doc
p txt
  = "<p>" >|< txt >|< "</p>"

h :: PP a => Int -> a -> PP_Doc
h n title
  = "<h" >|< show n >|< ">" >|< title >|< "</h" >|< show n >|< ">"

hr :: PP_Doc
hr = pp "<hr/>"
-- Doc ---------------------------------------------------------
data Doc  = Doc_Index 
          | Doc_Keyword (String) 
          | Doc_Paragraph (String) 
          | Doc_Section (String) (Docs ) 
          | Doc_Toc 
          deriving ( Show)
-- cata
sem_Doc :: Doc  ->
           T_Doc 
sem_Doc (Doc_Index )  =
    (sem_Doc_Index )
sem_Doc (Doc_Keyword _text )  =
    (sem_Doc_Keyword _text )
sem_Doc (Doc_Paragraph _text )  =
    (sem_Doc_Paragraph _text )
sem_Doc (Doc_Section _title _body )  =
    (sem_Doc_Section _title (sem_Docs _body ) )
sem_Doc (Doc_Toc )  =
    (sem_Doc_Toc )
-- semantic domain
type T_Doc  = Int ->
              String ->
              Int ->
              ([Int]) ->
              String ->
              PP_Doc ->
              ( Int,PP_Doc,PP_Doc,String,String)
sem_Doc_Index :: T_Doc 
sem_Doc_Index  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _lhsOgathToc :: PP_Doc
              _lhsOhtml :: PP_Doc
              _lhsOcount :: Int
              _lhsOleft :: String
              _lhsOright :: String
              _lhsOgathToc =
                  empty
              _lhsOhtml =
                  empty
              _lhsOcount =
                  _lhsIcount
              _lhsOleft =
                  _lhsIleft
              _lhsOright =
                  _lhsIright
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
sem_Doc_Keyword :: String ->
                   T_Doc 
sem_Doc_Keyword text_  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _lhsOgathToc :: PP_Doc
              _lhsOhtml :: PP_Doc
              _lhsOcount :: Int
              _lhsOleft :: String
              _lhsOright :: String
              _lhsOgathToc =
                  empty
              _lhsOhtml =
                  empty
              _lhsOcount =
                  _lhsIcount
              _lhsOleft =
                  _lhsIleft
              _lhsOright =
                  _lhsIright
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
sem_Doc_Paragraph :: String ->
                     T_Doc 
sem_Doc_Paragraph text_  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _lhsOhtml :: PP_Doc
              _lhsOgathToc :: PP_Doc
              _lhsOcount :: Int
              _lhsOleft :: String
              _lhsOright :: String
              _lhsOhtml =
                  p text_
              _lhsOgathToc =
                  empty
              _lhsOcount =
                  _lhsIcount
              _lhsOleft =
                  _lhsIleft
              _lhsOright =
                  _lhsIright
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
sem_Doc_Section :: String ->
                   T_Docs  ->
                   T_Doc 
sem_Doc_Section title_ body_  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _lhsOcount :: Int
              _bodyOcount :: Int
              _context :: String
              _name :: PP_Doc
              _lhsOgathToc :: PP_Doc
              _bodyOleft :: String
              _lhsOleft :: String
              _bodyOright :: String
              _lhsOright :: String
              _lhsOhtml :: PP_Doc
              _bodyOlevel :: Int
              _bodyOprefix :: ([Int])
              _bodyOtoc :: PP_Doc
              _bodyIcount :: Int
              _bodyIgathToc :: PP_Doc
              _bodyIhtml :: PP_Doc
              _bodyIleft :: String
              _bodyIright :: String
              _level =
                  1 + _lhsIlevel
              _lhsOcount =
                  1 + _lhsIcount
              _bodyOcount =
                  1
              _prefix =
                  _lhsIcount : _lhsIprefix
              _context =
                  concat . intersperse "." . map show . reverse $ _prefix
              _name =
                  _context     >#< title_
              _tocline =
                  aHref _context     _name
              _lhsOgathToc =
                  _tocline     >-< ul _bodyIgathToc
              _bodyOleft =
                  ""
              _lhsOleft =
                  _context
              _bodyOright =
                  ""
              _lhsOright =
                  _context
              _lhsOhtml =
                  aName _context
                  >-< h _lhsIlevel _name
                  >-<     (if null _lhsIleft then empty else aHref _lhsIleft "left")
                      >#< (if null _lhsIright then empty else aHref _lhsIright "right")
                  >-< _bodyIhtml
                  >-< hr
              _bodyOlevel =
                  _level
              _bodyOprefix =
                  _prefix
              _bodyOtoc =
                  _lhsItoc
              ( _bodyIcount,_bodyIgathToc,_bodyIhtml,_bodyIleft,_bodyIright) =
                  body_ _bodyOcount _bodyOleft _bodyOlevel _bodyOprefix _bodyOright _bodyOtoc 
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
sem_Doc_Toc :: T_Doc 
sem_Doc_Toc  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _lhsOhtml :: PP_Doc
              _lhsOgathToc :: PP_Doc
              _lhsOcount :: Int
              _lhsOleft :: String
              _lhsOright :: String
              _lhsOhtml =
                  h _lhsIlevel "Table Of Contents" >-< _lhsItoc
              _lhsOgathToc =
                  empty
              _lhsOcount =
                  _lhsIcount
              _lhsOleft =
                  _lhsIleft
              _lhsOright =
                  _lhsIright
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
-- Docs --------------------------------------------------------
type Docs  = [Doc ]
-- cata
sem_Docs :: Docs  ->
            T_Docs 
sem_Docs list  =
    (Prelude.foldr sem_Docs_Cons sem_Docs_Nil (Prelude.map sem_Doc list) )
-- semantic domain
type T_Docs  = Int ->
               String ->
               Int ->
               ([Int]) ->
               String ->
               PP_Doc ->
               ( Int,PP_Doc,PP_Doc,String,String)
sem_Docs_Cons :: T_Doc  ->
                 T_Docs  ->
                 T_Docs 
sem_Docs_Cons hd_ tl_  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _tlOright :: String
              _hdOright :: String
              _lhsOright :: String
              _lhsOgathToc :: PP_Doc
              _lhsOhtml :: PP_Doc
              _lhsOcount :: Int
              _lhsOleft :: String
              _hdOcount :: Int
              _hdOleft :: String
              _hdOlevel :: Int
              _hdOprefix :: ([Int])
              _hdOtoc :: PP_Doc
              _tlOcount :: Int
              _tlOleft :: String
              _tlOlevel :: Int
              _tlOprefix :: ([Int])
              _tlOtoc :: PP_Doc
              _hdIcount :: Int
              _hdIgathToc :: PP_Doc
              _hdIhtml :: PP_Doc
              _hdIleft :: String
              _hdIright :: String
              _tlIcount :: Int
              _tlIgathToc :: PP_Doc
              _tlIhtml :: PP_Doc
              _tlIleft :: String
              _tlIright :: String
              _tlOright =
                  _lhsIright
              _hdOright =
                  _tlIright
              _lhsOright =
                  _hdIright
              _lhsOgathToc =
                  _hdIgathToc >-< _tlIgathToc
              _lhsOhtml =
                  _hdIhtml >-< _tlIhtml
              _lhsOcount =
                  _tlIcount
              _lhsOleft =
                  _tlIleft
              _hdOcount =
                  _lhsIcount
              _hdOleft =
                  _lhsIleft
              _hdOlevel =
                  _lhsIlevel
              _hdOprefix =
                  _lhsIprefix
              _hdOtoc =
                  _lhsItoc
              _tlOcount =
                  _hdIcount
              _tlOleft =
                  _hdIleft
              _tlOlevel =
                  _lhsIlevel
              _tlOprefix =
                  _lhsIprefix
              _tlOtoc =
                  _lhsItoc
              ( _hdIcount,_hdIgathToc,_hdIhtml,_hdIleft,_hdIright) =
                  hd_ _hdOcount _hdOleft _hdOlevel _hdOprefix _hdOright _hdOtoc 
              ( _tlIcount,_tlIgathToc,_tlIhtml,_tlIleft,_tlIright) =
                  tl_ _tlOcount _tlOleft _tlOlevel _tlOprefix _tlOright _tlOtoc 
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
sem_Docs_Nil :: T_Docs 
sem_Docs_Nil  =
    (\ _lhsIcount
       _lhsIleft
       _lhsIlevel
       _lhsIprefix
       _lhsIright
       _lhsItoc ->
         (let _lhsOgathToc :: PP_Doc
              _lhsOhtml :: PP_Doc
              _lhsOcount :: Int
              _lhsOleft :: String
              _lhsOright :: String
              _lhsOgathToc =
                  empty
              _lhsOhtml =
                  empty
              _lhsOcount =
                  _lhsIcount
              _lhsOleft =
                  _lhsIleft
              _lhsOright =
                  _lhsIright
          in  ( _lhsOcount,_lhsOgathToc,_lhsOhtml,_lhsOleft,_lhsOright)))
-- Root --------------------------------------------------------
data Root  = Root_Root (Docs ) 
           deriving ( Show)
-- cata
sem_Root :: Root  ->
            T_Root 
sem_Root (Root_Root _body )  =
    (sem_Root_Root (sem_Docs _body ) )
-- semantic domain
type T_Root  = ( PP_Doc)
data Inh_Root  = Inh_Root {}
data Syn_Root  = Syn_Root {html_Syn_Root :: PP_Doc}
wrap_Root :: T_Root  ->
             Inh_Root  ->
             Syn_Root 
wrap_Root sem (Inh_Root )  =
    (let ( _lhsOhtml) = sem 
     in  (Syn_Root _lhsOhtml ))
sem_Root_Root :: T_Docs  ->
                 T_Root 
sem_Root_Root body_  =
    (let _bodyOcount :: Int
         _bodyOprefix :: ([Int])
         _bodyOtoc :: PP_Doc
         _bodyOleft :: String
         _bodyOright :: String
         _lhsOhtml :: PP_Doc
         _bodyOlevel :: Int
         _bodyIcount :: Int
         _bodyIgathToc :: PP_Doc
         _bodyIhtml :: PP_Doc
         _bodyIleft :: String
         _bodyIright :: String
         _level =
             1
         _bodyOcount =
             1
         _bodyOprefix =
             []
         _bodyOtoc =
             ul _bodyIgathToc
         _bodyOleft =
             ""
         _bodyOright =
             ""
         _lhsOhtml =
             _bodyIhtml
         _bodyOlevel =
             _level
         ( _bodyIcount,_bodyIgathToc,_bodyIhtml,_bodyIleft,_bodyIright) =
             body_ _bodyOcount _bodyOleft _bodyOlevel _bodyOprefix _bodyOright _bodyOtoc 
     in  ( _lhsOhtml))