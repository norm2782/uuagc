{-# OPTIONS_GHC -fbang-patterns #-}
-- UUAGC 0.9.5 (Html.ag)

{-# OPTIONS_GHC -fglasgow-exts -funbox-strict-fields -fdo-lambda-eta-expansion -fvia-C #-}
module Main(main) where

import UU.Parsing
import UU.Scanner.Token
import UU.Scanner.TokenParser
import UU.Scanner.GenTokenOrd()
import UU.Scanner.GenTokenSymbol()
import UU.Scanner.TokenShow()
import UU.Scanner.Position
import Data.List
import UU.Pretty
import System.Environment
import System.IO
import Data.Char

-- Evil, ugly handcrafted scanner.
-- For Haskell-like languages, you can use UU.Scanner (or Alex)
scanBlock :: Pos -> String -> [Token]
scanBlock _ "" = [] 
scanBlock p ('\\' : 'e' : 'n' : 'd' : r)
  = reserved "end" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 't' : 'o' : 'c' : r)
  = reserved "toc" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 'i' : 'n' : 'd' : 'e' : 'x' : r)
  = reserved "index" p : scanBlock (advc 6 p) r
scanBlock p1 ('\\' : 'k' : 'e' : 'y' : 'w' : 'o' : 'r' : 'd' : r)
  = let p2 = advc 8 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "keyword" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'p' : 'a' : 'r' : 'a' : 'g' : 'r' : 'a' : 'p' : 'h' : r)
  = let p2 = advc 10 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "paragraph" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'b' : 'e' : 'g' : 'i' : 'n' : '{' : r1)
  = let p2 = advc 7 p1
        (p3,r2,s1) = untilChar False '}' p2 r1
        p4 = adv p3 (head r2)
        r3 = tail r2
    in   reserved "begin" p1 : valueToken TkString s1 p2 : scanBlock p4 r3
scanBlock p ('\\' : r)
  = errToken "Non-command character \\" p : scanBlock (advc 1 p) r
scanBlock p (c : r)
  | isSpace c = scanBlock (adv p c) r
  | otherwise = errToken ("Unexpected character " ++ show c) p : scanBlock (adv p c) r

untilChar :: Bool -> Char -> Pos -> String -> (Pos, String, String)
untilChar eofAllowed c p s
  = let (l,r) = span (/= c) s
    in if null r && not eofAllowed
       then error "Unexpected EOF"
       else (foldl adv p l, r, l)


-- Parser with starting nonterminal Root
-- Semantic functions generated by UUAG
pRoot :: Parser Token T_Root
pRoot
  = sem_Root_Root <$> pDocs

pDocs :: Parser Token T_Docs
pDocs
  = pFoldr_gr (sem_Docs_Cons, sem_Docs_Nil) pDoc

pDoc :: Parser Token T_Doc
pDoc
  =   sem_Doc_Section   <$ pKey "begin" <*> pString <*> pDocs <* pKey "end"
  <|> sem_Doc_Paragraph <$ pKey "paragraph" <*> pString <* pKey "end"
  <|> sem_Doc_Toc       <$ pKey "toc"
  <|> sem_Doc_Index     <$ pKey "index"
  <|> sem_Doc_Keyword   <$ pKey "keyword" <*> (trim <$> pString) <* pKey "end"

trim :: String -> String
trim
  = (reverse . trimAtFront . reverse) . trimAtFront
  where trimAtFront = dropWhile isSpace

main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: html <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParser toks
       let output = pretty $ transform $ sem
       writeFile dest output

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

runParser :: [Token] -> IO T_Root
runParser
  = parseIOMessage show pRoot

transform :: T_Root -> PP_Doc
transform sem
  = let inh = Inh_Root {}
        syn = wrap_Root sem inh
    in html_Syn_Root syn

augment :: PP_Doc -> PP_Doc
augment doc
  = "<html lang=\"en\"><head><title>Generated HTML document</title></head><body>" >-< doc >-< "</body></html>"

pretty :: PP_Doc -> String
pretty doc
  = disp doc 10000 ""

aHref :: PP a => String -> a -> PP_Doc
aHref bookmark txt
  = "<a href=\"#" >|< bookmark >|< "\">" >|< txt >|< "</a>"

aName :: String -> PP_Doc
aName bookmark
  = "<a name=\"" >|< bookmark >|< "\"/>"

li :: PP a => a -> PP_Doc
li txt
  = "<li>" >|< txt >|< "</li>"

ul :: PP a => a -> PP_Doc
ul txt
  = "<ul>" >|< txt >|< "</ul>"

p :: PP a => a -> PP_Doc
p txt
  = "<p>" >|< txt >|< "</p>"

h :: PP a => Int -> a -> PP_Doc
h n title
  = "<h" >|< show n >|< ">" >|< title >|< "</h" >|< show n >|< ">"

hr :: PP_Doc
hr = pp "<hr/>"
-- Doc ---------------------------------------------------------
data Doc = Doc_Paragraph !(String)
         | Doc_Section !(String) !(Docs)
         | Doc_Toc 
         deriving ( Show)
-- cata
sem_Doc :: Doc ->
           T_Doc
sem_Doc !(Doc_Paragraph _text) =
    (sem_Doc_Paragraph _text)
sem_Doc !(Doc_Section _title _body) =
    (sem_Doc_Section _title (sem_Docs _body))
sem_Doc !(Doc_Toc ) =
    (sem_Doc_Toc )
-- semantic domain
type T_Doc = Int ->
             String ->
             ([Int]) ->
             ( Int,PP_Doc,String,T_Doc_1)
type T_Doc_1 = Int ->
               String ->
               PP_Doc ->
               ( PP_Doc,String)
sem_Doc_Paragraph :: String ->
                     T_Doc
sem_Doc_Paragraph !text_ =
    (\ (!_lhsIcount)
       (!_lhsIleft)
       (!_lhsIprefix) ->
         (let _lhsOcount :: Int
              _lhsOgathToc :: PP_Doc
              _lhsOleft :: String
              _lhsOcount =
                  _lhsIcount
              _lhsOgathToc =
                  empty
              _lhsOleft =
                  _lhsIleft
              ( !sem_Doc_1) =
                  (sem_Doc_Paragraph_1 text_)
          in  ( _lhsOcount,_lhsOgathToc,_lhsOleft,sem_Doc_1)))
sem_Doc_Paragraph_1 :: String ->
                       T_Doc_1
sem_Doc_Paragraph_1 !text_ =
    (\ (!_lhsIlevel)
       (!_lhsIright)
       (!_lhsItoc) ->
         (let _lhsOhtml :: PP_Doc
              _lhsOright :: String
              _lhsOhtml =
                  p text_
              _lhsOright =
                  _lhsIright
          in  ( _lhsOhtml,_lhsOright)))
sem_Doc_Section :: String ->
                   T_Docs ->
                   T_Doc
sem_Doc_Section !title_ !body_ =
    (\ (!_lhsIcount)
       (!_lhsIleft)
       (!_lhsIprefix) ->
         (let _lhsOcount :: Int
              _bodyOprefix :: ([Int])
              _bodyOleft :: String
              _context :: String
              _name :: PP_Doc
              _bodyOcount :: Int
              body_1 :: T_Docs_1
              _bodyIgathToc :: PP_Doc
              _lhsOgathToc :: PP_Doc
              _lhsOleft :: String
              _lhsOcount =
                  1 + _lhsIcount
              _prefix =
                  _lhsIcount : _lhsIprefix
              _bodyOprefix =
                  _prefix
              _bodyOleft =
                  ""
              _context =
                  concat . intersperse "." . map show . reverse $ _prefix
              _name =
                  _context     >#< title_
              _tocline =
                  aHref _context     _name
              _bodyOcount =
                  1
              ( !_bodyIgathToc,!body_1) =
                  (body_ _bodyOcount _bodyOleft _bodyOprefix)
              _lhsOgathToc =
                  _tocline     >-< ul _bodyIgathToc
              _lhsOleft =
                  _context
              ( !sem_Doc_1) =
                  (sem_Doc_Section_1 body_1 _lhsIleft _name _context)
          in  ( _lhsOcount,_lhsOgathToc,_lhsOleft,sem_Doc_1)))
sem_Doc_Section_1 :: T_Docs_1 ->
                     String ->
                     PP_Doc ->
                     String ->
                     T_Doc_1
sem_Doc_Section_1 !body_1 !_lhsIleft !_name !_context =
    (\ (!_lhsIlevel)
       (!_lhsIright)
       (!_lhsItoc) ->
         (let _bodyOtoc :: PP_Doc
              _bodyOlevel :: Int
              _bodyOright :: String
              _bodyIcount :: Int
              _bodyIhtml :: PP_Doc
              _bodyIleft :: String
              _bodyIright :: String
              _lhsOhtml :: PP_Doc
              _lhsOright :: String
              _bodyOtoc =
                  _lhsItoc
              _level =
                  1 + _lhsIlevel
              _bodyOlevel =
                  _level
              _bodyOright =
                  ""
              ( !_bodyIcount,!_bodyIhtml,!_bodyIleft,!_bodyIright) =
                  (body_1 _bodyOlevel _bodyOright _bodyOtoc)
              _lhsOhtml =
                  aName _context
                  >-< h _lhsIlevel _name
                  >-<     (if null _lhsIleft then empty else aHref _lhsIleft "left")
                      >#< (if null _lhsIright then empty else aHref _lhsIright "right")
                  >-< _bodyIhtml
                  >-< hr
              _lhsOright =
                  _context
          in  ( _lhsOhtml,_lhsOright)))
sem_Doc_Toc :: T_Doc
sem_Doc_Toc  =
    (\ (!_lhsIcount)
       (!_lhsIleft)
       (!_lhsIprefix) ->
         (let _lhsOcount :: Int
              _lhsOgathToc :: PP_Doc
              _lhsOleft :: String
              _lhsOcount =
                  _lhsIcount
              _lhsOgathToc =
                  empty
              _lhsOleft =
                  _lhsIleft
              ( !sem_Doc_1) =
                  (sem_Doc_Toc_1 )
          in  ( _lhsOcount,_lhsOgathToc,_lhsOleft,sem_Doc_1)))
sem_Doc_Toc_1 :: T_Doc_1
sem_Doc_Toc_1  =
    (\ (!_lhsIlevel)
       (!_lhsIright)
       (!_lhsItoc) ->
         (let _lhsOhtml :: PP_Doc
              _lhsOright :: String
              _lhsOhtml =
                  h _lhsIlevel "Table Of Contents" >-< _lhsItoc
              _lhsOright =
                  _lhsIright
          in  ( _lhsOhtml,_lhsOright)))
-- Docs --------------------------------------------------------
type Docs = [Doc]
-- cata
sem_Docs :: Docs ->
            T_Docs
sem_Docs !list =
    (Prelude.foldr sem_Docs_Cons sem_Docs_Nil (Prelude.map sem_Doc list))
-- semantic domain
type T_Docs = Int ->
              String ->
              ([Int]) ->
              ( PP_Doc,T_Docs_1)
type T_Docs_1 = Int ->
                String ->
                PP_Doc ->
                ( Int,PP_Doc,String,String)
sem_Docs_Cons :: T_Doc ->
                 T_Docs ->
                 T_Docs
sem_Docs_Cons !hd_ !tl_ =
    (\ (!_lhsIcount)
       (!_lhsIleft)
       (!_lhsIprefix) ->
         (let _tlOprefix :: ([Int])
              _hdOprefix :: ([Int])
              _hdOleft :: String
              _hdOcount :: Int
              hd_1 :: T_Doc_1
              _hdIcount :: Int
              _hdIgathToc :: PP_Doc
              _hdIleft :: String
              _tlOleft :: String
              _tlOcount :: Int
              tl_1 :: T_Docs_1
              _tlIgathToc :: PP_Doc
              _lhsOgathToc :: PP_Doc
              _tlOprefix =
                  _lhsIprefix
              _hdOprefix =
                  _lhsIprefix
              _hdOleft =
                  _lhsIleft
              _hdOcount =
                  _lhsIcount
              ( !_hdIcount,!_hdIgathToc,!_hdIleft,!hd_1) =
                  (hd_ _hdOcount _hdOleft _hdOprefix)
              _tlOleft =
                  _hdIleft
              _tlOcount =
                  _hdIcount
              ( !_tlIgathToc,!tl_1) =
                  (tl_ _tlOcount _tlOleft _tlOprefix)
              _lhsOgathToc =
                  _hdIgathToc >-< _tlIgathToc
              ( !sem_Docs_1) =
                  (sem_Docs_Cons_1 _hdIleft tl_1 hd_1)
          in  ( _lhsOgathToc,sem_Docs_1)))
sem_Docs_Cons_1 :: String ->
                   T_Docs_1 ->
                   T_Doc_1 ->
                   T_Docs_1
sem_Docs_Cons_1 !_hdIleft !tl_1 !hd_1 =
    (\ (!_lhsIlevel)
       (!_lhsIright)
       (!_lhsItoc) ->
         (let _tlOtoc :: PP_Doc
              _tlOlevel :: Int
              _tlOright :: String
              _tlIcount :: Int
              _tlIhtml :: PP_Doc
              _tlIleft :: String
              _tlIright :: String
              _lhsOcount :: Int
              _hdOtoc :: PP_Doc
              _hdOlevel :: Int
              _hdOright :: String
              _hdIhtml :: PP_Doc
              _hdIright :: String
              _lhsOhtml :: PP_Doc
              _lhsOleft :: String
              _lhsOright :: String
              _tlOtoc =
                  _lhsItoc
              _tlOlevel =
                  _lhsIlevel
              _tlOright =
                  _lhsIright
              ( !_tlIcount,!_tlIhtml,!_tlIleft,!_tlIright) =
                  (tl_1 _tlOlevel _tlOright _tlOtoc)
              _lhsOcount =
                  _tlIcount
              _hdOtoc =
                  _lhsItoc
              _hdOlevel =
                  _lhsIlevel
              _hdOright =
                  _tlIright
              ( !_hdIhtml,!_hdIright) =
                  (hd_1 _hdOlevel _hdOright _hdOtoc)
              _lhsOhtml =
                  _hdIhtml >-< _tlIhtml
              _lhsOleft =
                  _tlIleft
              _lhsOright =
                  _hdIright
          in  ( _lhsOcount,_lhsOhtml,_lhsOleft,_lhsOright)))
sem_Docs_Nil :: T_Docs
sem_Docs_Nil  =
    (\ (!_lhsIcount)
       (!_lhsIleft)
       (!_lhsIprefix) ->
         (let _lhsOgathToc :: PP_Doc
              _lhsOgathToc =
                  empty
              ( !sem_Docs_1) =
                  (sem_Docs_Nil_1 _lhsIcount _lhsIleft)
          in  ( _lhsOgathToc,sem_Docs_1)))
sem_Docs_Nil_1 :: Int ->
                  String ->
                  T_Docs_1
sem_Docs_Nil_1 !_lhsIcount !_lhsIleft =
    (\ (!_lhsIlevel)
       (!_lhsIright)
       (!_lhsItoc) ->
         (let _lhsOcount :: Int
              _lhsOhtml :: PP_Doc
              _lhsOleft :: String
              _lhsOright :: String
              _lhsOcount =
                  _lhsIcount
              _lhsOhtml =
                  empty
              _lhsOleft =
                  _lhsIleft
              _lhsOright =
                  _lhsIright
          in  ( _lhsOcount,_lhsOhtml,_lhsOleft,_lhsOright)))
-- Root --------------------------------------------------------
data Root = Root_Root !(Docs)
          deriving ( Show)
-- cata
sem_Root :: Root ->
            T_Root
sem_Root !(Root_Root _body) =
    (sem_Root_Root (sem_Docs _body))
-- semantic domain
type T_Root = ( PP_Doc)
data Inh_Root = Inh_Root {}
data Syn_Root = Syn_Root {html_Syn_Root :: !(PP_Doc)}
wrap_Root !sem !(Inh_Root ) =
    (let ( !_lhsOhtml) =
             (sem )
     in  (Syn_Root _lhsOhtml))
sem_Root_Root :: T_Docs ->
                 T_Root
sem_Root_Root !body_ =
    (let _bodyOlevel :: Int
         _bodyOright :: String
         _bodyOleft :: String
         _bodyOprefix :: ([Int])
         _bodyOcount :: Int
         body_1 :: T_Docs_1
         _bodyIgathToc :: PP_Doc
         _bodyOtoc :: PP_Doc
         _bodyIcount :: Int
         _bodyIhtml :: PP_Doc
         _bodyIleft :: String
         _bodyIright :: String
         _lhsOhtml :: PP_Doc
         _level =
             1
         _bodyOlevel =
             _level
         _bodyOright =
             ""
         _bodyOleft =
             ""
         _bodyOprefix =
             []
         _bodyOcount =
             1
         ( !_bodyIgathToc,!body_1) =
             (body_ _bodyOcount _bodyOleft _bodyOprefix)
         _bodyOtoc =
             ul _bodyIgathToc
         ( !_bodyIcount,!_bodyIhtml,!_bodyIleft,!_bodyIright) =
             (body_1 _bodyOlevel _bodyOright _bodyOtoc)
         _lhsOhtml =
             _bodyIhtml
     in  ( _lhsOhtml))
