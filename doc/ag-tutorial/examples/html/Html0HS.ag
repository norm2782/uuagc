-- Haskell syntax AG

imports
{
module Main(main) where

import UU.Parsing
import UU.Scanner.Token
import UU.Scanner.TokenParser
import UU.Scanner.GenTokenOrd()
import UU.Scanner.GenTokenSymbol()
import UU.Scanner.TokenShow()
import UU.Scanner.Position
import Data.List
import UU.Pretty
import System.Environment
import System.IO
import Data.Char
}


--
-- Concrete syntax
--

{
-- Evil, ugly handcrafted scanner.
-- For Haskell-like languages, you can use UU.Scanner (or Alex)
scanBlock :: Pos -> String -> [Token]
scanBlock _ "" = [] 
scanBlock p ('\\' : 'e' : 'n' : 'd' : r)
  = reserved "end" p : scanBlock (advc 4 p) r
scanBlock p1 ('\\' : 'p' : 'a' : 'r' : 'a' : 'g' : 'r' : 'a' : 'p' : 'h' : r)
  = let p2 = advc 10 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "paragraph" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'b' : 'e' : 'g' : 'i' : 'n' : '{' : r1)
  = let p2 = advc 7 p1
        (p3,r2,s1) = untilChar False '}' p2 r1
        p4 = adv p3 (head r2)
        r3 = tail r2
    in   reserved "begin" p1 : valueToken TkString s1 p2 : scanBlock p4 r3
scanBlock p ('\\' : r)
  = errToken "Non-command character \\" p : scanBlock (advc 1 p) r
scanBlock p (c : r)
  | isSpace c = scanBlock (adv p c) r
  | otherwise = errToken ("Unexpected character " ++ show c) p : scanBlock (adv p c) r

untilChar :: Bool -> Char -> Pos -> String -> (Pos, String, String)
untilChar eofAllowed c p s
  = let (l,r) = span (/= c) s
    in if null r && not eofAllowed
       then error "Unexpected EOF"
       else (foldl adv p l, r, l)


-- Parser with starting nonterminal Root
-- Semantic functions generated by UUAG
pRoot :: Parser Token T_Root
pRoot
  = sem_Root_Root <$> pDocs

pDocs :: Parser Token T_Docs
pDocs
  = pFoldr_gr (sem_Docs_Cons, sem_Docs_Nil) pDoc

pDoc :: Parser Token T_Doc
pDoc
  =   sem_Doc_Section   <$ pKey "begin" <*> pString <*> pDocs <* pKey "end"
  <|> sem_Doc_Paragraph <$ pKey "paragraph" <*> pString <* pKey "end"

trim :: String -> String
trim
  = (reverse . trimAtFront . reverse) . trimAtFront
  where trimAtFront = dropWhile isSpace
}


--
-- Abstract syntax
--

-- Give a name to lists such that we can give a semantics (with constructors Cons and Nil)
data Docs
  | Cons  hd :: Doc
          tl :: Docs
  | Nil

data Doc
  | Section
      title :: {String}
      body  :: Docs
  | Paragraph
      text  :: {String}

data Root
  | Root
      body :: Docs

-- Derive show instances when generating Haskell data types for these data declarations
deriving * : Show

-- Generates an interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = html_Syn_Root syn
wrapper Root


--
-- Html generation
--

attr Root Docs Doc syn html :: String

sem Doc
  | Section
      lhs.html = "<b>" ++ @title ++ "</b>\n" ++ @body.html
  | Paragraph
      lhs.html = "<p>" ++ @text ++ "</p>"

sem Docs
  | Cons
      lhs.html  =  @hd.html ++ @tl.html
  | Nil
      lhs.html  =  ""


--
-- Pipeline
--

{
main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: html <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParser toks
       let output = transform $ sem
       writeFile dest output

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

runParser :: [Token] -> IO T_Root
runParser
  = parseIOMessage show pRoot

transform :: T_Root -> String
transform sem
  = let inh = Inh_Root {}
        syn = wrap_Root sem inh
    in html_Syn_Root syn

augment :: String -> String
augment doc
  = "<html lang=\"en\"><head><title>Generated HTML document</title></head><body>\n" ++ doc ++ "\n</body></html>"

}


