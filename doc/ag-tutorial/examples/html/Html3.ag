-- Plain AG

imports
{
module Main(main) where

import UU.Parsing
import UU.Scanner.Token
import UU.Scanner.TokenParser
import UU.Scanner.GenTokenOrd()
import UU.Scanner.GenTokenSymbol()
import UU.Scanner.TokenShow()
import UU.Scanner.Position
import Data.List
import UU.Pretty
import System.Environment
import System.IO
import Data.Char
}


--
-- Concrete syntax
--

{
-- Evil, ugly handcrafted scanner.
-- For Haskell-like languages, you can use UU.Scanner (or Alex)
scanBlock :: Pos -> String -> [Token]
scanBlock _ "" = [] 
scanBlock p ('\\' : 'e' : 'n' : 'd' : r)
  = reserved "end" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 't' : 'o' : 'c' : r)
  = reserved "toc" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 'i' : 'n' : 'd' : 'e' : 'x' : r)
  = reserved "index" p : scanBlock (advc 6 p) r
scanBlock p1 ('\\' : 'k' : 'e' : 'y' : 'w' : 'o' : 'r' : 'd' : r)
  = let p2 = advc 8 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "keyword" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'p' : 'a' : 'r' : 'a' : 'g' : 'r' : 'a' : 'p' : 'h' : r)
  = let p2 = advc 10 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "paragraph" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'b' : 'e' : 'g' : 'i' : 'n' : '{' : r1)
  = let p2 = advc 7 p1
        (p3,r2,s1) = untilChar False '}' p2 r1
        p4 = adv p3 (head r2)
        r3 = tail r2
    in   reserved "begin" p1 : valueToken TkString s1 p2 : scanBlock p4 r3
scanBlock p ('\\' : r)
  = errToken "Non-command character \\" p : scanBlock (advc 1 p) r
scanBlock p (c : r)
  | isSpace c = scanBlock (adv p c) r
  | otherwise = errToken ("Unexpected character " ++ show c) p : scanBlock (adv p c) r

untilChar :: Bool -> Char -> Pos -> String -> (Pos, String, String)
untilChar eofAllowed c p s
  = let (l,r) = span (/= c) s
    in if null r && not eofAllowed
       then error "Unexpected EOF"
       else (foldl adv p l, r, l)


-- Parser with starting nonterminal Root
-- Semantic functions generated by UUAG
pRoot :: Parser Token T_Root
pRoot
  = sem_Root_Root <$> pDocs

pDocs :: Parser Token T_Docs
pDocs
  = pFoldr_gr (sem_Docs_Cons, sem_Docs_Nil) pDoc

pDoc :: Parser Token T_Doc
pDoc
  =   sem_Doc_Section   <$ pKey "begin" <*> pString <*> pDocs <* pKey "end"
  <|> sem_Doc_Paragraph <$ pKey "paragraph" <*> pString <* pKey "end"
  <|> sem_Doc_Toc       <$ pKey "toc"
  <|> sem_Doc_Index     <$ pKey "index"
  <|> sem_Doc_Keyword   <$ pKey "keyword" <*> (trim <$> pString) <* pKey "end"

trim :: String -> String
trim
  = (reverse . trimAtFront . reverse) . trimAtFront
  where trimAtFront = dropWhile isSpace
}


--
-- Abstract syntax
--

-- Give a name to lists such that we can give a semantics (with constructors Cons and Nil)
TYPE Docs = [Doc]

DATA Doc
  | Section
      title : {String}
      body  : Docs
  | Paragraph
      text  : {String}
  | Toc

  -- following are included because it is part of the test, but not used
  | Index
  | Keyword
      text  : {String}

DATA Root
  | Root
      body : Docs

-- Derive show instances when generating Haskell data types for these data declarations
DERIVING * : Show

-- Generates an interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = html_Syn_Root syn
WRAPPER Root


--
-- Level attribute
--


ATTR Docs Doc [ level : Int | | ]

SEM Root
  | Root
      loc.level = 1

SEM Doc
  | Section
      loc.level = 1 + @lhs.level


--
-- count attribute
-- (sibling counter)
--

ATTR Docs Doc [ | count : Int | ]

SEM Root
  | Root
      body.count = 1

SEM Doc
  | Section
      lhs.count  = 1 + @lhs.count
      body.count = 1


--
-- Context attribute
--   lhs.prefix is the prefix to the current node (i.e. 1.2)
--   loc.prefix is the prefix containing the current node (i.e. 1.2.5)
--   loc.context is a string representation of the prefix of the current node
--

ATTR Docs Doc [ prefix : {[Int]} | | ]
SEM Root
  | Root
      body.prefix = []

SEM Doc
  | Section
      loc.prefix  = @lhs.count : @lhs.prefix
      loc.context = concat . intersperse "." . map show . reverse $ @loc.prefix
      
      loc.context : {String}  -- type signature needed because loc.context is needed in more than one visit


--
-- Table of contents attribute
--

ATTR Docs Doc [ toc : PP_Doc | | gathToc USE {>-<} {empty} : {PP_Doc} ]

SEM Root
  | Root
      body.toc = ul @body.gathToc

SEM Doc
  | Section
      loc.name    = @loc.context >#< @title
      loc.tocline = aHref @loc.context @loc.name
      lhs.gathToc = @loc.tocline >-< ul @body.gathToc
      
      loc.name : {PP_Doc}  -- type signature needed because loc.name is needed in more than one visit


--
-- Left attribute
--

ATTR Docs Doc [ | left : String | ]

SEM Root
  | Root
      body.left = ""

SEM Doc
  | Section
      body.left = ""
      lhs.left  = @loc.context

--
-- Right attribute
--

ATTR Docs Doc [ | right : String | ]

SEM Root
  | Root
      body.right = ""

SEM Doc
  | Section
      body.right = ""
      lhs.right  = @loc.context

-- manually implement right-to-left copy rule
SEM Docs
  | Cons
      tl.right = @lhs.right
      hd.right  = @tl.right
      lhs.right = @hd.right


--
-- Add some artificial dependencies to tweak the scheduler
--

{-
SEM Docs
  | Cons
      hd.left < tl.right

SEM Doc
  | Paragraph
      lhs.left < lhs.gathToc
      lhs.prefix < lhs.gathToc
-}


--
-- Html generation
--

ATTR Root Docs Doc [ | | html USE {>-<} {empty} : PP_Doc ]

SEM Doc
  | Section
      lhs.html = aName @loc.context
                 >-< h @lhs.level @loc.name
                 >-<     (if null @lhs.left then empty else aHref @lhs.left "left")
                     >#< (if null @lhs.right then empty else aHref @lhs.right "right")
                 >-< @body.html
                 >-< hr
                  
  | Paragraph
      lhs.html = p @text
  | Toc
      lhs.html = h @lhs.level "Table Of Contents" >-< @lhs.toc


--
-- Pipeline
--

{
main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: html <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParser toks
       let output = pretty $ transform $ sem
       writeFile dest output

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

runParser :: [Token] -> IO T_Root
runParser
  = parseIOMessage show pRoot

transform :: T_Root -> PP_Doc
transform sem
  = let inh = Inh_Root {}
        syn = wrap_Root sem inh
    in html_Syn_Root syn

augment :: PP_Doc -> PP_Doc
augment doc
  = "<html lang=\"en\"><head><title>Generated HTML document</title></head><body>" >-< doc >-< "</body></html>"

pretty :: PP_Doc -> String
pretty doc
  = disp doc 10000 ""
}


--
-- Html pretty printing
--

{
aHref :: PP a => String -> a -> PP_Doc
aHref bookmark txt
  = "<a href=\"#" >|< bookmark >|< "\">" >|< txt >|< "</a>"

aName :: String -> PP_Doc
aName bookmark
  = "<a name=\"" >|< bookmark >|< "\"/>"

li :: PP a => a -> PP_Doc
li txt
  = "<li>" >|< txt >|< "</li>"

ul :: PP a => a -> PP_Doc
ul txt
  = "<ul>" >|< txt >|< "</ul>"

p :: PP a => a -> PP_Doc
p txt
  = "<p>" >|< txt >|< "</p>"

h :: PP a => Int -> a -> PP_Doc
h n title
  = "<h" >|< show n >|< ">" >|< title >|< "</h" >|< show n >|< ">"

hr :: PP_Doc
hr = pp "<hr/>"
}

