-- Haskell syntax AG

imports
{
module Main(main) where

import UU.Parsing
import UU.Scanner.Token
import UU.Scanner.TokenParser
import UU.Scanner.GenTokenOrd()
import UU.Scanner.GenTokenSymbol()
import UU.Scanner.TokenShow()
import UU.Scanner.Position
import Data.List
import UU.Pretty
import System.Environment
import System.IO
import Data.Char
}


--
-- Concrete syntax
--

{
-- Evil, ugly handcrafted scanner.
-- For Haskell-like languages, you can use UU.Scanner (or Alex)
scanBlock :: Pos -> String -> [Token]
scanBlock _ "" = [] 
scanBlock p ('\\' : 'e' : 'n' : 'd' : r)
  = reserved "end" p : scanBlock (advc 4 p) r
scanBlock p ('\\' : 't' : 'o' : 'c' : r)
  = reserved "toc" p : scanBlock (advc 4 p) r
scanBlock p1 ('\\' : 'p' : 'a' : 'r' : 'a' : 'g' : 'r' : 'a' : 'p' : 'h' : r)
  = let p2 = advc 10 p1
        (p3,r',s) = untilChar True '\\' p2 r
    in reserved "paragraph" p1 : valueToken TkString s p2 : scanBlock p3 r'
scanBlock p1 ('\\' : 'b' : 'e' : 'g' : 'i' : 'n' : '{' : r1)
  = let p2 = advc 7 p1
        (p3,r2,s1) = untilChar False '}' p2 r1
        p4 = adv p3 (head r2)
        r3 = tail r2
    in   reserved "begin" p1 : valueToken TkString s1 p2 : scanBlock p4 r3
scanBlock p ('\\' : r)
  = errToken "Non-command character \\" p : scanBlock (advc 1 p) r
scanBlock p (c : r)
  | isSpace c = scanBlock (adv p c) r
  | otherwise = errToken ("Unexpected character " ++ show c) p : scanBlock (adv p c) r

untilChar :: Bool -> Char -> Pos -> String -> (Pos, String, String)
untilChar eofAllowed c p s
  = let (l,r) = span (/= c) s
    in if null r && not eofAllowed
       then error "Unexpected EOF"
       else (foldl adv p l, r, l)


-- Parser with starting nonterminal Root, mapping to datatype
-- Datatypes generated by UUAG
pRoot :: Parser Token Root
pRoot
  = Root_Root <$> pDocs

pDocs :: Parser Token Docs
pDocs
  = pList pDoc

pDoc :: Parser Token Doc
pDoc
  =   Doc_Section   <$ pKey "begin" <*> pString <*> pDocs <* pKey "end"
  <|> Doc_Paragraph <$ pKey "paragraph" <*> pString <* pKey "end"
  <|> Doc_Toc       <$ pKey "toc"

-- Parser with starting nonterminal Root, mapping to semantics directly
-- Semantic functions generated by UUAG
pRootS :: Parser Token T_Root
pRootS
  = sem_Root_Root <$> pDocsS

pDocsS :: Parser Token T_Docs
pDocsS
  = pFoldr_gr (sem_Docs_Cons, sem_Docs_Nil) pDocS

pDocS :: Parser Token T_Doc
pDocS
  =   sem_Doc_Section   <$ pKey "begin" <*> pString <*> pDocsS <* pKey "end"
  <|> sem_Doc_Paragraph <$ pKey "paragraph" <*> pString <* pKey "end"
  <|> sem_Doc_Toc       <$ pKey "toc"

trim :: String -> String
trim
  = (reverse . trimAtFront . reverse) . trimAtFront
  where trimAtFront = dropWhile isSpace
}


--
-- Abstract syntax
--

-- Give a name to lists such that we can give a semantics (with constructors Cons and Nil)
type Docs = [Doc]

data Doc
  | Section
      title :: {String}
      body  :: Docs
  | Paragraph
      text  :: {String}
  | Toc

data Root
  | Root
      body :: Docs

-- Derive show instances when generating Haskell data types for these data declarations
deriving * : Show

-- Generates an interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = html_Syn_Root syn
wrapper Root


--
-- Level attribute
--


attr Docs Doc inh level :: Int

sem Root
  | Root
      loc.level = 1

sem Doc
  | Section
      loc.level = 1 + @lhs.level


--
-- count attribute
-- (sibling counter)
--

attr Docs Doc  inh count :: Int
               syn count :: Int

sem Root
  | Root
      body.count = 1

sem Doc
  | Section
      lhs.count  = 1 + @lhs.count
      body.count = 1


--
-- Context attribute
--   lhs.prefix is the prefix to the current node (i.e. 1.2)
--   loc.prefix is the prefix containing the current node (i.e. 1.2.5)
--   loc.context is a string representation of the prefix of the current node
--

attr Docs Doc inh prefix :: {[Int]}
sem Root
  | Root
      body.prefix = []

sem Doc
  | Section
      loc.prefix  = @lhs.count : @lhs.prefix
      loc.context = concat . intersperse "." . map show . reverse $ @loc.prefix
      
      loc.context :: {String}  -- type signature needed because loc.context is needed in more than one visit


--
-- Table of contents attribute
--

attr Docs Doc  inh toc :: PP_Doc
               syn gathToc use {>-<} {empty} :: {PP_Doc}

sem Root
  | Root
      body.toc = ul @body.gathToc

sem Doc
  | Section
      loc.name    = @loc.context >#< @title
      loc.tocline = aHref @loc.context @loc.name
      lhs.gathToc = @loc.tocline >-< ul @body.gathToc
      
      loc.name :: {PP_Doc}  -- type signature needed because loc.name is needed in more than one visit


--
-- Html generation
--

attr Root Docs Doc syn html use {>-<} {empty} :: PP_Doc

sem Doc
  | Section
      lhs.html = aName @loc.context
                 >-< h @lhs.level @loc.name
                 >-< @body.html
                 >-< hr
                  
  | Paragraph
      lhs.html = p @text
  | Toc
      lhs.html = h @lhs.level "Table Of Contents" >-< @lhs.toc


--
-- Pipeline
--

{
main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: html <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       root <- runParser toks
       let output = pretty $ transform root
       writeFile dest output

compileS :: String -> String -> IO ()
compileS source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParserS toks
       let output = pretty $ transformS $ sem
       writeFile dest output

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

runParser :: [Token] -> IO Root
runParser
  = parseIOMessage show pRoot

runParserS :: [Token] -> IO T_Root
runParserS
  = parseIOMessage show pRootS

transform :: Root -> PP_Doc
transform r
  = html_Syn_Root syn
  where inh = Inh_Root {}
        syn = wrap_Root (sem_Root r) inh

transformS :: T_Root -> PP_Doc
transformS sem
  = html_Syn_Root syn
  where inh = Inh_Root {}
        syn = wrap_Root sem inh

augment :: PP_Doc -> PP_Doc
augment doc
  = "<html lang=\"en\"><head><title>Generated HTML document</title></head><body>" >-< doc >-< "</body></html>"

pretty :: PP_Doc -> String
pretty doc
  = disp doc 10000 ""
}


--
-- Html pretty printing
--

{
aHref :: PP a => String -> a -> PP_Doc
aHref bookmark txt
  = "<a href=\"#" >|< bookmark >|< "\">" >|< txt >|< "</a>"

aName :: String -> PP_Doc
aName bookmark
  = "<a name=\"" >|< bookmark >|< "\"/>"

li :: PP a => a -> PP_Doc
li txt
  = "<li>" >|< txt >|< "</li>"

ul :: PP a => a -> PP_Doc
ul txt
  = "<ul>" >|< txt >|< "</ul>"

p :: PP a => a -> PP_Doc
p txt
  = "<p>" >|< txt >|< "</p>"

h :: PP a => Int -> a -> PP_Doc
h n title
  = "<h" >|< show n >|< ">" >|< title >|< "</h" >|< show n >|< ">"

hr :: PP_Doc
hr = pp "<hr/>"
}

