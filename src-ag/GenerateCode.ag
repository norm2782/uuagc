INCLUDE "CodeSyntax.ag"
INCLUDE "Patterns.ag"
INCLUDE "DeclBlocks.ag"

imports
{
import SequentialTypes
import Code hiding (Type)
import qualified Code
import Options
import CodeSyntax
import ErrorMessages
import GrammarInfo
import DeclBlocks

import qualified Data.Map as Map
import Data.Map(Map) 
import qualified Data.Set as Set
import Data.Set(Set) 
import qualified UU.DData.Seq as Seq
import UU.DData.Seq(Seq)
import UU.Scanner.Position

import Data.List(partition,intersperse,intersect,(\\))
import Maybe(fromJust,isJust)
}


-------------------------------------------------------------------------------
--         Options
-------------------------------------------------------------------------------

ATTR CProductions CProduction
     CAlternatives CAlternative
     CVisits CVisit
     Sequence CRule
     CInterface CSegments CSegment
       [ o_unbox,o_sig,o_sem,o_newtypes,o_case,o_pretty,o_rename,o_cata,o_strictwrap,o_splitsems,o_traces,o_costcentre,o_linePragmas : Bool
         o_data : {Maybe Bool}
         prefix : String
       | | ]
SEM CGrammar [ options : Options | | ]
  | CGrammar    prods.o_sig         = typeSigs      @lhs.options
                     .o_cata        = folds         @lhs.options
                     .o_sem         = semfuns       @lhs.options
                     .o_newtypes    = newtypes      @lhs.options
                     .o_unbox       = unbox         @lhs.options
                     .o_case        = cases         @lhs.options
                     .o_pretty      = attrInfo      @lhs.options
                     .o_rename      = rename        @lhs.options
                     .o_strictwrap  = strictWrap    @lhs.options
                     .o_splitsems   = splitSems     @lhs.options
                     .o_data        = if dataTypes @lhs.options then Just (strictData @lhs.options) else Nothing
                     .prefix        = prefix        @lhs.options
                     .o_traces      = genTraces     @lhs.options
                     .o_costcentre  = genCostCentres @lhs.options
                     .o_linePragmas = genLinePragmas @lhs.options

ATTR CProductions CProduction CAlternatives CAlternative CVisits CVisit [ allPragmas : PragmaMap | | ]

SEM CGrammar
  | CGrammar  prods.allPragmas = @pragmas

-------------------------------------------------------------------------------
-- Passing information about nonterminal and constructor down
-------------------------------------------------------------------------------

ATTR  CAlternatives CAlternative CVisits 
      CVisit Sequence CRule CInterface 
      CSegments CSegment [ nt:Nonterminal inh,syn:Attributes | | ]
SEM  CProduction
  |  CProduction  inter.(inh,syn,nt) = (@inh,@syn,@nt)
                  alts.(inh,syn,nt) = (@inh,@syn,@nt)

ATTR CVisits CVisit Sequence CRule [ con:Constructor 
                                     terminals : {[Name]} | | ]
SEM  CAlternative
  |  CAlternative  visits.con = @con
                   visits.terminals = @terminals

-------------------------------------------------------------------------------
-- Generating declarations from the sequence. We generate the origin
-- comment if pretty printing is requested. A childvisit takes inherited
-- attributes and returns synthesized attributes and the next visit.
-------------------------------------------------------------------------------

ATTR  Sequence CRule [ | | decls USE {++} {[]} : {Decls} ]
SEM  CRule
  |  CRule loc.instTypes = map (\(n,NT t,_) -> (n,t)) @lhs.higherOrderChildren
           loc.originComment = if  @lhs.o_pretty
                                   then (Comment @origin:)
                                   else id
           loc.instDecls = [ Decl (Pattern3 (Alias _INST' inst (Underscore (getPos inst)) []))
                                  (App (cataname @lhs.prefix (fromJust $ inst `lookup` @loc.instTypes))
                                       [SimpleExpr instLocFieldName])
                                  (Set.singleton instSemFieldName)
                                  (Set.singleton instLocFieldName)
                           | inst <- @loc.definedInsts
                           , let instLocFieldName = attrname True _INST inst
                           , let instSemFieldName = attrname False _INST' inst ]
           loc.patDescr = if @isIn
                          then "_"
                          else concat $ intersperse "," (map (\(f,a) -> show f ++ "." ++ show a) @pattern.patternAttributes)
           loc.traceDescr = show @nt ++ " :: " ++ show @con ++ " :: " ++ @loc.patDescr
                              
           loc.addTrace = \v -> if @lhs.o_traces
                                then Trace @loc.traceDescr v
                                else v
           loc.costCentreDescr = show @nt ++ ":" ++ show @con ++ ":" ++ @loc.patDescr
           loc.addCostCentre = \v -> if @lhs.o_costcentre
                                     then PragmaExpr True False ("SCC \"" ++ @loc.costCentreDescr ++ "\"") v
                                     else v
           loc.addLinePragma = \v -> let p = getPos @name
                                         hasPos = line p > 0 && column p >= 0 && not (null (file p))
                                     in if @lhs.o_linePragmas && hasPos
                                        then PragmaExpr True True ("LINE " ++ show (line p) ++ " " ++ show (file p))
                                             $ LineExpr
                                             $ v
                                        else v
           loc.decls = if @hasCode
                       then @originComment ( Decl (Pattern3 @pattern.copy) (@loc.addTrace $ @loc.addCostCentre $ @loc.addLinePragma $ (TextExpr @rhs))
                                                  (Set.fromList [attrname False fld nm | (fld,nm,_) <- Map.elems @defines])
                                                  (Set.fromList [attrname True fld nm | (fld,nm) <- Set.toList @uses])
                                           : @loc.instDecls)
                       else @loc.instDecls
  |  CChildVisit loc.costCentreDescr = show @lhs.nt ++ ":" ++ show @lhs.con ++ ":" ++ show @name ++ ":" ++ show @nt ++ ":" ++ show @nr
                 loc.addCostCentre = \v -> if @lhs.o_costcentre
                                           then PragmaExpr True False ("SCC \"" ++ @loc.costCentreDescr ++ "\"") v
                                           else v
                 loc.decls = let  lhsVars =  map (attrname True @name) (Map.keys @syn)
                                             ++ if @isLast then [] else [unwrap ++ funname @name (@nr+1)]
                                  rhsVars = map (attrname False @name) (Map.keys @inh)
                                  unwrap = if @lhs.o_newtypes then typeName @nt (@nr + 1) ++ " " else ""
                                  tuple = mkTupleLhs @lhs.o_unbox (null $ Map.keys @inh) lhsVars
                                  rhs = @loc.addCostCentre $ App (funname @name @nr) (map SimpleExpr rhsVars)
                             in [Decl tuple rhs (Set.fromList lhsVars) (Set.fromList (funname @name @nr : rhsVars))]

ATTR Sequence CRule [ higherOrderChildren : {[(Name,Type,Bool)]} ||]

ATTR Sequence CRule Pattern Patterns [|| definedInsts USE {++} {[]} : {[Identifier]} ]
SEM Pattern
  | Alias lhs.definedInsts = (if @field == _INST then [@attr] else []) ++ @pat.definedInsts

SEM CRule
  | CRule  loc.definedInsts = if @isIn then [] else @pattern.definedInsts

ATTR Pattern Patterns [ | | patternAttributes USE {++} {[]} : {[(Name, Name)]} ]
SEM Pattern
  | Alias
      lhs.patternAttributes = (@field,@attr) : (@pat.patternAttributes ++ @parts.patternAttributes)

-------------------------------------------------------------------------------
-- Numbering the visits
-------------------------------------------------------------------------------

ATTR  CVisits CVisit Sequence CRule
      CSegments CSegment [ nr : Int | | ]
SEM  CAlternative
  |  CAlternative visits.nr = 0
SEM  CVisits
  |  Cons tl.nr = @lhs.nr + 1
SEM  CInterface
  |  CInterface seg.nr = 0
SEM  CSegments
  |  Cons tl.nr = @lhs.nr + 1

-------------------------------------------------------------------------------
-- Checking last visit
-------------------------------------------------------------------------------

ATTR CVisit CSegment [ isLast : Bool | | ]
ATTR CVisits CSegments [ | | isNil : Bool ]
SEM  CVisits
  |  Cons  lhs.isNil = False
           hd.isLast = @tl.isNil
  |  Nil lhs.isNil = True
SEM  CSegments
  |  Cons  lhs.isNil = False
           hd.isLast = @tl.isNil
  |  Nil lhs.isNil = True

-------------------------------------------------------------------------------
-- Getting the next intra-visit dependencies
-------------------------------------------------------------------------------

ATTR CVisit [ nextIntra : {Exprs} nextIntraVars : {Set String} | | ]
ATTR CVisits CVisit [ | | intra : {Exprs} intraVars : {Set String} ]
SEM  CVisit 
  |  CVisit lhs.intra = @intra.exprs
            lhs.intraVars = @intra.usedVars
SEM  CVisits
  |  Cons  hd.nextIntra = @tl.intra
           hd.nextIntraVars = @tl.intraVars
           lhs.intra = @hd.intra
           lhs.intraVars = @hd.intraVars
  |  Nil lhs.intra = []
         lhs.intraVars = Set.empty

-------------------------------------------------------------------------------
-- Superfluous intra-visit dependencies due to higher-order children
--  (higher-order children can only be passed from their moment of creation)
-------------------------------------------------------------------------------

SEM CRule
  | CChildVisit
      loc.isSuperfluousHigherOrderIntra
        = @lhs.nr <= Map.findWithDefault (-1) @name @lhs.instVisitNrs

-------------------------------------------------------------------------------
-- Intra-visit dependencies are expressions that need to be passed
-------------------------------------------------------------------------------

ATTR  Sequence CRule [ | | exprs USE {++} {[]} : {Exprs} ]
SEM  CRule
  |  CRule loc.name = if  @field == _LOC && @name `elem` @lhs.terminals
                      then funname @name 0
                      else attrname @isIn @field @name
           lhs.exprs = [SimpleExpr @loc.name]
  |  CChildVisit 
       loc.names = -- do not pass inst-childs as parameter if they are not defined yet
                   if @loc.isSuperfluousHigherOrderIntra
                   then []
                   else [funname @name (@nr+1)]
       lhs.exprs = let wrap = if @lhs.o_newtypes then \x -> App (typeName @nt (@nr + 1)) [x] else id
                   in map (wrap . SimpleExpr) @loc.names

ATTR  Sequence CRule [ | | usedVars USE {`Set.union`} {Set.empty} : {Set String} ]
SEM CRule
  | CRule
      lhs.usedVars = Set.singleton @loc.name
  | CChildVisit
      lhs.usedVars = Set.fromList @loc.names

-------------------------------------------------------------------------------
-- Type signatures are added to the declarations. 
-------------------------------------------------------------------------------

ATTR Sequence CRule [ | | tSigs USE {++} {[]} : {[Decl]} ]
SEM  CRule
  |  CRule        loc.mkTp = SimpleType . typeToString @lhs.nt
                  lhs.tSigs = [ TSig (attrname False field attr) (@mkTp (fromJust tp)) 
                              |  (field,attr,tp) <- Map.elems @defines, isJust tp ]
  |  CChildVisit  loc.mkTp = SimpleType . typeToString @nt
                  loc.definedTps = [ TSig (attrname True @name a) (@mkTp tp) |  (a,tp) <- Map.toList @syn ]
                  loc.nextTp = typeName @nt (@nr+1)
                  lhs.tSigs = (if @isLast then id else (TSig (funname @name (@nr+1)) (SimpleType @nextTp) :)) @definedTps

-------------------------------------------------------------------------------
-- Types of intra-visit dependencies are needed in the type of the
-- semantic function.
-------------------------------------------------------------------------------

{
substSelf nt tp = if tp==NT _SELF 
                  then Haskell (getName nt)
                  else tp
}

ATTR CVisits CVisit Sequence CRule [ children : {[(Name,Type,Bool)]} | | ]
SEM  CAlternative
  |  CAlternative visits.children = @children


ATTR Sequence CRule [ | | tps USE {++} {[]} : {[Type]} 
                          allTpsFound USE {&&} {True} : Bool ]
SEM  CRule
  |  CRule        lhs.(tps,allTpsFound) = maybe ([],False) (\tp -> ([substSelf (fromJust @childnt) tp],True)) @tp
  |  CChildVisit  lhs.tps = if @loc.isSuperfluousHigherOrderIntra
                            then []
                            else [Haskell @nextTp]

-------------------------------------------------------------------------------
-- Each visit has its semantic function
-------------------------------------------------------------------------------

ATTR CVisits CVisit [ | | decls USE {++} {[]} : {Decls} ]
SEM  CVisit
  |  CVisit (loc.higherOrderChildren,loc.firstOrderChildren) = partition (\(_,_,ho) -> ho) @lhs.children
            loc.funcname = seqSemname @lhs.prefix @lhs.nt @lhs.con @lhs.nr
            loc.nextVisitName = if @lhs.isLast then [] else [visitname @lhs.prefix @lhs.nt (@lhs.nr+1)]
            loc.nextVisitDecl = let  lhs = TupleLhs @nextVisitName
                                     rhs = App fun @lhs.nextIntra
                                     fun = seqSemname @lhs.prefix @lhs.nt @lhs.con (@lhs.nr+1)
                                in if @lhs.isLast
                                   then []
                                   else [Decl lhs rhs (Set.fromList @nextVisitName) @lhs.nextIntraVars]
            loc.decls = @typeSigs ++ @vss.decls ++ @nextVisitDecl
            vss.lastExpr = mkTupleExpr @lhs.o_unbox (null $ Map.keys @inh) $ map (SimpleExpr . lhsname False) (Map.keys @syn) ++ map SimpleExpr @nextVisitName
            intra.lastExpr = error "lastExpr: not used here"
            loc.lastExprVars = map (lhsname False) (Map.keys @syn) ++ @loc.nextVisitName
            (loc.blockFunDecls, loc.blockFirstFunCall) = mkPartitionedFunction @loc.funcname @loc.o_case @loc.nextVisitDecl @loc.lastExprVars @vss.blockDecls
            
            loc.costCentreDescr = "b" ++ ":" ++ show @lhs.nt ++ ":" ++ show @lhs.con ++ ":" ++ show @lhs.nr
            loc.addCostCentre = \v -> if @lhs.o_costcentre
                                      then PragmaExpr True False ("SCC \"" ++ @loc.costCentreDescr ++ "\"") v
                                      else v
            
            loc.semFun = let  lhs = Fun @funcname lhs_args
                              lhs_args = if @lhs.nr == 0 then map field @loc.firstOrderChildren else @intra.exprs
                              
                              
                              field (name,NT tp,_) = let unwrap | @lhs.o_newtypes = \x -> App (sdtype tp) [x]
                                                                | otherwise       = id
                                                      in unwrap (SimpleExpr (funname name 0))
                              field (name,_,_)     =  SimpleExpr (funname name 0)
                              
                              rhs = wrap
                                  . mkLambda (map (lhsname True) (Map.keys @inh))
                                  $ @loc.addCostCentre
                                  $ if @ordered && @loc.o_splitsems
                                    then @loc.blockFirstFunCall
                                    else mkLet @o_case @decls
                                         . mkTupleExpr @lhs.o_unbox (null $ Map.keys @inh)
                                         $ map (SimpleExpr . lhsname False) (Map.keys @syn) ++ map SimpleExpr @nextVisitName
                              wrap = if  @lhs.o_newtypes
                                         then \x -> App (typeName @lhs.nt @lhs.nr) [x] 
                                         else id
                         in Decl lhs rhs Set.empty Set.empty
            loc.tsig = TSig @funcname @semType
            loc.semType = let argType (NT tp)      rec | tp /= _SELF = SimpleType (sdtype tp) `Arr` rec
                                                       | tp == _SELF = error "GenerateCode: found an intra-type with type SELF, which should have been prevented by CRule.tps"
                              argType (Haskell tp) rec               = SimpleType tp          `Arr` rec
                          in if  @lhs.nr == 0  
                                 then foldr argType (SimpleType (sdtype   @lhs.nt        )) (map (\(_,t,_) -> t) @loc.firstOrderChildren)
                                 else foldr argType (SimpleType (typeName @lhs.nt @lhs.nr)) @intra.tps
            lhs.decls =  ( if  @lhs.with_sig 
                           then [@tsig, @semFun]
                           else [@semFun]
                         ) ++
                         ( if @ordered && @loc.o_splitsems
                           then @loc.blockFunDecls
                           else []
                         )
            loc.typeSigs =  if  @lhs.o_sig && not @o_case
                                then  @vss.tSigs
                                else  []
            loc.o_case = @lhs.o_case && @ordered && not (hasPragma @lhs.allPragmas @lhs.nt @lhs.con _NOCASE)
            loc.o_splitsems = @ordered && @lhs.o_splitsems

{
mkLambda [] e = e
mkLambda xs e = Lambda xs e
}

ATTR CVisits CVisit Sequence CRule [ instVisitNrs : {Map Identifier Int} || ]
ATTR CVisits CVisit [|| gatherInstVisitNrs USE {`Map.union`} {Map.empty} : {Map Identifier Int} ]
SEM CAlternative
  | CAlternative
      visits.instVisitNrs = @visits.gatherInstVisitNrs

SEM CVisit
  | CVisit
      lhs.gatherInstVisitNrs = Map.fromList [(i,@lhs.nr) | i <- @vss.definedInsts]

-------------------------------------------------------------------------------
-- Generate a partitioned version of the sequence of rules
-------------------------------------------------------------------------------

ATTR Sequence [ lastExpr : Expr | | blockDecls : DeclBlocks ]

ATTR Sequence CRule [ | declsAbove : {[Decl]}  | ]
SEM CVisit
  | CVisit
      vss.declsAbove = []
      intra.declsAbove = error "declsAbove: not used here"

SEM CRule
  | CRule
      lhs.declsAbove = @lhs.declsAbove ++ @loc.decls
  | CChildVisit
      lhs.declsAbove = []

SEM Sequence
  | Cons
      lhs.blockDecls = @hd.bldBlocksFun @tl.blockDecls
  | Nil
      lhs.blockDecls = DeclTerminator @lhs.declsAbove @lhs.lastExpr

ATTR CRule [ | | bldBlocksFun : {DeclBlocks -> DeclBlocks} ]
SEM CRule
  | CRule
      lhs.bldBlocksFun = id
  | CChildVisit
      lhs.bldBlocksFun = DeclBlock @lhs.declsAbove (head @loc.decls)

{
-- dead code - replaced by mkPartitionedFunction
{-
localCpsToExpr :: Bool -> [Decl] -> DeclBlocks -> Expr
localCpsToExpr o_case nextVisitDecl
  = rec
  where
    rec cps
      = case cps of
          DeclTerminator decls expr
            -> mkLet o_case (decls ++ nextVisitDecl) expr
          DeclBlock decls (Decl lhs rhs _ _) remainder
            -> let inDecls = [ PragmaDecl ("NOINLINE " ++ internalCpsName)
                             , Decl (Fun internalCpsName [SimpleExpr internalCpsVarName])
                                    (mkLet o_case [Decl lhs (SimpleExpr internalCpsVarName) Set.empty Set.empty] (rec remainder))
                                    Set.empty Set.empty
                             ]
                   inBody = App "head" [App "(:)" [App internalCpsName [rhs], App "(:)" [App internalCpsName [rhs], SimpleExpr "[]"]]]
                   outerBody = Let inDecls inBody
                   block = mkLet o_case decls outerBody
               in block

internalCpsName :: String
internalCpsName = "internalCps_"

internalCpsVarName :: String
internalCpsVarName = "internalCps_var_"
-}

mkPartitionedFunction :: String -> Bool -> [Decl] -> [String] -> DeclBlocks -> ([Decl], Expr)
mkPartitionedFunction prefix optCase nextVisitDecls lastExprVars cpsTree
  = let inh = Inh_DeclBlocksRoot { prefix_Inh_DeclBlocksRoot = prefix
                                 , optCase_Inh_DeclBlocksRoot = optCase
                                 , nextVisitDecls_Inh_DeclBlocksRoot = nextVisitDecls
                                 , lastExprVars_Inh_DeclBlocksRoot = lastExprVars
                                 }
        sem = sem_DeclBlocksRoot (DeclBlocksRoot cpsTree)
        syn = wrap_DeclBlocksRoot sem inh
    in (lambdas_Syn_DeclBlocksRoot syn, firstCall_Syn_DeclBlocksRoot syn)
}

WRAPPER DeclBlocksRoot

ATTR DeclBlocksRoot DeclBlocks [ prefix : String optCase : Bool nextVisitDecls : {[Decl]} lastExprVars : {[String]} | | ]
ATTR DeclBlocksRoot [ | | lambdas : {[Decl]} firstCall : Expr ]

SEM DeclBlocksRoot
  | DeclBlocksRoot
      lhs.lambdas  = @blocks.decls
      lhs.firstCall = @blocks.callExpr

ATTR DeclBlocks [ blockNr : Int | | ]
SEM DeclBlocksRoot
  | DeclBlocksRoot
      blocks.blockNr = 1
SEM DeclBlocks
  | DeclBlock
      next.blockNr = @lhs.blockNr + 1

ATTR DeclBlocks [ | | callExpr : Expr freeVars : {[String]} ]
SEM DeclBlocks
  | DeclBlock DeclTerminator
      loc.lambdaName = @lhs.prefix ++ "_block" ++ show @lhs.blockNr
      loc.pragmaDecl = PragmaDecl ("NOINLINE " ++ @loc.lambdaName)
      lhs.callExpr = App @loc.lambdaName (map SimpleExpr @loc.freeVars)
  | DeclTerminator
      loc.freeVars = freevars @lhs.lastExprVars (@defs ++ @lhs.nextVisitDecls)
  | DeclBlock
      loc.freeVars = freevars @next.freeVars (@visit : @defs)

ATTR DeclBlocks [ | | decls : {[Decl]} ]
SEM DeclBlocks
  | DeclTerminator
      lhs.decls = [ mkBlockLambda @lhs.optCase @loc.lambdaName @loc.freeVars (@defs ++ @lhs.nextVisitDecls) @result ]
  | DeclBlock
      loc.decl = mkBlockLambda @lhs.optCase @loc.lambdaName @loc.freeVars (@defs ++ [@visit]) @next.callExpr
      lhs.decls = (if @lhs.blockNr > 1 then [@loc.pragmaDecl] else []) ++ [@loc.decl] ++ @next.decls

{
freevars :: [String] -> [Decl] -> [String]
freevars additional decls
  = Set.toList (allused `Set.difference` alldefined)
  where
    allused = Set.unions (Set.fromList additional : map usedvars decls)
    alldefined = Set.unions (map definedvars decls)
  
    usedvars (Decl _ _ _ uses) = uses
    usedvars _                 = Set.empty
    
    definedvars (Decl _ _ defs _) = defs
    definedvars _                 = Set.empty

mkBlockLambda :: Bool -> String -> [String] -> [Decl] -> Expr -> Decl
mkBlockLambda optCase name args decls expr
  = Decl lhs rhs Set.empty Set.empty
  where
    lhs = Fun name (map SimpleExpr args)
    rhs = mkLet optCase decls expr
}


-------------------------------------------------------------------------------
-- The semantic domain is generated from the interface. 
-------------------------------------------------------------------------------

ATTR  CInterface CSegments CSegment [ | | semDom USE {++} {[]} : {[Decl]} ]
SEM  CInterface
  |  CInterface  lhs.semDom = Comment "semantic domain" : @seg.semDom

SEM  CSegment
  |  CSegment lhs.semDom = let name = typeName @lhs.nt @lhs.nr
                               tp = foldr Arr synTps inhTps
                               inhTps = [SimpleType (typeToString @lhs.nt tp) |  tp <- Map.elems @inh]
                               synTps = mkTupleType @lhs.o_unbox (null inhTps) ([SimpleType (typeToString @lhs.nt tp) |  tp <- Map.elems @syn] ++ continuation)
                               continuation = if  @lhs.isLast
                                                  then []
                                                  else [SimpleType (typeName @lhs.nt (@lhs.nr + 1))]
                           in if @lhs.o_newtypes
                              then [ Code.NewType name name tp ]
                              else [ Code.Type name tp ]

-------------------------------------------------------------------------------
-- Wrapper functions
-------------------------------------------------------------------------------

SEM CProduction
  | CProduction loc.semWrapper = let inhAttrs = Map.toList @inh
                                     synAttrs = Map.toList @syn
                                     inhVars = [ SimpleExpr (attrname True _LHS a) | (a,_) <- inhAttrs ]
                                     synVars = [ SimpleExpr (attrname False _LHS a) | (a,_) <- synAttrs ]
                                     var = "sem"
                                     wrapNT = "wrap" ++ "_" ++ getName @nt
                                     inhNT = "Inh" ++ "_" ++ getName @nt
                                     synNT = "Syn" ++ "_" ++ getName @nt
                                     varPat = if  @lhs.o_newtypes
                                                  then App (sdtype @nt) [SimpleExpr var]
                                                  else SimpleExpr var
                                     typeSig = TSig wrapNT (SimpleType (sdtype @nt) `Arr` (SimpleType inhNT `Arr` SimpleType synNT))
                                     mkstrict = if @lhs.o_strictwrap then (\x -> "!(" ++ x ++ ")") else id
                                     mkdata n attrs = Data n [Record n [(getName f++"_"++n,mkstrict $ typeToString @nt t) | (f,t) <- attrs]] False []
                                     datas = [mkdata inhNT inhAttrs, mkdata synNT synAttrs]
                                 in datas ++ [ Decl (Fun wrapNT [varPat, App inhNT inhVars])
                                                    (Let @inter.wrapDecls (App synNT synVars))
                                                    Set.empty Set.empty
                                             ]

ATTR CInterface CSegments CSegment [ | | wrapDecls USE {++} {[]}: {Decls} ]
SEM  CSegment
  |  CSegment lhs.wrapDecls =  let lhsVars = map (lhsname False) (Map.keys @syn)
                                             ++ if @lhs.isLast then [] else [unwrap ++ sem (@lhs.nr+1)]
                                   rhsVars = map (lhsname True) (Map.keys @inh)
                                   rhs = map SimpleExpr rhsVars
                                   unwrap = if @lhs.o_newtypes then typeName @lhs.nt (@lhs.nr + 1) ++ " " else ""
                                   var = "sem"
                                   sem 0 = var
                                   sem n = var ++ "_" ++ show n
                               in [ Decl (mkTupleLhs @lhs.o_unbox (null $ Map.keys @inh) lhsVars) (App (sem @lhs.nr) rhs) (Set.fromList lhsVars) (Set.fromList rhsVars) ]

-------------------------------------------------------------------------------
-- Errors for missing type signatures. It's an error when one of the
-- attributes in the intra-visit dependencies does not have a type.
-------------------------------------------------------------------------------

ATTR CProductions CProduction
     CAlternatives CAlternative
     CVisits CVisit [ | | allTpsFound USE {&&} {True} : Bool ]
ATTR CProductions CProduction
     CAlternatives CAlternative
     CVisits CVisit [ with_sig : Bool | | ]

SEM  CVisit
  |  CVisit lhs.allTpsFound = @intra.allTpsFound
SEM CGrammar
  | CGrammar prods.with_sig = typeSigs @lhs.options && @prods.allTpsFound

ATTR CProductions CProduction
     CAlternatives CAlternative
     CVisits CVisit
     Sequence CRule [ | errors USE {Seq.<>} {Seq.empty} : {Seq Error} | ]
SEM  CGrammar [ | | errors : {Seq Error} ]
  |  CGrammar prods.errors = Seq.empty 
SEM  CVisit
  |  CVisit lhs.errors = @intra.errors
SEM  CRule
  |  CRule lhs.errors = let nameOf (Alias _ _ _ pats@(_:_)) = Ident (show (map (\(Alias _ a _ _)->a) pats)) (getPos @name)
                            nameOf _ = @name
                        in  maybe (Seq.single (MissingTypeSig @lhs.nt @lhs.con (nameOf @pattern.copy))) (const Seq.empty) @tp

-------------------------------------------------------------------------------
-- Provide a description of the interfaces as comments
-------------------------------------------------------------------------------

SEM CProduction
  | CProduction loc.comment = Comment . unlines . map ind $ ( @inter.comments ++ ("alternatives:" : map ind @alts.comments) )

ATTR CInterface CSegments CSegment 
     CAlternatives CAlternative
     CVisits CVisit Sequence CRule  [ | | comments USE {++} {[]}: {[String]} ]

ATTR Sequence CRule [ what:String | | ]

SEM CSegment
  | CSegment     lhs.comments =  let body = map ind (showsSegment (CSegment @inh @syn))
                                 in if null body
                                    then []
                                    else ("visit " ++ show @lhs.nr ++ ":") : body

SEM CAlternative 
  | CAlternative loc.firstOrderChildren = filter (\(_,_,ho) -> not ho) @children
                 lhs.comments =  ("alternative " ++ getName @con ++ ":")
                                 : map ind (  map (\(x,y,_) -> makeLocalComment 14 "child" x (Just y)) @loc.firstOrderChildren
                                           ++ @visits.comments
                                           )

SEM CVisit
  | CVisit       lhs.comments =  let body = map ind (@vss.comments ++ @intra.comments)
                                 in if null body
                                    then []
                                    else ("visit " ++ show @lhs.nr ++ ":") : body
                 vss.what     = "local"
                 intra.what   = "intra"
                                 

SEM CRule
  | CRule        lhs.comments =  [ makeLocalComment 11 @lhs.what name tp | (field,name,tp) <- Map.elems @defines, field == _LOC ]
                                 ++ [ makeLocalComment 11 "inst " name tp | (field,name,tp) <- Map.elems @defines, field == _INST ]

{
makeLocalComment :: Int -> String -> Name -> Maybe Type -> String
makeLocalComment width what  name tp = let  x = getName name
                                            y = maybe "_" (\t -> case t of (NT nt) -> getName nt; Haskell t -> '{':t++"}") tp
                                       in   ( what ++ " " ++ x ++ replicate ((width - length x) `max` 0) ' ' ++ " : " ++ y )

}

-------------------------------------------------------------------------------
-- And tie it all together
-------------------------------------------------------------------------------

ATTR CProductions CProduction    [ | | chunks USE {++} {[]} : {Chunks} ]
ATTR CAlternatives CAlternative  [ | | decls USE {++} {[]} : {Decls} ]
ATTR CGrammar [ | | output : Program ]

SEM CGrammar
  | CGrammar    lhs.output = Program @prods.chunks

SEM CProduction
  | CProduction  lhs.chunks = [ Chunk (getName @nt)
                                      (Comment (getName @nt ++ " " ++ replicate (60 - length (getName @nt)) '-'))
                                      (if @lhs.o_pretty                  then [@loc.comment]   else [])
                                      (if isJust @lhs.o_data             then [@loc.dataDef]   else [])
                                      (if @lhs.o_cata                    then  @loc.cataFun    else [])
                                      (if @lhs.o_sig                     then  @inter.semDom   else [])
                                      (if @nt `Set.member` @lhs.wrappers then  @loc.semWrapper else [])
                                      (if @lhs.o_sem                     then  @alts.decls     else [])
                                      (if @lhs.o_sem                     then  @alts.semNames  else [])
                              ]

{
-- Lets or nested Cases?
mkLet :: Bool -> Decls -> Expr -> Expr
mkLet False decls body = Let decls body
mkLet True decls body = foldr oneCase body decls

oneCase :: Decl -> Expr -> Expr
oneCase (Decl left rhs _ _) exp = Case rhs [CaseAlt left exp]
oneCase _                   exp = exp

-- Gives the name of the visit function
funname field 0  = show field ++ "_"
funname field nr = show field ++ "_" ++ show nr

-- Gives the name of a semantic function
seqSemname :: String -> Nonterminal -> Constructor -> Int -> String
seqSemname pre nt con  0 = semname pre nt con
seqSemname pre nt con nr = semname pre nt con ++ "_" ++ show nr

-- Gives the name of a type
typeName :: Nonterminal -> Int -> String
typeName nt 0 = "T_" ++ show nt
typeName nt n = "T_" ++ show nt ++ "_" ++ show n

-- Gives the name of a visit function
visitname  ::  String -> Nonterminal -> Int -> String
visitname pre nt n =  pre ++ getName nt ++ "_" ++ show n
}

-------------------------------------------------------------------------------
-- Datatypes were already present
-------------------------------------------------------------------------------

ATTR CProductions CProduction [ wrappers:{Set Nonterminal} derivings: {Derivings} typeSyns : {TypeSyns} | | ]
SEM CGrammar
  | CGrammar prods . typeSyns  = @typeSyns
                   . derivings = @derivings 
                   . wrappers  = @wrappers

SEM CProduction
  | CProduction loc.dataDef = let typeSyn tp = let theType = 
                                                    case tp of
                                                      CommonTypes.Maybe t  -> SimpleType ("Maybe (" ++ typeToString @nt t ++")")
                                                      CommonTypes.List t   -> Code.List $ SimpleType (typeToString @nt t)
                                                      CommonTypes.Tuple ts -> Code.TupleType [SimpleType (typeToString @nt t) 
                                                                                             | (_,t) <- ts
                                                                                             ]                                                                
                                               in Code.Type (getName @nt) theType
                                  derivings  = maybe [] (map getName . Set.toList) (Map.lookup @nt @lhs.derivings)
                                  dataDef    = Data (getName @nt) @alts.dataAlts (maybe False id @lhs.o_data) derivings
                              in maybe dataDef typeSyn $ lookup @nt @lhs.typeSyns

ATTR CAlternatives     [ | | dataAlts : {DataAlts} ]
ATTR CAlternative      [ | | dataAlt  : {DataAlt}  ]

SEM CAlternatives
  | Cons        lhs.dataAlts  = @hd.dataAlt : @tl.dataAlts
  | Nil         lhs.dataAlts  = []

SEM CAlternative
  | CAlternative  lhs.dataAlt   = DataAlt (conname @lhs.o_rename @lhs.nt @con) (map (\(_,t,_) -> typeToString @lhs.nt t) @loc.firstOrderChildren)

-------------------------------------------------------------------------------
-- Catamorphism were already present
-------------------------------------------------------------------------------

SEM CProduction
  | CProduction loc.cataFun  = let tSig = TSig (cataname @lhs.prefix @nt)
                                               (SimpleType (getName @nt) `Arr` SimpleType (sdtype @nt))
                                   special typ = case typ of
                                                 CommonTypes.List tp ->                                  
                                                     let cons = SimpleExpr (semname @lhs.prefix @nt (identifier "Cons"))
                                                         nil  = SimpleExpr (semname @lhs.prefix @nt (identifier "Nil" ))
                                                         arg  = SimpleExpr "list"
                                                         rarg = case tp of
                                                                  NT t  -> SimpleExpr ("(Prelude.map " ++ (cataname @lhs.prefix t) ++ " list)")
                                                                  _     -> arg
                                                         lhs = Fun (cataname @lhs.prefix @nt) [arg]
                                                         rhs = (App "Prelude.foldr" [cons,nil,rarg])
                                                     in  [Decl lhs rhs Set.empty Set.empty]
                                                 CommonTypes.Maybe tp ->                                  
                                                     let just    = semname @lhs.prefix @nt (identifier "Just")
                                                         nothing = semname @lhs.prefix @nt (identifier "Nothing" )
                                                         arg  = SimpleExpr "x"
                                                         rarg = case tp of
                                                                  NT t  -> App (cataname @lhs.prefix t) [arg]
                                                                  _     -> arg
                                                         lhs a = Fun (cataname @lhs.prefix @nt) [a]                                                        
                                                     in  [Decl (lhs (App "Prelude.Just" [arg]))     (App just [rarg])    Set.empty Set.empty
                                                         ,Decl (lhs (SimpleExpr "Prelude.Nothing")) (SimpleExpr nothing) Set.empty Set.empty
                                                         ]
                                                 CommonTypes.Tuple tps ->   
                                                     let con  = semname @lhs.prefix @nt (identifier "Tuple")
                                                         tps' = [ (SimpleExpr (getName x),y) | (x,y) <- tps]
                                                         rargs = map rarg tps'                                                        
                                                         rarg (n, tp) = case tp of
                                                                  NT t  -> App (cataname @lhs.prefix t) [n]
                                                                  _     -> n
                                                                  
                                                         lhs = Fun (cataname @lhs.prefix @nt) [TupleExpr (map fst tps')]
                                                         rhs = App con rargs
                                                     in  [Decl lhs rhs Set.empty Set.empty]
                               in  Comment "cata" :
                                   (if @lhs.o_sig then [tSig] else []) ++
                                   maybe @alts.cataAlts special (lookup @nt @lhs.typeSyns)
 
ATTR CAlternatives     [ | | cataAlts : {Decls} ]
ATTR CAlternative      [ | | cataAlt  : {Decl}  ]


SEM CAlternatives
  | Cons lhs.cataAlts = @hd.cataAlt : @tl.cataAlts
  | Nil  lhs.cataAlts = []

SEM CAlternative
  | CAlternative lhs.cataAlt = let lhs = Fun (cataname @lhs.prefix @lhs.nt) [lhs_pat]
                                   lhs_pat = App (conname @lhs.o_rename @lhs.nt @con)
                                                 (map (\(n,_,_) -> SimpleExpr $ locname $ n) @loc.firstOrderChildren)
                                   rhs = App (semname @lhs.prefix @lhs.nt @con)
                                             (map argument @loc.firstOrderChildren)
                                   argument (nm,NT tp,_) = App (cataname @lhs.prefix tp)
                                                               [SimpleExpr (locname nm)]
                                   argument (nm, _,_)    = SimpleExpr (locname nm)
                               in Decl lhs rhs Set.empty Set.empty


-------------------------------------------------------------------------------
-- Collect names of generated stuff
-------------------------------------------------------------------------------

ATTR CAlternatives CAlternative CVisits CVisit [ | | semNames USE {++} {[]} : {[String]} ]

{-
SEM CAlternative
  | CAlternative
      lhs.semNames = [cataname @lhs.prefix @lhs.nt] ++ @visits.semNames
-}

SEM CVisit
  | CVisit
      lhs.semNames = [@loc.funcname]

