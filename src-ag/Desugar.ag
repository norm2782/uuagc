INCLUDE "AbstractSyntax.ag"
INCLUDE "Patterns.ag"
INCLUDE "Expression.ag"
INCLUDE "HsToken.ag"


imports
{
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Map(Map)
import qualified UU.DData.Seq as Seq
import UU.DData.Seq(Seq,(<>))
import UU.Scanner.Position(Pos(..))
import Maybe

import AbstractSyntax
import ErrorMessages
import Options
import HsToken
import HsTokenScanner
import TokenDef
}

WRAPPER HsTokensRoot


ATTR Grammar [ options:{Options} | | ]

ATTR Grammar Nonterminals Nonterminal Productions Production Rule Rules Pattern Patterns Expression HsTokensRoot HsToken HsTokens [ | | errors USE {Seq.<>} {Seq.empty} : {Seq Error} ]

ATTR Grammar Nonterminals Nonterminal Productions Production Child Children Rule Rules Pattern Patterns TypeSig TypeSigs Expression [ | | output : SELF ]


-------------------------------------------------------------------------------
--         Deal with RHS
-------------------------------------------------------------------------------

SEM Expression
  | Expression
      (loc.tks', lhs.errors) = let inh = Inh_HsTokensRoot { childInhs_Inh_HsTokensRoot = @lhs.childInhs
                                                          , childSyns_Inh_HsTokensRoot = @lhs.childSyns
                                                          , nt_Inh_HsTokensRoot        = @lhs.nt
                                                          , con_Inh_HsTokensRoot       = @lhs.con
                                                          }
                                   sem = sem_HsTokensRoot (HsTokensRoot @tks)
                                   syn = wrap_HsTokensRoot sem inh
                               in (tks_Syn_HsTokensRoot syn, errors_Syn_HsTokensRoot syn)
      lhs.output = Expression @pos @tks'


ATTR HsToken HsTokens [ | addLines : Int | ]
SEM HsTokensRoot
  | HsTokensRoot
      tokens.addLines = 0

ATTR HsTokensRoot [ | | tks : {[HsToken]} ]
ATTR HsToken HsTokens [ | | tks : SELF ]

SEM HsToken
  | AGLocal
      loc.tks = AGLocal @var (addl @lhs.addLines @pos)
  | AGField
      loc.mField = findField @field @attr @lhs.childSyns
      
      loc.field' = maybe @field id @loc.mField
      lhs.errors = maybe (Seq.single (UndefAttr @lhs.nt @lhs.con @field (Ident "<ANY>" (getPos @field)))) (const Seq.empty) @loc.mField
      
      lhs.addLines = if length (getName @field) < length (getName @loc.field')
                     then @lhs.addLines + 1
                     else @lhs.addLines
      
      loc.tks = AGField @field @attr (addl @lhs.addLines @pos)
  | HsToken
      loc.tks = HsToken @value (addl @lhs.addLines @pos)
  | CharToken
      loc.tks = CharToken @value (addl @lhs.addLines @pos)
  | StrToken
      loc.tks = StrToken @value (addl @lhs.addLines @pos)
  | Err
      loc.tks = Err @mesg (addl @lhs.addLines @pos)

{
addl :: Int -> Pos -> Pos
addl n (Pos l c f) = Pos (l+n) c f
}


-------------------------------------------------------------------------------
--         Deal with LHS
-------------------------------------------------------------------------------

SEM Pattern
  | Alias
      (loc.field', loc.err1) = maybeError @field (UndefAttr @lhs.nt @lhs.con (Ident "<ANY>" (getPos @field)) @attr) $
                                 findField @field @attr @lhs.childInhs
      loc.err2 = if @loc.field' == @field
                 then Seq.empty
                 else if (@loc.field', @attr) `Set.member` @lhs.defs
                      then Seq.single $ DupRule @lhs.nt @lhs.con @field @attr @loc.field'
                      else Seq.empty
      lhs.errors = @loc.err1 Seq.<> @loc.err2 Seq.<> @pat.errors <> @parts.errors
      lhs.output = Alias @loc.field' @attr @pat.output @parts.output


-------------------------------------------------------------------------------
--         Distribute attributes of children
-------------------------------------------------------------------------------

ATTR Children Child [ | | childInhs, childSyns USE {++} {[]} : {[(Identifier, Identifier)]} ]
ATTR Rules Rule Pattern Patterns Expression HsTokensRoot HsToken HsTokens [ childInhs, childSyns : {[(Identifier, Identifier)]} | | ]

SEM Child
  | Child
      lhs.childInhs = [(i, @name) | i <- Map.keys @inh ]
      lhs.childSyns = [(s, @name) | s <- Map.keys @syn ]

{
maybeError :: a -> Error -> Maybe a -> (a, Seq Error)
maybeError def err mb
  = maybe (def, Seq.single err) (\r -> (r, Seq.empty)) mb

findField :: Identifier -> Identifier -> [(Identifier,Identifier)] -> Maybe Identifier
findField fld attr list
  | fld == _FIRST = f list
  | fld == _LAST  = f (reverse list)
  | otherwise     = Just fld
  where
    f = lookup attr
}


-------------------------------------------------------------------------------
--         Distribute nt and con
-------------------------------------------------------------------------------

ATTR Productions Production Rule Rules Pattern Patterns Expression HsTokensRoot HsToken HsTokens [ nt : NontermIdent | | ]
ATTR Rule Rules Pattern Patterns Expression HsTokensRoot HsToken HsTokens [ con : ConstructorIdent | | ]

SEM Nonterminal
  | Nonterminal
      prods.nt = @nt

SEM Production
  | Production
      rules.con = @con


-------------------------------------------------------------------------------
--         Distribute all defined attributes
-------------------------------------------------------------------------------

ATTR Rule Rules Pattern Patterns [ | | defsCollect USE {`Set.union`} {Set.empty} : {Set (Identifier, Identifier)} ]
SEM Pattern
  | Alias
      loc.def = Set.singleton (@field, @attr)
      lhs.defsCollect = @loc.def `Set.union` @pat.defsCollect `Set.union` @parts.defsCollect

ATTR Rule Rules Pattern Patterns [ defs : {Set (Identifier, Identifier)} | | ]
SEM Production
  | Production
      rules.defs = @rules.defsCollect

