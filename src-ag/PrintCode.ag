INCLUDE "Code.ag"
INCLUDE "Patterns.ag"

imports
{
import Char (isAlphaNum)
import UU.Pretty
import Code
import Patterns
import Options
import CommonTypes (attrname, _LOC, getName, nullIdent)
}

{
type PP_Docs = [PP_Doc]
}

{
ppMultiSeqH :: [PP_Doc] -> PP_Doc -> PP_Doc
ppMultiSeqH = ppMultiSeq' (>#<)

ppMultiSeqV :: [PP_Doc] -> PP_Doc -> PP_Doc
ppMultiSeqV = ppMultiSeq' (>-<)

ppMultiSeq' :: (PP_Doc -> PP_Doc -> PP_Doc) -> [PP_Doc] -> PP_Doc -> PP_Doc
ppMultiSeq' next strictArgs expr
  = foldr (\v r -> (v >#< "`seq`") `next` pp_parens r) expr strictArgs
}

ATTR Program                            [ options:{Options} | | output:{PP_Docs} ]

ATTR Expr Exprs Decl Decls CaseAlts CaseAlt Lhs Pattern Patterns [ options:{Options} | | ]

ATTR Expr Decl DataAlt Type Lhs         [ nested:{Bool} | | pp:{PP_Doc} ]

ATTR Exprs DataAlts Types  Decls        [ nested:{Bool} | | pps: {PP_Docs} ]

ATTR CaseAlt CaseAlts                   [ nested:{Bool} | | pps: {PP_Docs} ]

SEM Program
  | Program decls.nested = nest @lhs.options 

SEM Exprs
  | Cons lhs.pps = @hd.pp : @tl.pps
  | Nil  lhs.pps = []

SEM CaseAlts
  | Cons lhs.pps = @hd.pps ++ @tl.pps
  | Nil  lhs.pps = []

SEM DataAlts
  | Cons lhs.pps = @hd.pp : @tl.pps
  | Nil  lhs.pps = []

SEM Types
  | Cons lhs.pps = @hd.pp : @tl.pps
  | Nil  lhs.pps = []

SEM Decls
  | Cons lhs.pps = @hd.pp : @tl.pps
  | Nil  lhs.pps = []




SEM Program
  | Program    lhs.output  = @decls.pps

SEM Decl
  | Decl       lhs.pp      = @left.pp >#< "="
                             >-< indent 4 @rhs.pp
  | Data       lhs.pp      = "data" >#< @name 
                             >#<  ( case @alts.pps of
                                          [] -> empty
                                          (x:xs) ->              "=" >#<  x
                                                 >-< vlist (map ("|" >#<) xs)
                                     >-< if null @derivings
                                            then empty
                                            else "deriving" >#< ppTuple False (map text @derivings)  
                                  )                                            
  | NewType    lhs.pp      = "newtype" >#< @name >#< "=" >#< @con >#< pp_parens @tp.pp
  | Type       lhs.pp      = "type" >#< @name >#< "=" >#<  @tp.pp
  | TSig       lhs.pp      = @name >#< "::" >#< @tp.pp
  | Comment    lhs.pp      = if '\n' `elem` @txt
                               then "{-" >-< vlist (lines @txt) >-< "-}"
                               else "--" >#< @txt

SEM Expr
  | Let        lhs.pp      = pp_parens (    "let" >#< (vlist @decls.pps)
                                       >-< "in " >#< @body.pp
                                       )
  | Case       lhs.pp      = pp_parens (    "case" >#< pp_parens @expr.pp >#< "of"
                                       >-< (vlist @alts.pps)
                                       )
  | Lambda     loc.strictParams = if strictSems @lhs.options
                                  then map text @args
                                  else []
               lhs.pp      = pp_parens (    "\\" >#< (vlist @args) >#< "->" 
                                       >-< indent 4 (@loc.strictParams `ppMultiSeqV` @body.pp)
                                       )
  | TupleExpr  lhs.pp      = ppTuple @lhs.nested @exprs.pps
  | UnboxedTupleExpr  lhs.pp      = ppUnboxedTuple @lhs.nested @exprs.pps
  | App        lhs.pp      = pp_parens $ @name >#< hv_sp @args.pps
  | SimpleExpr lhs.pp      = text @txt
  | TextExpr   lhs.pp      = vlist (map text @lns)

SEM CaseAlt
  | CaseAlt    lhs.pps     = ["{" >#< @left.pp >#< "->", @expr.pp >#< "}"]

SEM DataAlt
  | DataAlt    lhs.pp      = @name >#< hv_sp (map ((@lhs.strictPre >|<) . pp_parens . text) @args)
  | Record     lhs.pp      = @name >#< pp_block "{" "}" "," 
                                                [ f >#< "::" >#< t | (f,t) <- @args ]
SEM Lhs
  | Pattern3 TupleLhs UnboxedTupleLhs
      loc.addStrictGuard = if strictCases @lhs.options then \v -> v >#< "|" >#< @loc.strictGuard else id
  | Pattern3
      loc.strictGuard = @pat3.strictVars `ppMultiSeqH` (pp "True")
  | TupleLhs UnboxedTupleLhs
      loc.strictGuard = if stricterCases @lhs.options
                        then map text @comps `ppMultiSeqH` (pp "True")
                        else pp "True"

  | Fun
      loc.addStrictGuard = if strictSems @lhs.options then \v -> v >#< "|" >#< @loc.strictGuard else id
      loc.strictGuard    = @args.pps `ppMultiSeqH` (pp "True")

  | Pattern3   lhs.pp      = @loc.addStrictGuard @pat3.pp
  | Pattern3SM lhs.pp      = @pat3.pp'
  | TupleLhs   lhs.pp      = @loc.addStrictGuard $ ppTuple @lhs.nested (map text @comps)
  | UnboxedTupleLhs   lhs.pp      = @loc.addStrictGuard $ ppUnboxedTuple @lhs.nested (map text @comps)
  | Fun        lhs.pp      = @loc.addStrictGuard (@name >#< hv_sp @args.pps)

SEM Type  [ | | prec:Int ]
  | Arr        lhs.prec    = 2
                  .pp      = @loc.l >#< "->" >-< @loc.r
               loc.l       = if @left.prec  <= 2 then pp_parens @left.pp  else @left.pp
                  .r       = if @right.prec <  2 then pp_parens @right.pp else @right.pp

  | TupleType  lhs.prec    = 5
                  .pp      = ppTuple @lhs.nested @tps.pps

  | UnboxedTupleType  lhs.prec    = 5
                         .pp      = ppUnboxedTuple @lhs.nested @tps.pps

  | List       lhs.prec    = 5
                  .pp      = "[" >|< @tp.pp >|< "]"

  | SimpleType lhs.prec    = 5
                  .pp      = if reallySimple @txt then text @txt else pp_parens (text @txt)

{

reallySimple :: String -> Bool
reallySimple = and . map (\x -> isAlphaNum x || x=='_')

ppTuple True  pps = "(" >|< pp_block " " (replicate (length pps `max` 1) ')') ",(" pps
ppTuple False pps = "(" >|< pp_block " " ")" "," pps
ppUnboxedTuple True pps  = "(# " >|< pp_block " " (concat $ replicate (length pps `max` 1) " #)") ",(# " pps
ppUnboxedTuple False pps = "(# " >|< pp_block " " " #)" "," pps

}


-------------------------------------------------------------------------------
--         Strict data fields
-------------------------------------------------------------------------------

ATTR DataAlt DataAlts [ strictPre: PP_Doc | | ]

SEM Decl
  | Data alts.strictPre = if @strict then pp "!" else empty

-------------------------------------------------------------------------------
--         Strict variables
-------------------------------------------------------------------------------

ATTR Pattern Patterns [ | | strictVars USE {++} {[]} : {[PP_Doc]} ]
SEM Pattern
  | Alias
      loc.strictVar
        = if strictCases @lhs.options
          then [@loc.ppVar]
          else []
      loc.strictPatVars
        = if stricterCases @lhs.options
          then @pat.strictVars
          else []
      lhs.strictVars
        = @loc.strictVar ++ @loc.strictPatVars
      

-------------------------------------------------------------------------------
--         Pretty printing patterns
-------------------------------------------------------------------------------

SEM Patterns [ | | pps : {[PP_Doc]} ]
  | Cons lhs.pps = @hd.pp : @tl.pps
  | Nil  lhs.pps = []

SEM Pattern [ | | pp:PP_Doc ]
  | Constr  lhs.pp     = pp_parens $ @name >#< hv_sp @pats.pps
  | Product lhs.pp     = pp_block "(" ")" "," @pats.pps
  | Alias   loc.ppVar  = pp (attrname False @field @attr)
            lhs.pp     = if @pat.isUnderscore
                          then @loc.ppVar
                          else @loc.ppVar >|< "@" >|< @pat.pp
  | Underscore lhs.pp  = text "_"

SEM Pattern [ | | isUnderscore:{Bool}]
 | Constr     lhs.isUnderscore = False
 | Product    lhs.isUnderscore = False
 | Alias      lhs.isUnderscore = False
 | Underscore lhs.isUnderscore = True

-------------------------------------------------------------------------------
--         Pretty printing patterns for SM
-------------------------------------------------------------------------------

SEM Patterns [ | | pps' : {[PP_Doc]} ]
  | Cons lhs.pps' = @hd.pp' : @tl.pps'
  | Nil  lhs.pps' = []

SEM Pattern [ | | pp':PP_Doc ]
  | Constr  lhs.pp'     = pp_parens $ @name >#< hv_sp (map pp_parens @pats.pps')
  | Product lhs.pp'     = pp_block "(" ")" "," @pats.pps'
  | Alias   lhs.pp'     = let attribute | @field == _LOC || @field == nullIdent = locname' @attr
                                        | otherwise                             = attrname False @field @attr
                          in attribute >|< "@" >|< @pat.pp'
  | Underscore lhs.pp'  = text "_"

{
locname' n = "_loc_" ++ getName n
}
