INCLUDE "AbstractSyntax.ag"
INCLUDE "Patterns.ag"

imports
{
import qualified List (delete,intersperse)

import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Map(Map)
import qualified UU.DData.Seq as Seq
import UU.DData.Seq(Seq,(<>))
import UU.Scanner.Position(noPos)
import Pretty
import Maybe

import AbstractSyntax
import ErrorMessages

import Options(Options,modcopy,rename)
}

-------------------------------------------------------------------------------
--         Passing down corresponding nonterminal and constructor names
-------------------------------------------------------------------------------
ATTR Rule Rules Child Children Alternative Alternatives  Pattern Patterns [ nt:Nonterminal | | ]
ATTR Rule Rules Child Children Pattern Patterns [ con:Constructor | | ]


-------------------------------------------------------------------------------
--         Distributing options
-------------------------------------------------------------------------------

ATTR Grammar          [ options:{Options} | | ]
ATTR Productions Production Alternatives Alternative [ o_rename:{Bool} 
                                                       cr:Bool {- copy rule -}  
                                                     | | ]

ATTR Children Child [ cr:Bool {- copy rule -}  | | ]
SEM Grammar
  | Grammar     prods.o_rename  = rename    @lhs.options
                prods.cr        = modcopy   @lhs.options
                    
-------------------------------------------------------------------------------
-- Type synonyms environment
-------------------------------------------------------------------------------
ATTR Productions Production Alternatives Alternative [ typeSyns : {TypeSyns} | | ]


-------------------------------------------------------------------------------
-- some auxiliary functions
-------------------------------------------------------------------------------
{
fieldName n       = '@' : getName n
	
locName n         = '@' : getName n

attrName fld attr
 | fld == _LOC    = '@' :                       getName attr 
 | otherwise      = '@' : getName fld ++ "." ++ getName attr

_ACHILD = Ident "(" noPos -- hack
	
	
getConName typeSyns rename nt con1 
 | nt `elem` map fst typeSyns  =  synonym
 | otherwise                   =  normalName
 where con                            = getName con1
       normalName | rename            = getName nt++"_"++ con
                  | otherwise         =  con
       synonym    | con == "Cons"     = "(:)"
                  | con == "Nil"      = "[]"
                  | con == "Just"     = "Just"
                  | con == "Nothing"  = "Nothing"
                  | otherwise         = normalName



concatSeq = foldr Seq.append Seq.empty

splitAttrs :: Map Name a -> [Name] -> ([(Name,a)],[Name])	  -- a used as (String,String)
splitAttrs _      []           
  =  ([],[])
splitAttrs useMap (n:rest) 
  =  let (uses,normals) = splitAttrs useMap rest
     in case Map.lookup n useMap of
          Just x  -> ((n,x):uses ,   normals )       
          Nothing -> (      uses , n:normals )

removeDefined ::  Set (Name,Name) -> (Name,Attributes) -> (Name,[Name])
removeDefined defined (fld,as) 
  = ( fld
    , [ a 
      | a <- Map.keys as
      , not (Set.member (fld,a) defined) 
      ]
    )

}

-------------------------------------------------------------------------------
--         Errors
-------------------------------------------------------------------------------

ATTR Grammar Productions Production Alternatives Alternative
     Child Children Rule Rules Pattern Patterns 
     [ | | errors USE {Seq.<>} {Seq.empty}:{Seq Error} ]

-------------------------------------------------------------------------------
-- Set of all defined nonterminals
-------------------------------------------------------------------------------

ATTR Productions Production  [ || collect_nts USE {`Set.union`} {Set.empty} : {Set Nonterminal}  ]
SEM Production 
  | Production lhs.collect_nts = Set.singleton @nt

ATTR Productions Production Alternatives Alternative [ nonterminals  : {Set Nonterminal} || ]
SEM Grammar
  | Grammar prods.nonterminals = @prods.collect_nts
-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------

-- Pass down the lhs-attributes and the USE's to each alternative of a production
--
ATTR Productions Production [ useMap : {UseMap} || ]
ATTR Alternatives Alternative [ inh, syn:{Attributes} useMap : {Map Name (String,String,String)}|| ]

SEM Production
  | Production  alts.inh  = @inh
                alts.syn  = @syn
                alts.useMap = Map.findWithDefault Map.empty @nt @lhs.useMap

SEM Alternative
  | Alternative rules.con    = @con
                children.con = @con
SEM Child
  | Child lhs . name = @name
SEM Grammar
  | Grammar prods . useMap = @useMap
SEM Grammar
  | Grammar prods . typeSyns = @typeSyns
SEM Production
  | Production alts . nt = @nt

SEM Child [ | | name:{Name} inherited,synthesized:{Attributes} ]
  | Child lhs.inherited = @inh
          lhs.synthesized = @syn
          
SEM Children [ | | inputs,outputs:{[(Name, Attributes)]} ]
  | Cons lhs.inputs  = (@hd.name, @hd.inherited) : @tl.inputs
            .outputs = (@hd.name, @hd.synthesized) : @tl.outputs
  | Nil  lhs.inputs  = []
            .outputs = []
 
 
 
-------------------------------------------------------------------------------
-- Implementation of Use-rule and Copy-rule
-------------------------------------------------------------------------------
 
{
	
	
	
deprecatedCopyRuleError nt con fld a
 = let mesg = 
                "In the definitions for alternative" 
            >#< getName con 
            >#< "of nonterminal" 
            >#< getName nt 
            >|< "," 
            >-< "the value of field" 
            >#< getName a  
            >#< "is copied by a copy-rule."                                    
            >-< "Copying the value of a field using a copy-rule is deprecated"
            >-< "Please add the following lines to your code:"
            >-< (    "SEM" 
                >#< getName nt
                >-< indent 2 (      "|" 
                             >#< getName con 
                             >#< getName fld 
                             >#< "." 
                             >#< a 
                             >#< "=" 
                             >#< "@" 
                             >|< a
                             )
                )  
    in  CustomError True (getPos a) mesg
	
	
missingRuleErrorExpr nt con fld a
 = "error \"missing rule: " 
   ++ show nt  ++ "." ++ show con ++ "." 
   ++ show fld ++ "." ++ show a   ++ "\""
	
	
	
makeRule :: (Name,Name) -> Expression -> String -> Rule
makeRule (f1,a1) expr origin 
 = Rule (Alias f1 a1 (Underscore noPos) []) 
        expr 
        False 
        origin


useRule :: Set Name -> [(Name,Attributes)] -> (Name,(String,String,String)) -> Rule
useRule locals ch_outs (n,(op,e,pos)) 
 =  let elems = [ fld 
                | (fld,as) <- ch_outs
                , Map.member n as
                ]
                
        expr | Set.member n locals  =  attrName _LOC n
             | null elems           =  e
             | otherwise            =  foldr1 (\x y -> x ++ " " ++ op ++ " " ++ y) 
                                              (map (flip attrName n) elems)
             
    in makeRule (_LHS,n) 
                (Expression noPos expr) 
                ("use rule " ++ pos)




selfRule lhsNecLoc attr x   
 = let expr | lhsNecLoc  = locName attr
            | otherwise  = x
     
   in makeRule (if lhsNecLoc then _LHS else _LOC,attr)
               (Expression noPos expr)
               "self rule"
               



concatRE rsess = let (rss,ess) = unzip rsess
                 in (concat rss, concatSeq ess)


copyRule :: Name -> Name -> Bool -> Set Name -> (Map Name Name, (Name,[Name])) -> ([Rule], Seq Error)
copyRule nt con modcopy locals (env,(fld,as)) 
 = concatRE (map copyRu as)
 
 where 
       copyRu a
           = ( [ makeRule (fld,a) 
                          (Expression noPos expr)
                          (cruletxt sel)
               ]
             , err
             )
                
        where 
              sel 
               |    not modcopy 
                 && Set.member a locals  =  Just _LOC
               | otherwise               =  Map.lookup a env

              (expr,err) 
               = case sel of
                  Nothing         -> ( missingRuleErrorExpr nt con fld a
                                     , Seq.single (MissingRule nt con fld a)
                                     )
                  Just f 
                   | f == _ACHILD -> ( fieldName a
                                     , Seq.single (deprecatedCopyRuleError nt con fld a)
                                     )
                   | otherwise    -> ( attrName f a
                                     , Seq.empty
                                     )
                                            
              cruletxt sel 
               | local                            = "copy rule (from local)"
               | deprChild                        = "deprecated child copy"
               | Set.member a locals && nonlocal  = "modified copy rule"
               | incoming && outgoing             = "copy rule (chain)"
               | incoming                         = "copy rule (down)"
               | outgoing                         = "copy rule (up)"
               | otherwise                        = "copy rule (chain)"
                where outgoing  =  fld == _LHS
                      incoming  =  maybe False (== _LHS)    sel
                      nonlocal  =  maybe False (/= _LOC)    sel
                      local     =  maybe False (== _LOC)    sel
                      deprChild =  maybe False (== _ACHILD) sel
}       




SEM Alternative
 | Alternative 

   lhs.errors = @children.errors <> @errs <> @rules.errors <> @loc.orderErrs

   loc.(newRls, errs) 
   =
    let locals       = @rules.locals  
        initenv      = Map.fromList (  [ (a,_ACHILD) 
                                       | (a,_,_) <- @children.fields
                                       ] 
                                    ++ attrs(_LHS, @lhs.inh) 
                                    ++ [ (a,_LOC) 
                                       |  a <- Set.toList locals
                                       ]
                                    ) 
                                    
        attrs (n,as) = [ (a,n) | a <- Map.keys as ]  
        
        envs       = scanl (flip Map.union) 
                           initenv 
                           (map (Map.fromList . attrs ) @children.outputs)
                           
        child_envs = init envs
        lhs_env    = last envs
        
        (selfAttrs, normalAttrs) 
          = Map.partition (==NT _SELF) @lhs.syn
                 
        (_,undefAttrs)    
          = removeDefined @rules.definedAttrs (_LHS, normalAttrs)
                 
        (useAttrs,others) 
          = splitAttrs @lhs.useMap undefAttrs
   

        (rules1, errors1)
          = concatRE $ map (copyRule @lhs.nt @con @lhs.cr locals)
                           (zip envs (map (removeDefined @rules.definedAttrs) @children.inputs))  

        uRules            
          = map (useRule locals @children.outputs) useAttrs
   
        selfLocRules  
          =  [ selfRule False attr (constructor [childSelf attr nm tp | (nm,tp,ho) <- @children.fields, not ho])
             | attr <- Map.keys selfAttrs
             , not (Set.member attr locals)
             ]
             where   
               childSelf self nm tp 
                 = case tp of NT nt                           -> attrName nm self
                              _      | nm `Set.member` locals -> locname nm
                                     | otherwise              -> fieldName nm
               constructor fs
                | getName @con == "Tuple" && @lhs.nt `elem` map fst @lhs.typeSyns 
                  = "(" ++ concat (List.intersperse "," fs) ++ ")"
                | otherwise 
                  = getConName @lhs.typeSyns @lhs.o_rename @lhs.nt @con ++ " " ++ unwords fs                                 

        selfRules
          = [ selfRule True attr undefined
            | attr <- Map.keys selfAttrs
            , not (Set.member (_LHS,attr) @rules.definedAttrs) 
            ]
                               
        (rules5, errs5) 
          = copyRule @lhs.nt 
                     @con 
                     @lhs.cr 
                     locals 
                     (lhs_env, (_LHS, others))
                                     
    in (uRules++selfLocRules++selfRules++rules5++rules1, errors1<>errs5)   
    
    
   
   
ATTR Rule Rules Pattern Patterns
  [ | | locals        USE {`Set.union`} {Set.empty} : {Set Name} 
        definedAttrs  USE {`Set.union`} {Set.empty} : {Set (Name,Name)}
  ]


SEM Pattern
  | Alias lhs.definedAttrs = Set.insert (@field,@attr) @pat.definedAttrs
             .locals       = if @field == _LOC
                                then Set.insert @attr @pat.locals
                                else @pat.locals

SEM Children [ | | fields : {[(Name,Type,Bool)]} ]
  | Cons lhs.fields = @hd.field : @tl.fields
  | Nil  lhs.fields = []
  
SEM Child    [ | | field  : { (Name,Type,Bool) } ]
  | Child lhs.field = (@name,@tp,@higherOrder)

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
ATTR Rule Pattern Patterns [ || containsVars USE {||} {False} : Bool ]

SEM Pattern
  | Alias      lhs.containsVars = True

-------------------------------------------------------------------------------
--         Reconstructing the tree
-------------------------------------------------------------------------------

ATTR Productions Production Alternatives Alternative Rules Rule [ | uniq:Int | ]

SEM Grammar
  | Grammar prods.uniq = 1

ATTR Grammar Productions  Production   Alternatives
    Alternative Children Child Rules Rule Pattern  Patterns TypeSigs TypeSig
    [ | | output:SELF ] 

ATTR Rule [ | | outputs:Rules ]


SEM Alternative
  | Alternative lhs.output = Alternative @con @children.output (@rules.output ++ @newRls) @typeSigs.output

SEM Rules 
  | Cons lhs.output = if @hd.containsVars then @hd.outputs ++ @tl.output else @tl.output
    -- remove rules that define nothing

SEM Rule
  | Rule  (lhs.outputs, lhs.uniq) = multiRule @loc.output @lhs.uniq


{
{- 
multiRule replaces
  loc.(a,b) = e
by  
  loc.tup1  = e
  loc.(a,_) = @loc.tup1
  loc.(_,b) = @loc.tup1
It needs to thread a unique number for inventing names for the tuples.

It also works for nested tuples:
  loc.(a,(b,c)) = e
becomes
  loc.tup1      = e
  loc.(a,_)     = @loc.tup1
  loc.(_,tup2)  = @loc.tup1
  loc.(b,_)     = @loc.tup2
  loc.(_,c)     = @loc.tup2
-}

multiRule :: Rule -> Int -> ([Rule], Int)	
multiRule (Rule pat expr owrt origin) uniq
  =  let f :: (Pattern->Pattern) -> Expression -> Pattern -> Int -> (Pattern, ([Rule], Int))
         f w e (Product pos pats) n 
           = let freshName = Ident ("_tup" ++ show n) pos 
                 freshExpr = Expression pos (attrName _LOC freshName)
                 freshPat  = Alias _LOC freshName (Underscore pos) pats
                 a = length pats - 1
                 us b p = Product pos (replicate (a-b) (Underscore pos) ++ [p] ++ replicate b (Underscore pos))
                 g :: Pattern -> ([Pattern],[Rule],Int) -> ([Pattern],[Rule],Int)
                 g p (xs1,rs1,n1)   = let (x2,(rs2,n2)) = f (us (length xs1)) freshExpr p n1
                                      in  (x2:xs1, rs2++rs1, n2)
                 (xs9,rs9,n9) = foldr g ([], [], n+1) pats
             in  ( freshPat
                 , ( Rule (w freshPat) e owrt origin : rs9
                   , n9
                   )
                 )
         f w e p n 
           = ( p
             , ( [Rule (w p) e owrt origin]
               , n
               )
             )
     in snd (f id expr pat uniq)

}

-------------------------------------------------------------------------------
--         Check the order definitions
-------------------------------------------------------------------------------

ATTR Productions Production Alternatives Alternative [ manualAttrOrderMap : {AttrOrderMap} | | ]

SEM Grammar
  | Grammar
      prods.manualAttrOrderMap = @manualAttrOrderMap
      

SEM Alternative
  | Alternative
      loc.orderDeps = Set.toList $ Map.findWithDefault Set.empty @con $ Map.findWithDefault Map.empty @lhs.nt @lhs.manualAttrOrderMap
      
      loc.allAttrsInScope
        = Map.fromList ( [ (_LHS, @lhs.syn `Map.union` @lhs.inh)
                         , (_LOC, Map.fromList [ (l,Haskell "LOC") | l <- Set.toList @rules.locals]) ]
                       ++ @children.inputs
                       ++ @children.outputs
                       )
      
      loc.invalidOrderDepsErrors
        = [ ErroneousOrder @lhs.nt @con dep
          | dep@(Dependency (fld,nm) _) <- @loc.orderDeps
          , not $ isInAttribute @children.outputs fld nm
          ]

      loc.undefinedAttributeInDepsErrors
        = [ UndefAttr @lhs.nt @con fld nm
          | (fld,nm) <- concatMap (\(Dependency a b) -> [a,b]) $ @loc.orderDeps
          , not $ isDefined @loc.allAttrsInScope fld nm
          ]

      loc.orderErrs
        = if null @loc.undefinedAttributeInDepsErrors
          then Seq.fromList @loc.invalidOrderDepsErrors
          else Seq.fromList @loc.undefinedAttributeInDepsErrors

{
isDefined :: Map Name Attributes -> Identifier -> Identifier -> Bool
isDefined mp fld nm
  = Map.member nm $ Map.findWithDefault Map.empty fld mp

-- check that for a dependency a < b, that a is an In attribute
isInAttribute :: [(Name,Attributes)] -> Identifier -> Identifier -> Bool
isInAttribute allSyns fld nm
  | fld == _INST || fld == _LOC || fld == _LHS
      = True
  | otherwise  -- is nm it a synthesized attribute of fld?
      = maybe False (Map.member nm) (lookup fld allSyns)
}
