INCLUDE "HsToken.ag"

imports
{
import Char(isPrint,ord)
import UU.DData.Seq as Seq(Seq,empty,single,(<>),toList)
import UU.Scanner.Position(Pos(Pos),line,column)
import UU.Pretty

import HsToken
import ErrorMessages
}

ATTR HsTokensRoot
     [ 
     | | 
       errors    USE {Seq.<>} {Seq.empty}:{Seq Error}
       usedLocals:{[Identifier]}
       usedAttrs :{[(Identifier,Identifier)]}
       textLines  :{[String]}
       usedFields:{[Identifier]}
     ]

-------------------------------------------------------------------------------
--  Context information
-------------------------------------------------------------------------------
ATTR HsTokensRoot
     HsTokens HsToken [ nt,con   :{Identifier}
                        -- fieldnames   :{[Identifier]}
                        allfields    :{[(Name,Type)]}
                        allnts       :{[Name]}
                        attrs    :{[(Identifier,Identifier)]}
                      ||
                      ]

ATTR HsTokens HsToken [ fieldnames : {[Identifier]} | | ]
SEM HsTokensRoot
  | HsTokensRoot tokens.fieldnames = map fst @lhs.allfields

-------------------------------------------------------------------------------
--  Errors
-------------------------------------------------------------------------------
ATTR HsTokens HsToken [ | |  errors USE {Seq.<>} {Seq.empty}:{Seq Error}  ]

-------------------------------------------------------------------------------
-- Syntax errors
-------------------------------------------------------------------------------

SEM HsToken
  | Err lhs.errors = let m = text @mesg
                     in Seq.single (CustomError False @pos m)
                     
-------------------------------------------------------------------------------
--  Undefined variables
-------------------------------------------------------------------------------

{
isNTname allnts (Just (NT nt)) = nt `elem` allnts
isNTname allnts _              = False
}


SEM HsToken
  | AGLocal   loc.(errors,tok,usedLocals) = 
                     if @var `elem` @lhs.fieldnames   
                     then if  isNTname @lhs.allnts (lookup @var @lhs.allfields)
                          then (Seq.single(ChildAsLocal @lhs.nt @lhs.con @var), (@pos,fieldname @var), []    )
                          else (Seq.empty, (@pos,fieldname @var), []    )
                     else if (_LOC,@var) `elem` @lhs.attrs 
                     then (Seq.empty                                   , (@pos,locname   @var), [@var])
                     else (Seq.single(UndefLocal @lhs.nt @lhs.con @var), (@pos,locname   @var), []    )

SEM HsToken
  | AGField   lhs.errors = if (@field,@attr) `elem` @lhs.attrs
                                 then Seq.empty
                                 else if not(@field `elem` (_LHS : _LOC: @lhs.fieldnames))
                                         then Seq.single (UndefChild @lhs.nt @lhs.con @field)
                                         else Seq.single (UndefAttr @lhs.nt @lhs.con @field @attr)
                                         
-------------------------------------------------------------------------------
--         Used variables
-------------------------------------------------------------------------------

ATTR HsTokens HsToken [ | | usedLocals USE {++} {[]} : {[Identifier]}
                            usedAttrs  USE {++} {[]} : {[(Identifier,Identifier)]} ]

SEM HsToken
  | AGField lhs.usedAttrs  = [(@field,@attr)]

-------------------------------------------------------------------------------
--         Used fields
-------------------------------------------------------------------------------
ATTR HsTokens HsToken [ | | usedFields USE {Seq.<>} {Seq.empty} : {Seq Identifier} ]

SEM HsToken
  | AGLocal lhs.usedFields = if @var `elem` @lhs.fieldnames
                              then Seq.single @var
                              else Seq.empty
SEM HsTokensRoot
  | HsTokensRoot lhs.usedFields = Seq.toList @tokens.usedFields

-------------------------------------------------------------------------------
--  Pretty printing
-------------------------------------------------------------------------------

SEM HsTokensRoot
  | HsTokensRoot lhs.textLines = showTokens @tokens.tks

SEM HsTokens [ || tks : {[(Pos,String)]} ]
  | Cons lhs.tks = @hd.tok : @tl.tks
  | Nil  lhs.tks = []

SEM HsToken [ || tok:{(Pos,String)}]
   | AGField lhs.tok = (@pos, attrname True @field @attr)

   | HsToken lhs.tok = (@pos, @value)

   | CharToken lhs.tok = (@pos, if null @value
                                   then ""
                                   else showCharShort (head @value)
                         )

   | StrToken  lhs.tok = (@pos, showStrShort @value)
   | Err       lhs.tok = (@pos, "")


{
showTokens :: [(Pos,String)] -> [String]
showTokens [] = []
showTokens xs = map showLine . shiftLeft . getLines $ xs

getLines []         = []
getLines ((p,t):xs) =       let (txs,rest)     = span sameLine xs
                                sameLine (q,_) = line p == line q
                            in ((p,t):txs) : getLines rest

shiftLeft lns =        let sh = let m = minimum . checkEmpty . filter (>=1) . map (column.fst.head) $ lns
                                    checkEmpty [] = [1]
                                    checkEmpty x  = x
                                in if m >= 1 then m-1 else 0
                           shift (p,t) = (if column p >= 1 then case p of (Pos l c f) -> Pos l (c - sh) f else p, t)
                       in map (map shift) lns

showLine ts =        let f (p,t) r = let ct = column p
                                     in \c -> spaces (ct-c) ++ t ++ r (length t+ct)
                         spaces x | x < 0 = ""
                                  | otherwise = replicate x ' '
                     in foldr f (const "") ts 1


showStrShort xs = "\"" ++ concatMap f xs ++ "\""
  where f '"' = "\\\""
        f x   = showCharShort' x

showCharShort '\'' = "'" ++ "\\'" ++ "'"
showCharShort c    = "'" ++ showCharShort' c ++ "'"

showCharShort' '\a'  = "\\a"
showCharShort' '\b'  = "\\b"
showCharShort' '\t'  = "\\t"
showCharShort' '\n'  = "\\n"
showCharShort' '\r'  = "\\r"
showCharShort' '\f'  = "\\f"
showCharShort' '\v'  = "\\v"
showCharShort' '\\'  = "\\\\"
showCharShort' x | isPrint x = [x]
                 | otherwise = '\\' : show (ord x)
}
