INCLUDE "HsToken.ag"

imports
{
import UU.DData.Seq as Seq(Seq,empty,single,(<>),toList)
import Pretty

import TokenDef
import HsToken
import ErrorMessages
}

ATTR HsTokensRoot
     [ 
     | | 
       errors    USE {Seq.<>} {Seq.empty}:{Seq Error}
       usedLocals:{[Identifier]}
       usedAttrs :{[(Identifier,Identifier)]}
       textLines  :{[String]}
       usedFields:{[Identifier]}
     ]

-------------------------------------------------------------------------------
--  Context information
-------------------------------------------------------------------------------
ATTR HsTokensRoot
     HsTokens HsToken [ nt,con    : {Identifier}
                        allfields : {[(Identifier,Type,Bool)]}
                        allnts    : {[Identifier]}
                        attrs     : {[(Identifier,Identifier)]}
                      ||
                      ]

ATTR HsTokens HsToken [ fieldnames : {[Identifier]} | | ]
SEM HsTokensRoot
  | HsTokensRoot tokens.fieldnames = map (\(n,_,_) -> n) @lhs.allfields

-------------------------------------------------------------------------------
--  Errors
-------------------------------------------------------------------------------
ATTR HsTokens HsToken [ | |  errors USE {Seq.<>} {Seq.empty}:{Seq Error}  ]

-------------------------------------------------------------------------------
-- Syntax errors
-------------------------------------------------------------------------------

SEM HsToken
  | Err lhs.errors = let m = text @mesg
                     in Seq.single (CustomError False @pos m)
                     
-------------------------------------------------------------------------------
--  Undefined variables
-------------------------------------------------------------------------------

{
isNTname allnts (Just (NT nt _)) = nt `elem` allnts
isNTname allnts _                = False
}


SEM HsToken
  | AGLocal   loc.(errors,tok,usedLocals) = 
                     if @var `elem` @lhs.fieldnames   
                     then if  isNTname @lhs.allnts (lookup @var (map (\(n,t,_) -> (n,t)) @lhs.allfields))
                          then (Seq.single(ChildAsLocal @lhs.nt @lhs.con @var), (@pos,fieldname @var), []    )
                          else (Seq.empty, (@pos,fieldname @var), []    )
                     else if (_LOC,@var) `elem` @lhs.attrs 
                     then (Seq.empty                                   , (@pos,locname   @var), [@var])
                     else (Seq.single(UndefLocal @lhs.nt @lhs.con @var), (@pos,locname   @var), []    )

SEM HsToken
  | AGField   lhs.errors = if (@field,@attr) `elem` @lhs.attrs
                                 then Seq.empty
                                 else if not(@field `elem` (_LHS : _LOC: @lhs.fieldnames))
                                         then Seq.single (UndefChild @lhs.nt @lhs.con @field)
                                         else Seq.single (UndefAttr @lhs.nt @lhs.con @field @attr False)
                                         
-------------------------------------------------------------------------------
--         Used variables
-------------------------------------------------------------------------------

ATTR HsTokens HsToken [ | | usedLocals USE {++} {[]} : {[Identifier]}
                            usedAttrs  USE {++} {[]} : {[(Identifier,Identifier)]} ]

SEM HsToken
  | AGField lhs.usedAttrs  = [(@field,@attr)]

-------------------------------------------------------------------------------
--         Used fields
-------------------------------------------------------------------------------
ATTR HsTokens HsToken [ | | usedFields USE {Seq.<>} {Seq.empty} : {Seq Identifier} ]

SEM HsToken
  | AGLocal lhs.usedFields = if @var `elem` @lhs.fieldnames
                              then Seq.single @var
                              else Seq.empty
SEM HsTokensRoot
  | HsTokensRoot lhs.usedFields = Seq.toList @tokens.usedFields

-------------------------------------------------------------------------------
--  Pretty printing
-------------------------------------------------------------------------------

SEM HsTokensRoot
  | HsTokensRoot lhs.textLines = showTokens @tokens.tks

SEM HsTokens [ || tks : {[(Pos,String)]} ]
  | Cons lhs.tks = @hd.tok : @tl.tks
  | Nil  lhs.tks = []

SEM HsToken [ || tok:{(Pos,String)}]
   | AGField
       loc.addTrace = case @rdesc of
                        Just d  -> \x -> "(trace " ++ show (d ++ " -> " ++ show @field ++ "." ++ show @attr) ++ " (" ++ x ++ "))"
                        Nothing -> id
       lhs.tok = (@pos, @loc.addTrace $ attrname True @field @attr)

   | HsToken lhs.tok = (@pos, @value)

   | CharToken lhs.tok = (@pos, if null @value
                                   then ""
                                   else showCharShort (head @value)
                         )

   | StrToken  lhs.tok = (@pos, showStrShort @value)
   | Err       lhs.tok = (@pos, "")

