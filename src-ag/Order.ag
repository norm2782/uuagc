--REMOVED SM INCLUDE "GenerateCodeSM.ag"
INCLUDE "Patterns.ag"
INCLUDE "Expression.ag"
INCLUDE "AbstractSyntax.ag"
imports
{
-- From uuagc
import CommonTypes
import Patterns
import ErrorMessages
import AbstractSyntax
import Code hiding (Type)
import qualified Code
import Expression
import Options
import SequentialComputation
import SequentialTypes
import CodeSyntax
import GrammarInfo
import HsToken(HsTokensRoot(HsTokensRoot))
import HsTokenScanner(lexTokens)
import SemHsTokens(sem_HsTokensRoot,wrap_HsTokensRoot, Syn_HsTokensRoot(..),Inh_HsTokensRoot(..))
-- From uulib
import qualified UU.DData.Map as Map
import qualified UU.DData.Seq as Seq
import qualified UU.DData.Set as Set
import UU.DData.Map(Map) 
import UU.DData.Set(Set) 
import UU.DData.Seq(Seq, (<>)) 
import UU.Util.Utils

-- From haskell libraries
import Control.Monad(liftM)
import qualified Data.Array as Array
import Data.Array((!),bounds,inRange)
import Data.List(elemIndex,partition,sort,mapAccumL,find,nubBy,intersperse,groupBy,transpose)
import qualified Data.Tree as Tree
import Maybe
}

{
-- Terminates with an error if the key is not in the map
findWithErr1 :: (Ord k, Show k) => String -> k -> Map k a -> a
findWithErr1 s k
  = Map.findWithDefault (error ("findWithErr1 " ++ s ++ ": key " ++ show k ++ " not in map.")) k

findWithErr2 :: (Ord k, Show k, Show a) => k -> Map k a -> a
findWithErr2 k m
  = Map.findWithDefault (error ("findWithErr2: key " ++ show k ++ " not in map: " ++ show m)) k m
}

-------------------------------------------------------------------------------
--         Errors
-------------------------------------------------------------------------------
-- Everyone that wants to report an error can do this by adding an error message to the
-- stream of errors

ATTR Productions Production Alternatives Alternative
     Child Children Rule Rules Pattern Patterns Grammar [ | | errors USE {Seq.<>} {Seq.empty}:{Seq Error} ]

-------------------------------------------------------------------------------
--         Distributing name of nonterminal and names of attributes
-------------------------------------------------------------------------------
ATTR Alternatives Alternative Child Children Rules Rule Patterns Pattern [ nt : {Identifier} inh,syn : {Attributes} | | ]
ATTR Child Children Rules Rule Patterns Pattern [ con : {Identifier} | | ]

SEM Alternative
  | Alternative children . con = @con
SEM Alternative
  | Alternative rules . con = @con
SEM Production
  | Production alts . nt = @nt

SEM Production
  | Production alts.inh  = @inh
               alts.syn  = @syn


-------------------------------------------------------------------------------
--         Distributing options
-------------------------------------------------------------------------------

ATTR Grammar          [ options:{Options} | | ]
ATTR Productions Production Alternatives Alternative Rules Rule 
   [ o_newtypes
   , o_cata
   , o_sig
   , o_sem
   , o_rename
   , o_wantvisit -- True if the option for visit functions has been specified
   , o_dovisit   -- True if o_wantvisit and it is possible to generate visit functions (no cycles)
   , o_case:{Bool}  
   prefix : {String} | | ]
ATTR Productions Production Alternatives Alternative Children Child [ o_unbox:{Bool} | | ]
ATTR Productions Production [ o_data:{Bool} | | ]

SEM Grammar
  | Grammar     prods.o_cata    = folds     @lhs.options
                     .o_data    = dataTypes @lhs.options
                     .o_sig     = typeSigs  @lhs.options
                     .o_sem     = semfuns   @lhs.options
                     .o_rename  = rename    @lhs.options
                     .o_newtypes= newtypes  @lhs.options
                     .o_wantvisit = visit   @lhs.options
                     .o_dovisit = visit     @lhs.options && null @cyclesErrors
                     .o_unbox   = unbox     @lhs.options
                     .o_case    = cases     @lhs.options
                     .prefix    = prefix    @lhs.options

------------------------------------------------------------------
-- Building a mapping from Vertices to Ints
------------------------------------------------------------------
{
getNtName :: Type -> Nonterminal
getNtName (NT nt) = nt
getNtName _       = nullIdent
}

------------------------------------------------------------------
-- Collect attribute occurrences
--
-- All attribute occurences in an alternative are gathered.
-- This is done by joining various sublists:
--  1.  inherited attributes for _LHS
--  2a. synthesized attributes for children
--  2b. children that are a trivial field
--  3a. inherited attributes for children 
--  3b. synthesized attributes for _LHS
--  3c. local attributes
--
-- Sublist 3 is exactly the targets for ATTR definitions, and
-- thus can be obtained by traversing all rules.
--
-- The (field,attr) combination is not enough to uniquely identify
-- an attribute occurence, because threaded attributes occur twice.
-- Therefore, in the AltAttr structures, a boolean is added,
-- that is False in sublists 3a and 3b, i.e. the non-local output fields.
--
-- Each AltAttr, that is eacht attribute occurence, is mapped to a number
-- in the altAttrs Map, starting at vcount
{
data AltAttr = AltAttr Name Name Bool 
               deriving (Eq, Ord, Show)
}
ATTR Children Child Rules Rule Patterns Pattern [ | | gathAltAttrs USE {++} {[]} : {[AltAttr]} ]
SEM  Alternative
  |  Alternative  loc.gathAltAttrs =  [ AltAttr _LHS inh True | inh <- Map.keys @lhs.inh ]   -- sublist 1
                                      ++ @children.gathAltAttrs                              -- sublist 2
                                      ++ @rules.gathAltAttrs                                 -- sublist 3

SEM  Child
  |  Child  loc.maptolocal =  case @tp of
                                NT nt  -> Map.isEmpty @syn
                                _      -> True
            lhs.gathAltAttrs = if  @maptolocal
                                   then [ AltAttr _LOC @name True ]                          -- sublist 2b
                                   else [ AltAttr @name syn True | syn <- Map.keys @syn ]    -- sublist 2a
SEM  Pattern
  |  Alias lhs.gathAltAttrs = [AltAttr @field @attr (@field == _LOC || @field == _INST)]     -- sublist 3

ATTR Rules Rule Patterns Pattern [ altAttrs : {Map AltAttr Vertex} | | ]
SEM  Alternative
  |  Alternative rules.altAttrs = Map.fromList (zip @gathAltAttrs [@lhs.vcount..])

-- Information passed to Pattern
ATTR  Children Child 
      [  | |  nts USE {Seq.<>} {Seq.empty} : {Seq (Name,Nonterminal)} 
              inhs USE {Seq.<>} {Seq.empty} : {Seq (Name,Attributes)} ]
SEM  Child
  |  Child  lhs.nts = Seq.single (@name,getNtName @tp)
            lhs.inhs = Seq.single (@name,@inh)
ATTR  Rules Rule
      [  childNts : {Map Name Nonterminal} 
         childInhs : {Map Name Attributes} | | ]
SEM  Alternative
  |  Alternative  rules.childNts = Map.fromList (Seq.toList @children.nts)
                  rules.childInhs = Map.fromList (Seq.toList @children.inhs)

-- Collect CRules
ATTR  Children Child Rules Rule
      [ | | gathRules USE {Seq.<>} {Seq.empty} : {Seq CRule} ]
SEM  Alternative
  |  Alternative  loc.inhRules = [ cRuleLhsInh inh @lhs.nt @con tp | (inh,tp) <- Map.assocs @lhs.inh ]
                  loc.gathRules = @inhRules ++ Seq.toList (@children.gathRules Seq.<> @rules.gathRules)

SEM  Child
  |  Child  loc.gathRules = if  @maptolocal
                                then Seq.single (cRuleTerminal @name @lhs.nt @lhs.con @tp)
                                else Seq.fromList [ cRuleRhsSyn syn @lhs.nt @lhs.con tp @name (getNtName @tp) | (syn,tp) <- Map.assocs @syn]

SEM  Rule
  |  Rule  loc.defines = let  tp field attr parts | field == _LOC || field == _INST
                                                                  = case parts of 
                                                                      [] -> Map.lookup attr @lhs.allTypeSigs
                                                                      _  -> (sequence (map typ parts)) >>= (haskellTupel . map (substSelf @lhs.nt))
                                                  | field == _LHS = Map.lookup attr @lhs.syn
                                                  | otherwise     = Map.lookup attr (findWithErr1 "Rule.defines.tp" field @lhs.childInhs)
                              typ :: Pattern -> Maybe Type
                              typ (Alias field attr _ parts) = tp field attr parts
                              typ (Underscore _)             = Nothing
                              typ (Product _ pats)           = tp _LOC undefined pats
                              typ _                          = Nothing
                              
                         in Map.fromList  [ (findWithErr1 "Rule.defines" aa @lhs.altAttrs, (field,attr,(tp field attr parts)))
                                          | (field,attr,isLocalOrInst,parts) <- @pattern.patternAttrs
                                          , let aa = AltAttr field attr isLocalOrInst
                                          ]
           loc.gathRules =  let childnt field = Map.lookup field @lhs.childNts
                            in Seq.fromList [ CRule attr False True @lhs.nt @lhs.con field (childnt field) tp @pattern.copy @rhs.textLines @defines @owrt @origin
                                            | (field,attr,tp) <- Map.elems @defines 
                                            ] 

{
substSelf nt tp = if tp==NT _SELF 
                  then Haskell (getName nt)
                  else tp
	
haskellTupel :: [Type] -> Maybe Type
haskellTupel ts =  Just ( Haskell ( '(' : (concat (intersperse "," (map show ts))) ++ ")" ))
}


ATTR Patterns Pattern [ | | patternAttrs USE {++} {[]} : {[(Name,Name,Bool,Patterns)]} ]

SEM  Pattern
  |  Alias lhs.patternAttrs = [(@field,@attr,(@field == _LOC || @field == _INST),@parts.copy)]



-- Giving them a number
ATTR  Productions Production Alternatives Alternative
      [  | vcount : Int 
         | rules USE {Seq.<>} {Seq.empty} : {Seq (Vertex,CRule)}]
SEM  Grammar
  |  Grammar  prods.vcount = 0
SEM  Alternative
  |  Alternative  lhs.rules = Seq.fromList (zip [@lhs.vcount..] @gathRules)
                  lhs.vcount = @lhs.vcount + length @gathRules

-- Direct dependencies
ATTR Productions Production 
     Alternatives Alternative 
     Rules Rule [ | | directDep USE {Seq.<>} {Seq.empty} : {Seq Edge} ]
SEM  Rule
  |  Rule  lhs.directDep
             = let  defined = Map.keys @defines
                    used =  [ Map.lookup (AltAttr field attr True) @lhs.altAttrs | (field,attr) <- @rhs.usedAttrs]
                            ++ [ Map.lookup (AltAttr _LOC attr True) @lhs.altAttrs | attr <- @rhs.usedLocals ++ @rhs.usedFields ]
               in Seq.fromList [ (x,y) | Just x <- used, y <- defined ]

-- Manual depdendencies (provided by the programmer)
--
-- a dependency f1.a1 < f2.a2 is translated to
-- the edige (vertex(f1.a1), vertex(f2.a2))
ATTR Productions Production
     Alternatives Alternative
     Rules Rule [ manualAttrDepMap : {AttrOrderMap} | | additionalDep USE {Seq.<>} {Seq.empty} : {Seq Edge} ]
SEM Grammar
  | Grammar
      prods.manualAttrDepMap = @manualAttrOrderMap
SEM Rule
  | Rule
      loc.manualDeps
        = Set.toList $ Map.findWithDefault Set.empty @lhs.con $ Map.findWithDefault Map.empty @lhs.nt @lhs.manualAttrDepMap
      lhs.additionalDep
        = Seq.fromList [ (vertexA, vertexB)
                       | Dependency (fldA,nmA) (fldB,nmB) <- @loc.manualDeps
                       , let vertexA = findWithErr2 (AltAttr fldA nmA True) @lhs.altAttrs
                       , vertexB <- lookupVertices fldB nmB @lhs.altAttrs
                       ]

{
lookupVertices :: Identifier -> Identifier -> Map AltAttr Int -> [Int]
lookupVertices fld nm attrs
  = catMaybes (  [Map.lookup (AltAttr fld nm True) attrs]
              ++ [Map.lookup (AltAttr fld nm False) attrs]
              )
}

-- Inst dependencies
--
-- For each inst attribute x of nt N, add the dependency
--  (inst.x,x.y) for each synthesized attribute of N
--

ATTR Productions Production 
     Alternatives Alternative 
     Rules Rule [ | | instDep USE {Seq.<>} {Seq.empty} : {Seq Edge} ]
SEM Rule
  | Rule
      lhs.instDep
        = Seq.fromList $
            [ (instVert, synVert)
            | (field,instNm,_) <- Map.elems @defines
            , field == _INST
            , synNm <- Map.keys (findWithErr2 instNm @lhs.synsOfChildren)
            , let instAttr = AltAttr _INST instNm True
                  synAttr  = AltAttr instNm synNm True
                  instVert = findWithErr2 instAttr @lhs.altAttrs
                  synVert  = findWithErr2 synAttr @lhs.altAttrs
            ]

ATTR Rules Rule [ synsOfChildren : {Map Name Attributes} | | ]
SEM Alternative
  | Alternative  rules.synsOfChildren = @children.collectChildrenSyns

ATTR Children Child [ | | collectChildrenSyns USE {`Map.union`} {Map.empty} : {Map Name Attributes } ]
SEM Child
  | Child  lhs.collectChildrenSyns = Map.single @name @syn


-- Wrapping an Expression

ATTR Expression [ nt,con   :{Name}
                  allfields:{[(Name,Type,Bool)]}
                  allnts   :{[Name]}
                  attrs    :{[(Name,Name)]}
                ||
                  errors   :{Seq Error}
                  usedLocals:{[Name]}
                  usedAttrs :{[(Name,Name)]}
                  usedFields:{[Name]}
                  textLines :{[String]}
                  copy : SELF
                  allRhsVars : {Set (Name,Name)}
                ]

SEM Expression
  | Expression  loc.(errors,textLines,usedAttrs,usedLocals,usedFields)
                            = let inherited = Inh_HsTokensRoot
                                              { attrs_Inh_HsTokensRoot      = @lhs.attrs
                                              , con_Inh_HsTokensRoot        = @lhs.con
                                              , allfields_Inh_HsTokensRoot  = @lhs.allfields
                                              , allnts_Inh_HsTokensRoot     = @lhs.allnts
                                              , nt_Inh_HsTokensRoot         = @lhs.nt
                                              }
                                  synthesized = wrap_HsTokensRoot (sem_HsTokensRoot (HsTokensRoot $ lexTokens @pos @txt)) inherited
                              in case synthesized of
                                   Syn_HsTokensRoot
                                    { errors_Syn_HsTokensRoot     = errors
                                    , textLines_Syn_HsTokensRoot  = textLines
                                    , usedAttrs_Syn_HsTokensRoot  = usedAttrs
                                    , usedLocals_Syn_HsTokensRoot = usedLocals
                                    , usedFields_Syn_HsTokensRoot = usedFields
                                    }  -> (errors,textLines,usedAttrs,usedLocals,usedFields)

                lhs.allRhsVars = Set.fromList @loc.usedAttrs
                                 `Set.union`
                                 Set.fromList [ (_LOC, l) | l <- @loc.usedLocals]
                                 `Set.union`
                                 Set.fromList [ (_FIELD, fld) | fld <- @loc.usedFields]

-------------------------------------
-- NT-Attributes
-------------------------------------
ATTR  Productions Production 
      [ | acount : Int |  ntattrs USE {Seq.<>} {Seq.empty} : {Seq (Vertex,NTAttr)} 
                          aranges  USE {Seq.<>} {Seq.empty} : {Seq (Int,Int,Int)}]

SEM Grammar
  | Grammar prods.acount = 0

SEM Production
  | Production loc.ntattrs =  [ NTAInh @nt inh tp | (inh,tp) <- Map.assocs @inh ]
                              ++ [NTASyn @nt syn tp | (syn,tp) <- Map.assocs @syn ]
               lhs.ntattrs = Seq.fromList (zip [@lhs.acount ..] @ntattrs)
               lhs.acount = @lhs.acount + Map.size @inh + Map.size @syn
               lhs.aranges =  Seq.single
                                (@lhs.acount
                                ,@lhs.acount + Map.size @inh
                                ,@lhs.acount + Map.size @syn + Map.size @inh - 1)
------------------------------------------------------------------
-- Pass structure up
------------------------------------------------------------------
ATTR Productions Production [ | | prods USE {++} {[]} : {[(Nonterminal,[Constructor])]} ]
SEM  Production
  |  Production  lhs.prods = [(@nt,@alts.cons)]
ATTR Alternatives Alternative [ | | cons USE {++} {[]} : {[Constructor]} ]
SEM  Alternative
  |  Alternative  lhs.cons = [@con]

------------------------------------------------------------------
-- Collect type signatures
------------------------------------------------------------------
ATTR TypeSigs TypeSig [ | typeSigs : {Map Name Type} | ]
SEM Alternative
  | Alternative typeSigs.typeSigs = Map.empty
SEM TypeSig
  | TypeSig lhs.typeSigs = Map.insert @name @tp @lhs.typeSigs

ATTR Rules Rule Patterns Pattern [ allTypeSigs : {Map Name Type} | | ]
SEM  Alternative
  |  Alternative rules.allTypeSigs = @typeSigs.typeSigs

------------------------------------------------------------------
-- Invoking sequential computation
------------------------------------------------------------------
SEM Grammar
  | Grammar loc.ruleTable = Array.array (0,@prods.vcount-1) (Seq.toList @prods.rules)
            loc.attrTable = Array.array (0,@prods.acount-1) (Seq.toList @prods.ntattrs)
            loc.attrVertex = Map.fromList (map swap (Seq.toList @prods.ntattrs))
            loc.tdpToTds  = [ (s, maybe (-1) (\v -> findWithErr1 "Grammar.tdpToTds" v @attrVertex) (ntattr cr))
                            | (s,cr) <- Seq.toList @prods.rules]
            loc.tdsToTdp  =  let  eq (_,v) (_,v') = v == v'
                                  conv ((s,v):svs)  | v == -1 = Nothing
                                                    | otherwise = Just (v,s:map fst svs)
                             in mapMaybe conv (eqClasses eq @tdpToTds)
            loc.directDep = Seq.toList (@prods.directDep Seq.<> @prods.additionalDep)
            loc.instDep   = Seq.toList @prods.instDep
            loc.info      = let def [] = -1
                                def (v:vs) = v
                             in Info { tdsToTdp   = Array.array (0,@prods.acount-1) @tdsToTdp
                                     , tdpToTds   = Array.array (0,@prods.vcount-1) @tdpToTds
                                     , attrTable  = @attrTable
                                     , ruleTable  = @ruleTable
                                     , lmh        = Seq.toList @prods.aranges
                                     , prods      = @prods.prods
                                     , wraps      = @wrappers
                                     }

            loc.(cInterfaceMap,cVisitsMap,cyclesErrors) =
                              case computeSequential @info @directDep @instDep of
                                           CycleFree    cim cvm   -> ( cim
                                                                     , cvm
                                                                     , []
                                                                     )
                                           LocalCycle   errs      -> ( error "No interfaces for AG with local cycles"
                                                                     , error "No visit sub-sequences for AG with local cycles"
                                                                     , map (localCycleErr @ruleTable (visit @lhs.options)) errs
                                                                     )
                                           InstCycle    errs      -> ( error "No interfaces for AG with cycles through insts"
                                                                     , error "No visit sub-sequences for AG with cycles through insts"
                                                                     , map (instCycleErr @ruleTable (visit @lhs.options)) errs
                                                                     )
                                           DirectCycle  errs      -> ( error "No interfaces for AG with direct cycles"
                                                                     , error "No visit sub-sequences for AG with direct cycles"
                                                                     , directCycleErrs @attrTable @ruleTable (visit @lhs.options) errs
                                                                     )
                                           InducedCycle cim errs ->  ( cim
                                                                     , error "No visit sub-sequences for AG with induced cycles"
                                                                     , inducedCycleErrs @attrTable @ruleTable cim errs
                                                                     )
            lhs.errors := (if withCycle @lhs.options then Seq.fromList @cyclesErrors else Seq.empty) 
                          Seq.<> @prods.errors

------------------------------------------------------------------
-- Generate CGrammar
------------------------------------------------------------------
-- Pass InterfaceMap down and select the Interface in the Production
ATTR Productions Production [ cInterfaceMap : CInterfaceMap | | ]
SEM  Production
  |  Production  loc.cInter = if  @lhs.o_dovisit
                                      then findWithErr1 "Production.cInter" @nt @lhs.cInterfaceMap
                                      else CInterface [CSegment @inh @syn]

-- Pass VisitMap down and select the CVisits in the Alternative
ATTR Productions Production Alternatives Alternative [ cVisitsMap : CVisitsMap | | ]
SEM  Alternative
  |  Alternative loc.cVisits = if  @lhs.o_dovisit
                                   then let altsVisitsMap = findWithErr1 "Alternative.cVisits.nt" @lhs.nt @lhs.cVisitsMap
                                            visits = findWithErr1 "Alternative.cVisits.con" @con altsVisitsMap
                                         in visits
                                   else  let  vss = nubBy eqCRuleDefines @gathRules ++ @children.singlevisits
                                         in  [CVisit @lhs.inh @lhs.syn vss [] False]

-- Declarations for single visits
ATTR Child Children [ | | singlevisits USE {++} {[]}: {[CRule]}]
SEM Child 
  | Child lhs.singlevisits  =  if  @maptolocal
                                   then []
                                   else [CChildVisit @name (getNtName @tp) 0 @inh @syn True]

-- Now just build the CGrammar
SEM  Grammar [ | | output : CGrammar ]
  |  Grammar  lhs.output = CGrammar @typeSyns @derivings @wrappers @prods.cProductions @pragmas
SEM  Productions [ | | cProductions : CProductions ]
  |  Cons  lhs.cProductions = @hd.cProduction : @tl.cProductions
  |  Nil   lhs.cProductions = []
SEM  Production [ | | cProduction : CProduction ]
  |  Production  lhs.cProduction = CProduction @nt @inh @syn @alts.cAlternatives @cInter
SEM  Alternatives [ | | cAlternatives : CAlternatives ]
  |  Cons  lhs.cAlternatives = @hd.cAlternative : @tl.cAlternatives
  |  Nil   lhs.cAlternatives = []
SEM  Alternative [ | | cAlternative : CAlternative ]
  |  Alternative  lhs.cAlternative = CAlternative @con @cVisits @children.fields @children.terminals

-- Collect terminals
ATTR Children Child  [ | | terminals USE {++} {[]} : {[Name]} ]
SEM Child
  | Child lhs.terminals = if @maptolocal
                          then [@name]
                          else []


-- Collecting nts
ATTR Production Productions
     Alternative Alternatives
     Rule Rules 
     Child Children [allnts:{[Name]} | | ]
     
SEM Grammar
  | Grammar prods.allnts = map fst (@prods.prods)

-- Collecting fields
ATTR Rule Rules 
     Child Children [allfields:{[(Name,Type,Bool)]} attrs:{[(Name,Name)]} | | ]

SEM Alternative
  | Alternative loc.allfields  = @children.fields
                   .attrs      = map ((,) _LOC)  @rules.locVars ++
                                 map ((,) _INST) @rules.instVars ++
                                 map ((,) _LHS)  @inhnames ++ 
                                 concat [map ((,) nm) (Map.keys as) | (nm,_,as) <- @children.attributes]
                   .inhnames   = Map.keys @lhs.inh
                   .synnames   = Map.keys @lhs.syn

ATTR Children [ | | attributes USE {++} {[]} : {[(Name,Attributes,Attributes)]} ]
SEM Child [ | | attributes:{[(Name,Attributes,Attributes)]} ]
  | Child lhs.attributes = [(@name, @inh, @syn)]


SEM Child [ | | field : {(Name,Type,Bool)} ]
  | Child lhs.field = (@name, @tp, @higherOrder)

SEM Children [ | | fields : {[(Name,Type,Bool)]} ]
  | Cons  lhs.fields = @hd.field : @tl.fields
  | Nil   lhs.fields = []

ATTR Rules Rule Patterns Pattern [ | | locVars USE {++} {[]}:{[Name]} instVars USE {++} {[]} : {[Name]} ]

SEM Pattern
  | Alias    lhs.locVars   = if @field == _LOC
                                then [@attr]
                                else []
             lhs.instVars  = if @field == _INST
                                then [@attr]
                                else []

{
swap (a,b) = (b,a)

showPath :: Table CRule -> [Vertex] -> [String]
showPath ruleTable path
  =  let  look a | inRange (bounds ruleTable) a = [showOrigin (ruleTable ! a)]
                 | otherwise = ["Vertex " ++ show a]
          showOrigin cr  | getHasCode cr && getName (getAttr cr) /= "self" = prettyCRule cr ++ " (" ++ show (getPos (getAttr cr)) ++ ")"
                         | otherwise = prettyCRule cr
     in concatMap look path


showPathLocal :: Table CRule -> [Vertex] -> [String]
showPathLocal _ [] = []
showPathLocal ruleTable xs = showP (xs++[-1])
 where showP []         = []
       showP (v1:v2:vs) = let line  = step v1 v2
                              lines = showP vs
                          in  line:lines
       step v1 v2  = " - " ++ a1
        where r1 = ruleTable ! v1
              a1 = show (getAttr  r1)


limitTo :: Int -> [String] -> [String]
limitTo _ [] = [] 
limitTo 0 _ = ["....etcetera, etcetera...."]
limitTo n (x:xs) = x : limitTo (n-1) xs

showPathNice :: Table CRule -> [Vertex] -> [String]
showPathNice _ [] = []
showPathNice ruleTable xs = limitTo 100 (showP ((-1):xs++[-1]))
 where [maxf, maxa, maxn, maxc] = maxWidths ruleTable (take 100 xs)
       showP []         = []
       showP (v1:v2:vs) = let line  = step v1 v2
                              lines = showP vs
                          in  if null line  then lines  else line:lines
       step v1 v2  |  last &&      first    = induced
                   |  last &&     isSyn r1  = "pass up        "  ++ alignR maxf ""    ++ " " ++ alignL maxa a1 ++ " in " ++ alignR maxn n1 ++ "|" ++ c1 ++ induced
                   |  first&& not(isSyn r2) = "get from above "  ++ alignR maxf ""    ++ " " ++ alignL maxa a2 ++ " in " ++ alignR maxn n2 ++ "|" ++ c2
                   |  last                  = "pass down      "  ++ alignR maxf f1    ++ "." ++ a1                                                      ++ induced
                   |              isSyn r2  = "get from below "  ++ alignR maxf f2    ++ "." ++ alignL maxa a2 ++ " in " ++ alignR maxn n2 ++ "|" ++ c2
                   |  isLocal r1  = if head a1 == '_' 
                                         then ""
                                         else "calculate      "  ++ alignR maxf "loc" ++ "." ++ a1
                   |  otherwise             = "pass down      "  ++ alignR maxf f1    ++ "." ++ alignL maxa a1 ++ " to " ++ alignR maxn n2 ++ "|" ++ c2
          where
              first = v1<0
              last  = v2<0
              r1 = ruleTable ! v1
              r2 = ruleTable ! v2
              a1 = show (getAttr  r1)
              a2 = show (getAttr  r2)
              f1 = show (getField r1)
              f2 = show (getField r2)
              n1 = show (getLhsNt r1)
              n2 = show (getLhsNt r2)
              c1 = show (getCon   r1)
              c2 = show (getCon   r2)
              induced | v2== -2   =  " INDUCED dependency to "
                      | otherwise = ""


maxWidths ruleTable vs
  = map maximum (transpose (map getWidth vs))
  where getWidth v | v<0       = [0,0,0,0]
                   | otherwise = map (length . show . ($ (ruleTable!v))) [getField, getAttr, getLhsNt, getCon]

alignL n xs | k<n       = xs ++ replicate (n-k) ' '
            | otherwise = xs
              where k = length xs

alignR n xs | k<n       = replicate (n-k) ' ' ++ xs
            | otherwise = xs
              where k = length xs

localCycleErr :: Table CRule -> Bool -> Route -> Error
localCycleErr ruleTable o_visit (s:path)
  =  let cr = ruleTable ! s
         attr = getAttr cr
         nt = getLhsNt cr
         con = getCon cr
     in LocalCirc nt con attr o_visit (showPathLocal ruleTable path)

instCycleErr :: Table CRule -> Bool -> Route -> Error
instCycleErr ruleTable o_visit (s:path)
  =  let cr = ruleTable ! s
         attr = getAttr cr
         nt = getLhsNt cr
         con = getCon cr
     in InstCirc nt con attr o_visit (showPathLocal ruleTable path)

directCycleErrs :: Table NTAttr -> Table CRule -> Bool -> [EdgeRoutes] -> [Error]
directCycleErrs attrTable ruleTable o_visit xs
  = let getNont v = case attrTable ! v of
                      NTASyn nt _ _ -> nt
                      NTAInh nt _ _ -> nt
        getAttr v = case attrTable ! v of
                      NTASyn _ a _  -> a
                      NTAInh _ a _  -> a
        sameNont ((v1,_),_,_) ((v2,_),_,_) =  getNont v1 == getNont v2
        procCycle ((v1,v2),p1,p2) = ((getAttr v1, getAttr v2), showPathNice ruleTable p1, showPathNice ruleTable p2)
        wrapGroup gr@(((v1,_),_,_):_) = DirectCirc (getNont v1) o_visit (map procCycle gr)
    in  map wrapGroup (groupBy sameNont xs)

inducedCycleErrs :: Table NTAttr -> Table CRule -> CInterfaceMap -> [EdgeRoutes] -> [Error]
inducedCycleErrs attrTable ruleTable cim xs
  = let getNont v = case attrTable ! v of
                      NTASyn nt _ _ -> nt
                      NTAInh nt _ _ -> nt
        getAttr v = case attrTable ! v of
                      NTASyn _ a _  -> a
                      NTAInh _ a _  -> a
        sameNont ((v1,_),_,_) ((v2,_),_,_) =  getNont v1 == getNont v2
        procCycle ((v1,v2),p1,p2) = ((getAttr v1, getAttr v2), showPathNice ruleTable p1, showPathNice ruleTable p2)
        wrapGroup gr@(((v1,_),_,_):_) = InducedCirc (getNont v1) (findWithErr1 "inducedCycleErr.cinter" (getNont v1) cim) (map procCycle gr)
    in  map wrapGroup (groupBy sameNont xs)
}
