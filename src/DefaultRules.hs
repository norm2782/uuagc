-- do not edit; automatically generated by UU.AG
module DefaultRules where

import List
import AbstractSyntax
import CommonTypes
import Patterns
import qualified UU.DData.Map as Map
import qualified UU.DData.Seq as Seq
import qualified UU.DData.Set as Set
import UU.DData.Map(Map) 
import UU.DData.Set(Set) 
import UU.DData.Seq(Seq, (<>)) 
import UU.Util.Utils
import List (deleteBy,partition)
import qualified List (delete)
import UU.Pretty
import Maybe
import ErrorMessages
import Expression
import UU.Scanner.Position(Pos,noPos)
import Options

import CommonTypes
import UU.Pretty
import Patterns
import Expression
import UU.DData.Set(Set)

import UU.Scanner.Position(Pos)
import CommonTypes

attrName fld attr | fld == _LOC = locName attr 
                  | otherwise   = '@':getName fld ++ "." ++ getName attr
locName n         = '@': getName n

_ACHILD = Ident "(" noPos -- hack

getConName typeSyns rename nt con1 | nt `elem` map fst typeSyns = synonym
                                   | otherwise =  normalName

 where con = getName con1
       normalName | rename    = getName nt++"_"++ con
                  | otherwise =  con
       synonym | con == "Cons"     = "(:)"
               | con == "Nil"      = "[]"
               | con == "Just"     = "Just"
               | con == "Nothing"  = "Nothing"
               | otherwise         = normalName

concatSeq = foldr Seq.append Seq.empty


copy_rule nt con modcopy locals (env,(fld,as)) = foldr copy_rl ([],Seq.empty) as
 where copy_rl a ~(rs,es) 
        | not modcopy && Set.member a locals     = (makeRule (fld,a) (fst (mkExpr _LOC)) "copy rule (from local)":rs, es)
        | otherwise             = let sel        = Map.lookup a env
                                      ((expr,err),origin) = 
                                                   case sel of
                                                    Nothing -> (undef,cruletxt sel)
                                                    Just f | f == _ACHILD -> (child_copy,"deprecated child copy") -- HACK!!
                                                           | otherwise    -> (mkExpr f,cruletxt sel)
                                                    
                                  in (makeRule (fld,a) expr origin:rs, es<>err)
        where mkExpr t = (Expression noPos $ attrName t a, Seq.empty)
              undef = (Expression noPos $ "error \"missing rule: " ++ show nt ++ "." ++ show con ++ "." 
                                                                     ++  show fld ++ "." ++ show a ++ "\""
                      , Seq.single (MissingRule nt con fld a))
              child_copy = (Expression noPos $ fieldname a
                           ,let mesg = "In the definitions for alternative" >#< getName con >#< "of nonterminal" >#< getName nt >|< "," 
                                       >-< "the value of field" >#< getName a  >#< "is copied by a copy-rule."                                    
                                       >-< "Copying the value of a field using a copy-rule is deprecated"
                                       >-< "Please add the following lines to your code:"
                                       >-< ("SEM" >#< getName nt
                                             >-< indent 2 ("|" >#< getName con >#< getName fld >#< "." >#< a >#< "=" >#< "@" >|< a)
                                           )  
                            in Seq.single (CustomError True (getPos a) mesg )
                           )                           
              -- inform the user if the modified copy rule is in use
              cruletxt sel | Set.member a locals && nonlocal                    = "modified copy rule"
                           | incoming && outgoing                               = "copy rule (chain)"
                           | incoming                                           = "copy rule (down)"
                           | outgoing                                           = "copy rule (up)"
                           | otherwise                                          = "copy rule (chain)"
                where outgoing = fld == _LHS
                      incoming = maybe False (== _LHS) sel
                      nonlocal = maybe False (/= _LOC) sel

makeRule (f1,a1) expr origin = Rule (Alias f1 a1 (Underscore noPos)) expr False origin

splitAttrs _      []           = ([],[])
splitAttrs useMap (n:rest) = 
     let (uses,normals) = splitAttrs useMap rest
     in case Map.lookup n useMap of
          Just x  -> ((n,x):uses,normals)       
          Nothing -> (uses      ,n:normals)

useRule locals ch_outs (n,(op,e)) = 
                             let elems = [ fld |  (fld,as) <- ch_outs, Map.member n as]
                                 expr | Set.member n locals = attrName _LOC n
                                      | null elems = e
                                      | otherwise  = foldr1 (\x y -> x ++ " " ++ op ++ " " ++ y) (map (flip attrName n) elems)
                             in makeRule (_LHS,n) (Expression noPos expr) "use rule"

removeDefined defined (fld,as) = (fld, [ a | a <- Map.keys as, not (Set.member (fld,a) defined) ])
-- Alternative -------------------------------------------------
{-
   inherited attributes:
      cr                   : Bool
      inh                  : Attributes
      nonterminals         : Set Nonterminal
      nt                   : Nonterminal
      o_rename             : Bool
      syn                  : Attributes
      typeSyns             : TypeSyns
      useMap               : Map Name (String,String)

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      out                  : SELF

-}
{-
   local variables for Alternative.Alternative:
      newRls
      errs
      out

-}
-- semantic domain
newtype T_Alternative = T_Alternative ((Bool) ->
                                       (Attributes) ->
                                       (Set Nonterminal) ->
                                       (Nonterminal) ->
                                       (Bool) ->
                                       (Attributes) ->
                                       (TypeSyns) ->
                                       (Map Name (String,String)) ->
                                       ( (Seq Error),(Alternative)))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative (_con) (_children) (_rules))) =
    (sem_Alternative_Alternative (_con) ((sem_Children (_children))) ((sem_Rules (_rules))))
data Inh_Alternative = Inh_Alternative {cr_Inh_Alternative :: Bool,inh_Inh_Alternative :: Attributes,nonterminals_Inh_Alternative :: Set Nonterminal,nt_Inh_Alternative :: Nonterminal,o_rename_Inh_Alternative :: Bool,syn_Inh_Alternative :: Attributes,typeSyns_Inh_Alternative :: TypeSyns,useMap_Inh_Alternative :: Map Name (String,String)}
data Syn_Alternative = Syn_Alternative {errors_Syn_Alternative :: Seq Error,out_Syn_Alternative :: Alternative}
wrap_Alternative :: (T_Alternative) ->
                    (Inh_Alternative) ->
                    (Syn_Alternative)
wrap_Alternative ((T_Alternative (sem))) ((Inh_Alternative (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8))) =
    let ( s1,s2) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8))
    in  (Syn_Alternative (s1) (s2))
sem_Alternative_Alternative :: (Constructor) ->
                               (T_Children) ->
                               (T_Rules) ->
                               (T_Alternative)
sem_Alternative_Alternative (con_) ((T_Children (children_))) ((T_Rules (rules_))) =
    (T_Alternative (\ _lhsIcr
                      _lhsIinh
                      _lhsInonterminals
                      _lhsInt
                      _lhsIo_rename
                      _lhsIsyn
                      _lhsItypeSyns
                      _lhsIuseMap ->
                        let _lhsOerrors :: (Seq Error)
                            _lhsOout :: (Alternative)
                            _childrenIerrors :: (Seq Error)
                            _childrenIfields :: ([(Name,Type)])
                            _childrenIinputs :: ([(Name, Attributes)])
                            _childrenIout :: (Children)
                            _childrenIoutputs :: ([(Name, Attributes)])
                            _childrenOcon :: (Constructor)
                            _childrenOcr :: (Bool)
                            _childrenOnt :: (Nonterminal)
                            _rulesIdefinedAttrs :: (Set (Name,Name))
                            _rulesIerrors :: (Seq Error)
                            _rulesIlocals :: (Set Name)
                            _rulesIout :: (Rules)
                            _rulesOcon :: (Constructor)
                            _rulesOnt :: (Nonterminal)
                            ( _childrenIerrors,_childrenIfields,_childrenIinputs,_childrenIout,_childrenIoutputs) =
                                (children_ (_childrenOcon) (_childrenOcr) (_childrenOnt))
                            ( _rulesIdefinedAttrs,_rulesIerrors,_rulesIlocals,_rulesIout) =
                                (rules_ (_rulesOcon) (_rulesOnt))
                            -- "DefaultRules.ag"(line 118, column 17)
                            (_childrenOcon@_) =
                                con_
                            -- "DefaultRules.ag"(line 117, column 17)
                            (_rulesOcon@_) =
                                con_
                            -- "DefaultRules.ag"(line 238, column 16)
                            (_lhsOerrors@_) =
                                _childrenIerrors <> _errs <> _rulesIerrors
                            -- "DefaultRules.ag"(line 199, column 20)
                            ((_newRls@_,_errs@_)) =
                                let locals       = _rulesIlocals
                                    initenv      = Map.fromList ([(a,_ACHILD) | (a,_) <- _childrenIfields] ++ attrs(_LHS, _lhsIinh) ++ [(a,_LOC) |  a <- Set.toList locals])
                                    attrs (n,as) = [ (a,n) | a <- Map.keys as ]
                                    envs    = scanl (flip Map.union) initenv (map (Map.fromList . attrs ) _childrenIoutputs)
                                    child_envs = init envs
                                    lhs_env    = last envs
                                    (rss,ess)  = unzip $ map (copy_rule _lhsInt con_ _lhsIcr locals)
                                                                    (zip envs (map (removeDefined _rulesIdefinedAttrs) _childrenIinputs))
                                    errors     = concatSeq ess
                                    rules      = concat rss
                                    (rules_lhs, errors2) = let (selfAttrs, normalAttrs) = Map.partition (==NT _SELF) _lhsIsyn
                                                               (_,undefAttrs)    = removeDefined _rulesIdefinedAttrs (_LHS, normalAttrs)
                                                               (useAttrs,others) = splitAttrs _lhsIuseMap undefAttrs
                                                               uRules            = map (useRule locals _childrenIoutputs) useAttrs
                                                               selfLocRules  = let childSelf self nm tp = case tp of
                                                                                     NT nt  -> attrName nm self
                                                                                     _      -> fieldname nm
                                                                               in [ makeRule (_LOC,attr)
                                                                                          (Expression noPos
                                                                                            (constructor [childSelf attr nm tp | (nm,tp) <- _childrenIfields]
                                                                                            )
                                                                                          )  "self rule"
                                                                                  | let constructor | getName con_ == "Tuple" && _lhsInt `elem` map fst _lhsItypeSyns
                                                                                                           = \fs -> "(" ++ concat (intersperse "," fs) ++ ")"
                                                                                                    | otherwise = \fs ->  getConName _lhsItypeSyns _lhsIo_rename _lhsInt con_ ++ " " ++ unwords fs
                                                                                  , attr <- Map.keys selfAttrs
                                                                                  , not (Set.member attr locals)
                                                                                  ]
                                                               selfRules     = [ makeRule (_LHS,attr) (Expression noPos (locName attr)) "self rule"
                                                                               | attr <- Map.keys selfAttrs
                                                                               , not (Set.member (_LHS,attr) _rulesIdefinedAttrs) ]
                                                               (rules,errs) = copy_rule _lhsInt con_ _lhsIcr locals
                                                                                    (lhs_env,  (_LHS, others))
                                                           in (uRules++selfLocRules++selfRules++rules,errs)
                                in (rules_lhs++rules,errors<>errors2)
                            -- "DefaultRules.ag"(line 276, column 17)
                            (_lhsOout@_) =
                                Alternative con_ _childrenIout (_rulesIout ++ _newRls)
                            -- self rule
                            (_out@_) =
                                Alternative con_ _childrenIout _rulesIout
                            -- copy rule (down)
                            (_childrenOcr@_) =
                                _lhsIcr
                            -- copy rule (down)
                            (_childrenOnt@_) =
                                _lhsInt
                            -- copy rule (down)
                            (_rulesOnt@_) =
                                _lhsInt
                        in  ( _lhsOerrors,_lhsOout)))
-- Alternatives ------------------------------------------------
{-
   inherited attributes:
      cr                   : Bool
      inh                  : Attributes
      nonterminals         : Set Nonterminal
      nt                   : Nonterminal
      o_rename             : Bool
      syn                  : Attributes
      typeSyns             : TypeSyns
      useMap               : Map Name (String,String)

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      out                  : SELF

-}
{-
   local variables for Alternatives.Cons:
      out

-}
{-
   local variables for Alternatives.Nil:
      out

-}
-- semantic domain
newtype T_Alternatives = T_Alternatives ((Bool) ->
                                         (Attributes) ->
                                         (Set Nonterminal) ->
                                         (Nonterminal) ->
                                         (Bool) ->
                                         (Attributes) ->
                                         (TypeSyns) ->
                                         (Map Name (String,String)) ->
                                         ( (Seq Error),(Alternatives)))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
data Inh_Alternatives = Inh_Alternatives {cr_Inh_Alternatives :: Bool,inh_Inh_Alternatives :: Attributes,nonterminals_Inh_Alternatives :: Set Nonterminal,nt_Inh_Alternatives :: Nonterminal,o_rename_Inh_Alternatives :: Bool,syn_Inh_Alternatives :: Attributes,typeSyns_Inh_Alternatives :: TypeSyns,useMap_Inh_Alternatives :: Map Name (String,String)}
data Syn_Alternatives = Syn_Alternatives {errors_Syn_Alternatives :: Seq Error,out_Syn_Alternatives :: Alternatives}
wrap_Alternatives :: (T_Alternatives) ->
                     (Inh_Alternatives) ->
                     (Syn_Alternatives)
wrap_Alternatives ((T_Alternatives (sem))) ((Inh_Alternatives (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8))) =
    let ( s1,s2) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8))
    in  (Syn_Alternatives (s1) (s2))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons ((T_Alternative (hd_))) ((T_Alternatives (tl_))) =
    (T_Alternatives (\ _lhsIcr
                       _lhsIinh
                       _lhsInonterminals
                       _lhsInt
                       _lhsIo_rename
                       _lhsIsyn
                       _lhsItypeSyns
                       _lhsIuseMap ->
                         let _lhsOerrors :: (Seq Error)
                             _lhsOout :: (Alternatives)
                             _hdIerrors :: (Seq Error)
                             _hdIout :: (Alternative)
                             _hdOcr :: (Bool)
                             _hdOinh :: (Attributes)
                             _hdOnonterminals :: (Set Nonterminal)
                             _hdOnt :: (Nonterminal)
                             _hdOo_rename :: (Bool)
                             _hdOsyn :: (Attributes)
                             _hdOtypeSyns :: (TypeSyns)
                             _hdOuseMap :: (Map Name (String,String))
                             _tlIerrors :: (Seq Error)
                             _tlIout :: (Alternatives)
                             _tlOcr :: (Bool)
                             _tlOinh :: (Attributes)
                             _tlOnonterminals :: (Set Nonterminal)
                             _tlOnt :: (Nonterminal)
                             _tlOo_rename :: (Bool)
                             _tlOsyn :: (Attributes)
                             _tlOtypeSyns :: (TypeSyns)
                             _tlOuseMap :: (Map Name (String,String))
                             ( _hdIerrors,_hdIout) =
                                 (hd_ (_hdOcr) (_hdOinh) (_hdOnonterminals) (_hdOnt) (_hdOo_rename) (_hdOsyn) (_hdOtypeSyns) (_hdOuseMap))
                             ( _tlIerrors,_tlIout) =
                                 (tl_ (_tlOcr) (_tlOinh) (_tlOnonterminals) (_tlOnt) (_tlOo_rename) (_tlOsyn) (_tlOtypeSyns) (_tlOuseMap))
                             -- use rule
                             (_lhsOerrors@_) =
                                 _hdIerrors Seq.<> _tlIerrors
                             -- self rule
                             (_out@_) =
                                 (:) _hdIout _tlIout
                             -- self rule
                             (_lhsOout@_) =
                                 _out
                             -- copy rule (down)
                             (_hdOcr@_) =
                                 _lhsIcr
                             -- copy rule (down)
                             (_hdOinh@_) =
                                 _lhsIinh
                             -- copy rule (down)
                             (_hdOnonterminals@_) =
                                 _lhsInonterminals
                             -- copy rule (down)
                             (_hdOnt@_) =
                                 _lhsInt
                             -- copy rule (down)
                             (_hdOo_rename@_) =
                                 _lhsIo_rename
                             -- copy rule (down)
                             (_hdOsyn@_) =
                                 _lhsIsyn
                             -- copy rule (down)
                             (_hdOtypeSyns@_) =
                                 _lhsItypeSyns
                             -- copy rule (down)
                             (_hdOuseMap@_) =
                                 _lhsIuseMap
                             -- copy rule (down)
                             (_tlOcr@_) =
                                 _lhsIcr
                             -- copy rule (down)
                             (_tlOinh@_) =
                                 _lhsIinh
                             -- copy rule (down)
                             (_tlOnonterminals@_) =
                                 _lhsInonterminals
                             -- copy rule (down)
                             (_tlOnt@_) =
                                 _lhsInt
                             -- copy rule (down)
                             (_tlOo_rename@_) =
                                 _lhsIo_rename
                             -- copy rule (down)
                             (_tlOsyn@_) =
                                 _lhsIsyn
                             -- copy rule (down)
                             (_tlOtypeSyns@_) =
                                 _lhsItypeSyns
                             -- copy rule (down)
                             (_tlOuseMap@_) =
                                 _lhsIuseMap
                         in  ( _lhsOerrors,_lhsOout)))
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil  =
    (T_Alternatives (\ _lhsIcr
                       _lhsIinh
                       _lhsInonterminals
                       _lhsInt
                       _lhsIo_rename
                       _lhsIsyn
                       _lhsItypeSyns
                       _lhsIuseMap ->
                         let _lhsOerrors :: (Seq Error)
                             _lhsOout :: (Alternatives)
                             -- use rule
                             (_lhsOerrors@_) =
                                 Seq.empty
                             -- self rule
                             (_out@_) =
                                 []
                             -- self rule
                             (_lhsOout@_) =
                                 _out
                         in  ( _lhsOerrors,_lhsOout)))
-- Child -------------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      cr                   : Bool
      nt                   : Nonterminal

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      field                :  (Name,Type) 
      inherited            : Attributes
      name                 : Name
      out                  : SELF
      synthesized          : Attributes

-}
{-
   local variables for Child.Child:
      out

-}
-- semantic domain
newtype T_Child = T_Child ((Constructor) ->
                           (Bool) ->
                           (Nonterminal) ->
                           ( (Seq Error),( (Name,Type) ),(Attributes),(Name),(Child),(Attributes)))
-- cata
sem_Child :: (Child) ->
             (T_Child)
sem_Child ((Child (_name) (_tp) (_inh) (_syn))) =
    (sem_Child_Child (_name) (_tp) (_inh) (_syn))
data Inh_Child = Inh_Child {con_Inh_Child :: Constructor,cr_Inh_Child :: Bool,nt_Inh_Child :: Nonterminal}
data Syn_Child = Syn_Child {errors_Syn_Child :: Seq Error,field_Syn_Child ::  (Name,Type) ,inherited_Syn_Child :: Attributes,name_Syn_Child :: Name,out_Syn_Child :: Child,synthesized_Syn_Child :: Attributes}
wrap_Child :: (T_Child) ->
              (Inh_Child) ->
              (Syn_Child)
wrap_Child ((T_Child (sem))) ((Inh_Child (i1) (i2) (i3))) =
    let ( s1,s2,s3,s4,s5,s6) =
            (sem (i1) (i2) (i3))
    in  (Syn_Child (s1) (s2) (s3) (s4) (s5) (s6))
sem_Child_Child :: (Name) ->
                   (Type) ->
                   (Attributes) ->
                   (Attributes) ->
                   (T_Child)
sem_Child_Child (name_) (tp_) (inh_) (syn_) =
    (T_Child (\ _lhsIcon
                _lhsIcr
                _lhsInt ->
                  let _lhsOerrors :: (Seq Error)
                      _lhsOfield :: ( (Name,Type) )
                      _lhsOinherited :: (Attributes)
                      _lhsOname :: (Name)
                      _lhsOout :: (Child)
                      _lhsOsynthesized :: (Attributes)
                      -- "DefaultRules.ag"(line 120, column 11)
                      (_lhsOname@_) =
                          name_
                      -- "DefaultRules.ag"(line 130, column 11)
                      (_lhsOsynthesized@_) =
                          syn_
                      -- "DefaultRules.ag"(line 129, column 11)
                      (_lhsOinherited@_) =
                          inh_
                      -- "DefaultRules.ag"(line 255, column 11)
                      (_lhsOfield@_) =
                          (name_,tp_)
                      -- use rule
                      (_lhsOerrors@_) =
                          Seq.empty
                      -- self rule
                      (_out@_) =
                          Child name_ tp_ inh_ syn_
                      -- self rule
                      (_lhsOout@_) =
                          _out
                  in  ( _lhsOerrors,_lhsOfield,_lhsOinherited,_lhsOname,_lhsOout,_lhsOsynthesized)))
-- Children ----------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      cr                   : Bool
      nt                   : Nonterminal

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      fields               : [(Name,Type)]
      inputs               : [(Name, Attributes)]
      out                  : SELF
      outputs              : [(Name, Attributes)]

-}
{-
   local variables for Children.Cons:
      out

-}
{-
   local variables for Children.Nil:
      out

-}
-- semantic domain
newtype T_Children = T_Children ((Constructor) ->
                                 (Bool) ->
                                 (Nonterminal) ->
                                 ( (Seq Error),([(Name,Type)]),([(Name, Attributes)]),(Children),([(Name, Attributes)])))
-- cata
sem_Children :: (Children) ->
                (T_Children)
sem_Children (list) =
    (foldr (sem_Children_Cons) (sem_Children_Nil) ((map sem_Child list)))
data Inh_Children = Inh_Children {con_Inh_Children :: Constructor,cr_Inh_Children :: Bool,nt_Inh_Children :: Nonterminal}
data Syn_Children = Syn_Children {errors_Syn_Children :: Seq Error,fields_Syn_Children :: [(Name,Type)],inputs_Syn_Children :: [(Name, Attributes)],out_Syn_Children :: Children,outputs_Syn_Children :: [(Name, Attributes)]}
wrap_Children :: (T_Children) ->
                 (Inh_Children) ->
                 (Syn_Children)
wrap_Children ((T_Children (sem))) ((Inh_Children (i1) (i2) (i3))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2) (i3))
    in  (Syn_Children (s1) (s2) (s3) (s4) (s5))
sem_Children_Cons :: (T_Child) ->
                     (T_Children) ->
                     (T_Children)
sem_Children_Cons ((T_Child (hd_))) ((T_Children (tl_))) =
    (T_Children (\ _lhsIcon
                   _lhsIcr
                   _lhsInt ->
                     let _lhsOerrors :: (Seq Error)
                         _lhsOfields :: ([(Name,Type)])
                         _lhsOinputs :: ([(Name, Attributes)])
                         _lhsOout :: (Children)
                         _lhsOoutputs :: ([(Name, Attributes)])
                         _hdIerrors :: (Seq Error)
                         _hdIfield :: ( (Name,Type) )
                         _hdIinherited :: (Attributes)
                         _hdIname :: (Name)
                         _hdIout :: (Child)
                         _hdIsynthesized :: (Attributes)
                         _hdOcon :: (Constructor)
                         _hdOcr :: (Bool)
                         _hdOnt :: (Nonterminal)
                         _tlIerrors :: (Seq Error)
                         _tlIfields :: ([(Name,Type)])
                         _tlIinputs :: ([(Name, Attributes)])
                         _tlIout :: (Children)
                         _tlIoutputs :: ([(Name, Attributes)])
                         _tlOcon :: (Constructor)
                         _tlOcr :: (Bool)
                         _tlOnt :: (Nonterminal)
                         ( _hdIerrors,_hdIfield,_hdIinherited,_hdIname,_hdIout,_hdIsynthesized) =
                             (hd_ (_hdOcon) (_hdOcr) (_hdOnt))
                         ( _tlIerrors,_tlIfields,_tlIinputs,_tlIout,_tlIoutputs) =
                             (tl_ (_tlOcon) (_tlOcr) (_tlOnt))
                         -- "DefaultRules.ag"(line 133, column 10)
                         (_lhsOoutputs@_) =
                             (_hdIname, _hdIsynthesized) : _tlIoutputs
                         -- "DefaultRules.ag"(line 133, column 10)
                         (_lhsOinputs@_) =
                             (_hdIname, _hdIinherited) : _tlIinputs
                         -- "DefaultRules.ag"(line 251, column 10)
                         (_lhsOfields@_) =
                             _hdIfield : _tlIfields
                         -- use rule
                         (_lhsOerrors@_) =
                             _hdIerrors Seq.<> _tlIerrors
                         -- self rule
                         (_out@_) =
                             (:) _hdIout _tlIout
                         -- self rule
                         (_lhsOout@_) =
                             _out
                         -- copy rule (down)
                         (_hdOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_hdOcr@_) =
                             _lhsIcr
                         -- copy rule (down)
                         (_hdOnt@_) =
                             _lhsInt
                         -- copy rule (down)
                         (_tlOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_tlOcr@_) =
                             _lhsIcr
                         -- copy rule (down)
                         (_tlOnt@_) =
                             _lhsInt
                     in  ( _lhsOerrors,_lhsOfields,_lhsOinputs,_lhsOout,_lhsOoutputs)))
sem_Children_Nil :: (T_Children)
sem_Children_Nil  =
    (T_Children (\ _lhsIcon
                   _lhsIcr
                   _lhsInt ->
                     let _lhsOerrors :: (Seq Error)
                         _lhsOfields :: ([(Name,Type)])
                         _lhsOinputs :: ([(Name, Attributes)])
                         _lhsOout :: (Children)
                         _lhsOoutputs :: ([(Name, Attributes)])
                         -- "DefaultRules.ag"(line 135, column 10)
                         (_lhsOoutputs@_) =
                             []
                         -- "DefaultRules.ag"(line 135, column 10)
                         (_lhsOinputs@_) =
                             []
                         -- "DefaultRules.ag"(line 252, column 10)
                         (_lhsOfields@_) =
                             []
                         -- use rule
                         (_lhsOerrors@_) =
                             Seq.empty
                         -- self rule
                         (_out@_) =
                             []
                         -- self rule
                         (_lhsOout@_) =
                             _out
                     in  ( _lhsOerrors,_lhsOfields,_lhsOinputs,_lhsOout,_lhsOoutputs)))
-- Grammar -----------------------------------------------------
{-
   inherited attributes:
      options              : Options

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      out                  : SELF

-}
{-
   local variables for Grammar.Grammar:
      out

-}
-- semantic domain
newtype T_Grammar = T_Grammar ((Options) ->
                               ( (Seq Error),(Grammar)))
-- cata
sem_Grammar :: (Grammar) ->
               (T_Grammar)
sem_Grammar ((Grammar (_typeSyns) (_useMap) (_derivings) (_wrappers) (_prods))) =
    (sem_Grammar_Grammar (_typeSyns) (_useMap) (_derivings) (_wrappers) ((sem_Productions (_prods))))
data Inh_Grammar = Inh_Grammar {options_Inh_Grammar :: Options}
data Syn_Grammar = Syn_Grammar {errors_Syn_Grammar :: Seq Error,out_Syn_Grammar :: Grammar}
wrap_Grammar :: (T_Grammar) ->
                (Inh_Grammar) ->
                (Syn_Grammar)
wrap_Grammar ((T_Grammar (sem))) ((Inh_Grammar (i1))) =
    let ( s1,s2) =
            (sem (i1))
    in  (Syn_Grammar (s1) (s2))
sem_Grammar_Grammar :: (TypeSyns) ->
                       (UseMap) ->
                       (Derivings) ->
                       (Set Nonterminal) ->
                       (T_Productions) ->
                       (T_Grammar)
sem_Grammar_Grammar (typeSyns_) (useMap_) (derivings_) (wrappers_) ((T_Productions (prods_))) =
    (T_Grammar (\ _lhsIoptions ->
                    let _lhsOerrors :: (Seq Error)
                        _lhsOout :: (Grammar)
                        _prodsIcollect_nts :: (Set Nonterminal)
                        _prodsIerrors :: (Seq Error)
                        _prodsIout :: (Productions)
                        _prodsOcr :: (Bool)
                        _prodsOnonterminals :: (Set Nonterminal)
                        _prodsOo_rename :: (Bool)
                        _prodsOtypeSyns :: (TypeSyns)
                        _prodsOuseMap :: (UseMap)
                        ( _prodsIcollect_nts,_prodsIerrors,_prodsIout) =
                            (prods_ (_prodsOcr) (_prodsOnonterminals) (_prodsOo_rename) (_prodsOtypeSyns) (_prodsOuseMap))
                        -- "DefaultRules.ag"(line 55, column 17)
                        (_prodsOcr@_) =
                            modcopy   _lhsIoptions
                        -- "DefaultRules.ag"(line 54, column 17)
                        (_prodsOo_rename@_) =
                            rename    _lhsIoptions
                        -- "DefaultRules.ag"(line 98, column 13)
                        (_prodsOnonterminals@_) =
                            _prodsIcollect_nts
                        -- "DefaultRules.ag"(line 122, column 13)
                        (_prodsOuseMap@_) =
                            useMap_
                        -- "DefaultRules.ag"(line 124, column 13)
                        (_prodsOtypeSyns@_) =
                            typeSyns_
                        -- use rule
                        (_lhsOerrors@_) =
                            _prodsIerrors
                        -- self rule
                        (_out@_) =
                            Grammar typeSyns_ useMap_ derivings_ wrappers_ _prodsIout
                        -- self rule
                        (_lhsOout@_) =
                            _out
                    in  ( _lhsOerrors,_lhsOout)))
-- Pattern -----------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      nt                   : Nonterminal

   chained attributes:

   synthesised attributes:
      containsVars         : Bool
      definedAttrs         : Set (Name,Name)
      errors               : Seq Error
      locals               : Set Name
      out                  : SELF

-}
{-
   local variables for Pattern.Alias:
      out

-}
{-
   local variables for Pattern.Constr:
      out

-}
{-
   local variables for Pattern.Product:
      out

-}
{-
   local variables for Pattern.Underscore:
      out

-}
-- semantic domain
newtype T_Pattern = T_Pattern ((Constructor) ->
                               (Nonterminal) ->
                               ( (Bool),(Set (Name,Name)),(Seq Error),(Set Name),(Pattern)))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Alias (_field) (_attr) (_pat))) =
    (sem_Pattern_Alias (_field) (_attr) ((sem_Pattern (_pat))))
sem_Pattern ((Constr (_name) (_pats))) =
    (sem_Pattern_Constr (_name) ((sem_Patterns (_pats))))
sem_Pattern ((Product (_pos) (_pats))) =
    (sem_Pattern_Product (_pos) ((sem_Patterns (_pats))))
sem_Pattern ((Underscore (_pos))) =
    (sem_Pattern_Underscore (_pos))
data Inh_Pattern = Inh_Pattern {con_Inh_Pattern :: Constructor,nt_Inh_Pattern :: Nonterminal}
data Syn_Pattern = Syn_Pattern {containsVars_Syn_Pattern :: Bool,definedAttrs_Syn_Pattern :: Set (Name,Name),errors_Syn_Pattern :: Seq Error,locals_Syn_Pattern :: Set Name,out_Syn_Pattern :: Pattern}
wrap_Pattern :: (T_Pattern) ->
                (Inh_Pattern) ->
                (Syn_Pattern)
wrap_Pattern ((T_Pattern (sem))) ((Inh_Pattern (i1) (i2))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2))
    in  (Syn_Pattern (s1) (s2) (s3) (s4) (s5))
sem_Pattern_Alias :: (Name) ->
                     (Name) ->
                     (T_Pattern) ->
                     (T_Pattern)
sem_Pattern_Alias (field_) (attr_) ((T_Pattern (pat_))) =
    (T_Pattern (\ _lhsIcon
                  _lhsInt ->
                    let _lhsOcontainsVars :: (Bool)
                        _lhsOdefinedAttrs :: (Set (Name,Name))
                        _lhsOerrors :: (Seq Error)
                        _lhsOlocals :: (Set Name)
                        _lhsOout :: (Pattern)
                        _patIcontainsVars :: (Bool)
                        _patIdefinedAttrs :: (Set (Name,Name))
                        _patIerrors :: (Seq Error)
                        _patIlocals :: (Set Name)
                        _patIout :: (Pattern)
                        _patOcon :: (Constructor)
                        _patOnt :: (Nonterminal)
                        ( _patIcontainsVars,_patIdefinedAttrs,_patIerrors,_patIlocals,_patIout) =
                            (pat_ (_patOcon) (_patOnt))
                        -- "DefaultRules.ag"(line 245, column 11)
                        (_lhsOlocals@_) =
                            if field_ == _LOC
                               then Set.insert attr_ _patIlocals
                               else _patIlocals
                        -- "DefaultRules.ag"(line 245, column 11)
                        (_lhsOdefinedAttrs@_) =
                            Set.insert (field_,attr_) _patIdefinedAttrs
                        -- "DefaultRules.ag"(line 263, column 16)
                        (_lhsOcontainsVars@_) =
                            True
                        -- use rule
                        (_lhsOerrors@_) =
                            _patIerrors
                        -- self rule
                        (_out@_) =
                            Alias field_ attr_ _patIout
                        -- self rule
                        (_lhsOout@_) =
                            _out
                        -- copy rule (down)
                        (_patOcon@_) =
                            _lhsIcon
                        -- copy rule (down)
                        (_patOnt@_) =
                            _lhsInt
                    in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
sem_Pattern_Constr :: (Constructor) ->
                      (T_Patterns) ->
                      (T_Pattern)
sem_Pattern_Constr (name_) ((T_Patterns (pats_))) =
    (T_Pattern (\ _lhsIcon
                  _lhsInt ->
                    let _lhsOcontainsVars :: (Bool)
                        _lhsOdefinedAttrs :: (Set (Name,Name))
                        _lhsOerrors :: (Seq Error)
                        _lhsOlocals :: (Set Name)
                        _lhsOout :: (Pattern)
                        _patsIcontainsVars :: (Bool)
                        _patsIdefinedAttrs :: (Set (Name,Name))
                        _patsIerrors :: (Seq Error)
                        _patsIlocals :: (Set Name)
                        _patsIout :: (Patterns)
                        _patsOcon :: (Constructor)
                        _patsOnt :: (Nonterminal)
                        ( _patsIcontainsVars,_patsIdefinedAttrs,_patsIerrors,_patsIlocals,_patsIout) =
                            (pats_ (_patsOcon) (_patsOnt))
                        -- use rule
                        (_lhsOcontainsVars@_) =
                            _patsIcontainsVars
                        -- use rule
                        (_lhsOdefinedAttrs@_) =
                            _patsIdefinedAttrs
                        -- use rule
                        (_lhsOerrors@_) =
                            _patsIerrors
                        -- use rule
                        (_lhsOlocals@_) =
                            _patsIlocals
                        -- self rule
                        (_out@_) =
                            Constr name_ _patsIout
                        -- self rule
                        (_lhsOout@_) =
                            _out
                        -- copy rule (down)
                        (_patsOcon@_) =
                            _lhsIcon
                        -- copy rule (down)
                        (_patsOnt@_) =
                            _lhsInt
                    in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
sem_Pattern_Product :: (Pos) ->
                       (T_Patterns) ->
                       (T_Pattern)
sem_Pattern_Product (pos_) ((T_Patterns (pats_))) =
    (T_Pattern (\ _lhsIcon
                  _lhsInt ->
                    let _lhsOcontainsVars :: (Bool)
                        _lhsOdefinedAttrs :: (Set (Name,Name))
                        _lhsOerrors :: (Seq Error)
                        _lhsOlocals :: (Set Name)
                        _lhsOout :: (Pattern)
                        _patsIcontainsVars :: (Bool)
                        _patsIdefinedAttrs :: (Set (Name,Name))
                        _patsIerrors :: (Seq Error)
                        _patsIlocals :: (Set Name)
                        _patsIout :: (Patterns)
                        _patsOcon :: (Constructor)
                        _patsOnt :: (Nonterminal)
                        ( _patsIcontainsVars,_patsIdefinedAttrs,_patsIerrors,_patsIlocals,_patsIout) =
                            (pats_ (_patsOcon) (_patsOnt))
                        -- use rule
                        (_lhsOcontainsVars@_) =
                            _patsIcontainsVars
                        -- use rule
                        (_lhsOdefinedAttrs@_) =
                            _patsIdefinedAttrs
                        -- use rule
                        (_lhsOerrors@_) =
                            _patsIerrors
                        -- use rule
                        (_lhsOlocals@_) =
                            _patsIlocals
                        -- self rule
                        (_out@_) =
                            Product pos_ _patsIout
                        -- self rule
                        (_lhsOout@_) =
                            _out
                        -- copy rule (down)
                        (_patsOcon@_) =
                            _lhsIcon
                        -- copy rule (down)
                        (_patsOnt@_) =
                            _lhsInt
                    in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
sem_Pattern_Underscore :: (Pos) ->
                          (T_Pattern)
sem_Pattern_Underscore (pos_) =
    (T_Pattern (\ _lhsIcon
                  _lhsInt ->
                    let _lhsOcontainsVars :: (Bool)
                        _lhsOdefinedAttrs :: (Set (Name,Name))
                        _lhsOerrors :: (Seq Error)
                        _lhsOlocals :: (Set Name)
                        _lhsOout :: (Pattern)
                        -- use rule
                        (_lhsOcontainsVars@_) =
                            False
                        -- use rule
                        (_lhsOdefinedAttrs@_) =
                            Set.empty
                        -- use rule
                        (_lhsOerrors@_) =
                            Seq.empty
                        -- use rule
                        (_lhsOlocals@_) =
                            Set.empty
                        -- self rule
                        (_out@_) =
                            Underscore pos_
                        -- self rule
                        (_lhsOout@_) =
                            _out
                    in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
-- Patterns ----------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      nt                   : Nonterminal

   chained attributes:

   synthesised attributes:
      containsVars         : Bool
      definedAttrs         : Set (Name,Name)
      errors               : Seq Error
      locals               : Set Name
      out                  : SELF

-}
{-
   local variables for Patterns.Cons:
      out

-}
{-
   local variables for Patterns.Nil:
      out

-}
-- semantic domain
newtype T_Patterns = T_Patterns ((Constructor) ->
                                 (Nonterminal) ->
                                 ( (Bool),(Set (Name,Name)),(Seq Error),(Set Name),(Patterns)))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
data Inh_Patterns = Inh_Patterns {con_Inh_Patterns :: Constructor,nt_Inh_Patterns :: Nonterminal}
data Syn_Patterns = Syn_Patterns {containsVars_Syn_Patterns :: Bool,definedAttrs_Syn_Patterns :: Set (Name,Name),errors_Syn_Patterns :: Seq Error,locals_Syn_Patterns :: Set Name,out_Syn_Patterns :: Patterns}
wrap_Patterns :: (T_Patterns) ->
                 (Inh_Patterns) ->
                 (Syn_Patterns)
wrap_Patterns ((T_Patterns (sem))) ((Inh_Patterns (i1) (i2))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2))
    in  (Syn_Patterns (s1) (s2) (s3) (s4) (s5))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons ((T_Pattern (hd_))) ((T_Patterns (tl_))) =
    (T_Patterns (\ _lhsIcon
                   _lhsInt ->
                     let _lhsOcontainsVars :: (Bool)
                         _lhsOdefinedAttrs :: (Set (Name,Name))
                         _lhsOerrors :: (Seq Error)
                         _lhsOlocals :: (Set Name)
                         _lhsOout :: (Patterns)
                         _hdIcontainsVars :: (Bool)
                         _hdIdefinedAttrs :: (Set (Name,Name))
                         _hdIerrors :: (Seq Error)
                         _hdIlocals :: (Set Name)
                         _hdIout :: (Pattern)
                         _hdOcon :: (Constructor)
                         _hdOnt :: (Nonterminal)
                         _tlIcontainsVars :: (Bool)
                         _tlIdefinedAttrs :: (Set (Name,Name))
                         _tlIerrors :: (Seq Error)
                         _tlIlocals :: (Set Name)
                         _tlIout :: (Patterns)
                         _tlOcon :: (Constructor)
                         _tlOnt :: (Nonterminal)
                         ( _hdIcontainsVars,_hdIdefinedAttrs,_hdIerrors,_hdIlocals,_hdIout) =
                             (hd_ (_hdOcon) (_hdOnt))
                         ( _tlIcontainsVars,_tlIdefinedAttrs,_tlIerrors,_tlIlocals,_tlIout) =
                             (tl_ (_tlOcon) (_tlOnt))
                         -- use rule
                         (_lhsOcontainsVars@_) =
                             _hdIcontainsVars || _tlIcontainsVars
                         -- use rule
                         (_lhsOdefinedAttrs@_) =
                             _hdIdefinedAttrs `Set.union` _tlIdefinedAttrs
                         -- use rule
                         (_lhsOerrors@_) =
                             _hdIerrors Seq.<> _tlIerrors
                         -- use rule
                         (_lhsOlocals@_) =
                             _hdIlocals `Set.union` _tlIlocals
                         -- self rule
                         (_out@_) =
                             (:) _hdIout _tlIout
                         -- self rule
                         (_lhsOout@_) =
                             _out
                         -- copy rule (down)
                         (_hdOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_hdOnt@_) =
                             _lhsInt
                         -- copy rule (down)
                         (_tlOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_tlOnt@_) =
                             _lhsInt
                     in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil  =
    (T_Patterns (\ _lhsIcon
                   _lhsInt ->
                     let _lhsOcontainsVars :: (Bool)
                         _lhsOdefinedAttrs :: (Set (Name,Name))
                         _lhsOerrors :: (Seq Error)
                         _lhsOlocals :: (Set Name)
                         _lhsOout :: (Patterns)
                         -- use rule
                         (_lhsOcontainsVars@_) =
                             False
                         -- use rule
                         (_lhsOdefinedAttrs@_) =
                             Set.empty
                         -- use rule
                         (_lhsOerrors@_) =
                             Seq.empty
                         -- use rule
                         (_lhsOlocals@_) =
                             Set.empty
                         -- self rule
                         (_out@_) =
                             []
                         -- self rule
                         (_lhsOout@_) =
                             _out
                     in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
-- Production --------------------------------------------------
{-
   inherited attributes:
      cr                   : Bool
      nonterminals         : Set Nonterminal
      o_rename             : Bool
      typeSyns             : TypeSyns
      useMap               : UseMap

   chained attributes:

   synthesised attributes:
      collect_nts          : Set Nonterminal
      errors               : Seq Error
      out                  : SELF

-}
{-
   local variables for Production.Production:
      out

-}
-- semantic domain
newtype T_Production = T_Production ((Bool) ->
                                     (Set Nonterminal) ->
                                     (Bool) ->
                                     (TypeSyns) ->
                                     (UseMap) ->
                                     ( (Set Nonterminal),(Seq Error),(Production)))
-- cata
sem_Production :: (Production) ->
                  (T_Production)
sem_Production ((Production (_nt) (_inh) (_syn) (_alts))) =
    (sem_Production_Production (_nt) (_inh) (_syn) ((sem_Alternatives (_alts))))
data Inh_Production = Inh_Production {cr_Inh_Production :: Bool,nonterminals_Inh_Production :: Set Nonterminal,o_rename_Inh_Production :: Bool,typeSyns_Inh_Production :: TypeSyns,useMap_Inh_Production :: UseMap}
data Syn_Production = Syn_Production {collect_nts_Syn_Production :: Set Nonterminal,errors_Syn_Production :: Seq Error,out_Syn_Production :: Production}
wrap_Production :: (T_Production) ->
                   (Inh_Production) ->
                   (Syn_Production)
wrap_Production ((T_Production (sem))) ((Inh_Production (i1) (i2) (i3) (i4) (i5))) =
    let ( s1,s2,s3) =
            (sem (i1) (i2) (i3) (i4) (i5))
    in  (Syn_Production (s1) (s2) (s3))
sem_Production_Production :: (Nonterminal) ->
                             (Attributes) ->
                             (Attributes) ->
                             (T_Alternatives) ->
                             (T_Production)
sem_Production_Production (nt_) (inh_) (syn_) ((T_Alternatives (alts_))) =
    (T_Production (\ _lhsIcr
                     _lhsInonterminals
                     _lhsIo_rename
                     _lhsItypeSyns
                     _lhsIuseMap ->
                       let _lhsOcollect_nts :: (Set Nonterminal)
                           _lhsOerrors :: (Seq Error)
                           _lhsOout :: (Production)
                           _altsIerrors :: (Seq Error)
                           _altsIout :: (Alternatives)
                           _altsOcr :: (Bool)
                           _altsOinh :: (Attributes)
                           _altsOnonterminals :: (Set Nonterminal)
                           _altsOnt :: (Nonterminal)
                           _altsOo_rename :: (Bool)
                           _altsOsyn :: (Attributes)
                           _altsOtypeSyns :: (TypeSyns)
                           _altsOuseMap :: (Map Name (String,String))
                           ( _altsIerrors,_altsIout) =
                               (alts_ (_altsOcr) (_altsOinh) (_altsOnonterminals) (_altsOnt) (_altsOo_rename) (_altsOsyn) (_altsOtypeSyns) (_altsOuseMap))
                           -- "DefaultRules.ag"(line 94, column 16)
                           (_lhsOcollect_nts@_) =
                               Set.single nt_
                           -- "DefaultRules.ag"(line 111, column 17)
                           (_altsOuseMap@_) =
                               Map.findWithDefault Map.empty nt_ _lhsIuseMap
                           -- "DefaultRules.ag"(line 110, column 17)
                           (_altsOsyn@_) =
                               syn_
                           -- "DefaultRules.ag"(line 109, column 17)
                           (_altsOinh@_) =
                               inh_
                           -- "DefaultRules.ag"(line 126, column 16)
                           (_altsOnt@_) =
                               nt_
                           -- use rule
                           (_lhsOerrors@_) =
                               _altsIerrors
                           -- self rule
                           (_out@_) =
                               Production nt_ inh_ syn_ _altsIout
                           -- self rule
                           (_lhsOout@_) =
                               _out
                           -- copy rule (down)
                           (_altsOcr@_) =
                               _lhsIcr
                           -- copy rule (down)
                           (_altsOnonterminals@_) =
                               _lhsInonterminals
                           -- copy rule (down)
                           (_altsOo_rename@_) =
                               _lhsIo_rename
                           -- copy rule (down)
                           (_altsOtypeSyns@_) =
                               _lhsItypeSyns
                       in  ( _lhsOcollect_nts,_lhsOerrors,_lhsOout)))
-- Productions -------------------------------------------------
{-
   inherited attributes:
      cr                   : Bool
      nonterminals         : Set Nonterminal
      o_rename             : Bool
      typeSyns             : TypeSyns
      useMap               : UseMap

   chained attributes:

   synthesised attributes:
      collect_nts          : Set Nonterminal
      errors               : Seq Error
      out                  : SELF

-}
{-
   local variables for Productions.Cons:
      out

-}
{-
   local variables for Productions.Nil:
      out

-}
-- semantic domain
newtype T_Productions = T_Productions ((Bool) ->
                                       (Set Nonterminal) ->
                                       (Bool) ->
                                       (TypeSyns) ->
                                       (UseMap) ->
                                       ( (Set Nonterminal),(Seq Error),(Productions)))
-- cata
sem_Productions :: (Productions) ->
                   (T_Productions)
sem_Productions (list) =
    (foldr (sem_Productions_Cons) (sem_Productions_Nil) ((map sem_Production list)))
data Inh_Productions = Inh_Productions {cr_Inh_Productions :: Bool,nonterminals_Inh_Productions :: Set Nonterminal,o_rename_Inh_Productions :: Bool,typeSyns_Inh_Productions :: TypeSyns,useMap_Inh_Productions :: UseMap}
data Syn_Productions = Syn_Productions {collect_nts_Syn_Productions :: Set Nonterminal,errors_Syn_Productions :: Seq Error,out_Syn_Productions :: Productions}
wrap_Productions :: (T_Productions) ->
                    (Inh_Productions) ->
                    (Syn_Productions)
wrap_Productions ((T_Productions (sem))) ((Inh_Productions (i1) (i2) (i3) (i4) (i5))) =
    let ( s1,s2,s3) =
            (sem (i1) (i2) (i3) (i4) (i5))
    in  (Syn_Productions (s1) (s2) (s3))
sem_Productions_Cons :: (T_Production) ->
                        (T_Productions) ->
                        (T_Productions)
sem_Productions_Cons ((T_Production (hd_))) ((T_Productions (tl_))) =
    (T_Productions (\ _lhsIcr
                      _lhsInonterminals
                      _lhsIo_rename
                      _lhsItypeSyns
                      _lhsIuseMap ->
                        let _lhsOcollect_nts :: (Set Nonterminal)
                            _lhsOerrors :: (Seq Error)
                            _lhsOout :: (Productions)
                            _hdIcollect_nts :: (Set Nonterminal)
                            _hdIerrors :: (Seq Error)
                            _hdIout :: (Production)
                            _hdOcr :: (Bool)
                            _hdOnonterminals :: (Set Nonterminal)
                            _hdOo_rename :: (Bool)
                            _hdOtypeSyns :: (TypeSyns)
                            _hdOuseMap :: (UseMap)
                            _tlIcollect_nts :: (Set Nonterminal)
                            _tlIerrors :: (Seq Error)
                            _tlIout :: (Productions)
                            _tlOcr :: (Bool)
                            _tlOnonterminals :: (Set Nonterminal)
                            _tlOo_rename :: (Bool)
                            _tlOtypeSyns :: (TypeSyns)
                            _tlOuseMap :: (UseMap)
                            ( _hdIcollect_nts,_hdIerrors,_hdIout) =
                                (hd_ (_hdOcr) (_hdOnonterminals) (_hdOo_rename) (_hdOtypeSyns) (_hdOuseMap))
                            ( _tlIcollect_nts,_tlIerrors,_tlIout) =
                                (tl_ (_tlOcr) (_tlOnonterminals) (_tlOo_rename) (_tlOtypeSyns) (_tlOuseMap))
                            -- use rule
                            (_lhsOcollect_nts@_) =
                                _hdIcollect_nts `Set.union` _tlIcollect_nts
                            -- use rule
                            (_lhsOerrors@_) =
                                _hdIerrors Seq.<> _tlIerrors
                            -- self rule
                            (_out@_) =
                                (:) _hdIout _tlIout
                            -- self rule
                            (_lhsOout@_) =
                                _out
                            -- copy rule (down)
                            (_hdOcr@_) =
                                _lhsIcr
                            -- copy rule (down)
                            (_hdOnonterminals@_) =
                                _lhsInonterminals
                            -- copy rule (down)
                            (_hdOo_rename@_) =
                                _lhsIo_rename
                            -- copy rule (down)
                            (_hdOtypeSyns@_) =
                                _lhsItypeSyns
                            -- copy rule (down)
                            (_hdOuseMap@_) =
                                _lhsIuseMap
                            -- copy rule (down)
                            (_tlOcr@_) =
                                _lhsIcr
                            -- copy rule (down)
                            (_tlOnonterminals@_) =
                                _lhsInonterminals
                            -- copy rule (down)
                            (_tlOo_rename@_) =
                                _lhsIo_rename
                            -- copy rule (down)
                            (_tlOtypeSyns@_) =
                                _lhsItypeSyns
                            -- copy rule (down)
                            (_tlOuseMap@_) =
                                _lhsIuseMap
                        in  ( _lhsOcollect_nts,_lhsOerrors,_lhsOout)))
sem_Productions_Nil :: (T_Productions)
sem_Productions_Nil  =
    (T_Productions (\ _lhsIcr
                      _lhsInonterminals
                      _lhsIo_rename
                      _lhsItypeSyns
                      _lhsIuseMap ->
                        let _lhsOcollect_nts :: (Set Nonterminal)
                            _lhsOerrors :: (Seq Error)
                            _lhsOout :: (Productions)
                            -- use rule
                            (_lhsOcollect_nts@_) =
                                Set.empty
                            -- use rule
                            (_lhsOerrors@_) =
                                Seq.empty
                            -- self rule
                            (_out@_) =
                                []
                            -- self rule
                            (_lhsOout@_) =
                                _out
                        in  ( _lhsOcollect_nts,_lhsOerrors,_lhsOout)))
-- Rule --------------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      nt                   : Nonterminal

   chained attributes:

   synthesised attributes:
      containsVars         : Bool
      definedAttrs         : Set (Name,Name)
      errors               : Seq Error
      locals               : Set Name
      out                  : SELF

-}
{-
   local variables for Rule.Rule:
      out

-}
-- semantic domain
newtype T_Rule = T_Rule ((Constructor) ->
                         (Nonterminal) ->
                         ( (Bool),(Set (Name,Name)),(Seq Error),(Set Name),(Rule)))
-- cata
sem_Rule :: (Rule) ->
            (T_Rule)
sem_Rule ((Rule (_pattern) (_rhs) (_owrt) (_origin))) =
    (sem_Rule_Rule ((sem_Pattern (_pattern))) (_rhs) (_owrt) (_origin))
data Inh_Rule = Inh_Rule {con_Inh_Rule :: Constructor,nt_Inh_Rule :: Nonterminal}
data Syn_Rule = Syn_Rule {containsVars_Syn_Rule :: Bool,definedAttrs_Syn_Rule :: Set (Name,Name),errors_Syn_Rule :: Seq Error,locals_Syn_Rule :: Set Name,out_Syn_Rule :: Rule}
wrap_Rule :: (T_Rule) ->
             (Inh_Rule) ->
             (Syn_Rule)
wrap_Rule ((T_Rule (sem))) ((Inh_Rule (i1) (i2))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2))
    in  (Syn_Rule (s1) (s2) (s3) (s4) (s5))
sem_Rule_Rule :: (T_Pattern) ->
                 (Expression) ->
                 (Bool) ->
                 (String) ->
                 (T_Rule)
sem_Rule_Rule ((T_Pattern (pattern_))) (rhs_) (owrt_) (origin_) =
    (T_Rule (\ _lhsIcon
               _lhsInt ->
                 let _lhsOcontainsVars :: (Bool)
                     _lhsOdefinedAttrs :: (Set (Name,Name))
                     _lhsOerrors :: (Seq Error)
                     _lhsOlocals :: (Set Name)
                     _lhsOout :: (Rule)
                     _patternIcontainsVars :: (Bool)
                     _patternIdefinedAttrs :: (Set (Name,Name))
                     _patternIerrors :: (Seq Error)
                     _patternIlocals :: (Set Name)
                     _patternIout :: (Pattern)
                     _patternOcon :: (Constructor)
                     _patternOnt :: (Nonterminal)
                     ( _patternIcontainsVars,_patternIdefinedAttrs,_patternIerrors,_patternIlocals,_patternIout) =
                         (pattern_ (_patternOcon) (_patternOnt))
                     -- use rule
                     (_lhsOcontainsVars@_) =
                         _patternIcontainsVars
                     -- use rule
                     (_lhsOdefinedAttrs@_) =
                         _patternIdefinedAttrs
                     -- use rule
                     (_lhsOerrors@_) =
                         _patternIerrors
                     -- use rule
                     (_lhsOlocals@_) =
                         _patternIlocals
                     -- self rule
                     (_out@_) =
                         Rule _patternIout rhs_ owrt_ origin_
                     -- self rule
                     (_lhsOout@_) =
                         _out
                     -- copy rule (down)
                     (_patternOcon@_) =
                         _lhsIcon
                     -- copy rule (down)
                     (_patternOnt@_) =
                         _lhsInt
                 in  ( _lhsOcontainsVars,_lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
-- Rules -------------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      nt                   : Nonterminal

   chained attributes:

   synthesised attributes:
      definedAttrs         : Set (Name,Name)
      errors               : Seq Error
      locals               : Set Name
      out                  : SELF

-}
{-
   local variables for Rules.Cons:
      out

-}
{-
   local variables for Rules.Nil:
      out

-}
-- semantic domain
newtype T_Rules = T_Rules ((Constructor) ->
                           (Nonterminal) ->
                           ( (Set (Name,Name)),(Seq Error),(Set Name),(Rules)))
-- cata
sem_Rules :: (Rules) ->
             (T_Rules)
sem_Rules (list) =
    (foldr (sem_Rules_Cons) (sem_Rules_Nil) ((map sem_Rule list)))
data Inh_Rules = Inh_Rules {con_Inh_Rules :: Constructor,nt_Inh_Rules :: Nonterminal}
data Syn_Rules = Syn_Rules {definedAttrs_Syn_Rules :: Set (Name,Name),errors_Syn_Rules :: Seq Error,locals_Syn_Rules :: Set Name,out_Syn_Rules :: Rules}
wrap_Rules :: (T_Rules) ->
              (Inh_Rules) ->
              (Syn_Rules)
wrap_Rules ((T_Rules (sem))) ((Inh_Rules (i1) (i2))) =
    let ( s1,s2,s3,s4) =
            (sem (i1) (i2))
    in  (Syn_Rules (s1) (s2) (s3) (s4))
sem_Rules_Cons :: (T_Rule) ->
                  (T_Rules) ->
                  (T_Rules)
sem_Rules_Cons ((T_Rule (hd_))) ((T_Rules (tl_))) =
    (T_Rules (\ _lhsIcon
                _lhsInt ->
                  let _lhsOdefinedAttrs :: (Set (Name,Name))
                      _lhsOerrors :: (Seq Error)
                      _lhsOlocals :: (Set Name)
                      _lhsOout :: (Rules)
                      _hdIcontainsVars :: (Bool)
                      _hdIdefinedAttrs :: (Set (Name,Name))
                      _hdIerrors :: (Seq Error)
                      _hdIlocals :: (Set Name)
                      _hdIout :: (Rule)
                      _hdOcon :: (Constructor)
                      _hdOnt :: (Nonterminal)
                      _tlIdefinedAttrs :: (Set (Name,Name))
                      _tlIerrors :: (Seq Error)
                      _tlIlocals :: (Set Name)
                      _tlIout :: (Rules)
                      _tlOcon :: (Constructor)
                      _tlOnt :: (Nonterminal)
                      ( _hdIcontainsVars,_hdIdefinedAttrs,_hdIerrors,_hdIlocals,_hdIout) =
                          (hd_ (_hdOcon) (_hdOnt))
                      ( _tlIdefinedAttrs,_tlIerrors,_tlIlocals,_tlIout) =
                          (tl_ (_tlOcon) (_tlOnt))
                      -- "DefaultRules.ag"(line 279, column 10)
                      (_lhsOout@_) =
                          if _hdIcontainsVars then _out else _tlIout
                      -- use rule
                      (_lhsOdefinedAttrs@_) =
                          _hdIdefinedAttrs `Set.union` _tlIdefinedAttrs
                      -- use rule
                      (_lhsOerrors@_) =
                          _hdIerrors Seq.<> _tlIerrors
                      -- use rule
                      (_lhsOlocals@_) =
                          _hdIlocals `Set.union` _tlIlocals
                      -- self rule
                      (_out@_) =
                          (:) _hdIout _tlIout
                      -- copy rule (down)
                      (_hdOcon@_) =
                          _lhsIcon
                      -- copy rule (down)
                      (_hdOnt@_) =
                          _lhsInt
                      -- copy rule (down)
                      (_tlOcon@_) =
                          _lhsIcon
                      -- copy rule (down)
                      (_tlOnt@_) =
                          _lhsInt
                  in  ( _lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))
sem_Rules_Nil :: (T_Rules)
sem_Rules_Nil  =
    (T_Rules (\ _lhsIcon
                _lhsInt ->
                  let _lhsOdefinedAttrs :: (Set (Name,Name))
                      _lhsOerrors :: (Seq Error)
                      _lhsOlocals :: (Set Name)
                      _lhsOout :: (Rules)
                      -- use rule
                      (_lhsOdefinedAttrs@_) =
                          Set.empty
                      -- use rule
                      (_lhsOerrors@_) =
                          Seq.empty
                      -- use rule
                      (_lhsOlocals@_) =
                          Set.empty
                      -- self rule
                      (_out@_) =
                          []
                      -- self rule
                      (_lhsOout@_) =
                          _out
                  in  ( _lhsOdefinedAttrs,_lhsOerrors,_lhsOlocals,_lhsOout)))


