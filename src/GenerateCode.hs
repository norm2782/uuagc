-- do not edit; automatically generated by UU.AG
module GenerateCode where

import CommonTypes
import Patterns
import ErrorMessages
import AbstractSyntax
import Code hiding (Type)
import qualified Code
import qualified UU.DData.Map as Map
import qualified UU.DData.Seq as Seq
import qualified UU.DData.Set as Set
import UU.DData.Map(Map) 
import UU.DData.Set(Set) 
import UU.DData.Seq(Seq, (<>)) 
import Maybe
import UU.Pretty
import UU.Util.Utils
import Expression
import Options

import CommonTypes
import UU.Pretty
import Patterns
import Expression
import UU.DData.Set(Set)

import List  (intersect, (\\))
import qualified UU.DData.Map as Map(toList) 

import UU.Scanner.Position(Pos)
import CommonTypes

import UU.Pretty.Basic(PP_Doc)

import Expression
import HsTokenScanner(lexTokens)
import SemHsTokens(sem_HsTokensRoot,wrap_HsTokensRoot, Syn_HsTokensRoot(..),Inh_HsTokensRoot(..))
import ErrorMessages
import UU.Scanner.Position
import CommonTypes
import HsToken
import UU.DData.Seq(Seq)

import UU.Scanner.Position(Pos)

import Options
import Streaming
import qualified UU.DData.Map as Map
import List(partition,transpose)
import CommonTypes(_LHS)
import DepTypes

import List(nub)
import Char

{- de definitieve versie -}
getResult :: [[(Vertex,Result)]] -> Seq Error
getResult (res:rest) = if and (map (\(v,(set,upd)) -> null upd) res)
                       then checkCircular res
                       else getResult rest
getResult [] = Seq.empty


-- volgorde van belang: eerst de inh aflopen, dat zijn er minder!!
checkCircular :: [(Vertex,Result)] -> Seq Error
checkCircular res = Seq.fromList $  
                     concat [ [ CircGrammar
                                nt1
                                attr1
                                (fromJust (lookup attr2 (map toPair set1)))
                                attr2
                                (fromJust (lookup attr1 (map toPair set2)))
                             | (NTSyn  nt2 attr2,(set2,upd2))<-res
                             , nt1==nt2
                             , attr1 `elem` (map getAttr set2)
                             , attr2 `elem` (map getAttr set1)]
                           | (NTInh nt1 attr1,(set1,upd1))<-res
                           ]



-- de vertex is die die aangemaakt wordt door de productie
-- 1 allereerst worden de useStreams geselecteerd die met deze knoop verbonden dienen te worden
-- 2 daarna worden hier alle resultaten gefilterd die met de lhs nonterminal verbonden zijn
--   want we zijn alleen geïnteresseerd in hoe de inh (syn) attributen van de syn (inh) attributen van een nonterminal afhangen
-- 3 de field informatie is nu niet meer nodig en wordt eruit gegooid door van een lokaal resultaat een globaal resultaat te maken
prod2stream :: Vertex -> [UseStream] -> Stream
prod2stream (NTSyn nt at) streams = foldr stUnion stEmpty (map (stLocal2global . stFilterInclSide) . filter p $ streams) where
 p ((LHSSyn nont con attr),_) = nont==nt && attr==at
 p _                           = False
prod2stream (NTInh nt at) streams = foldr stUnion stEmpty (map (stLocal2global . stFilterInclSide) . filter p $ streams) where
 p ((RHSInh  rhs lhs con fld attr),_) = rhs==nt && attr==at
 p _                                  = False
prod2stream _ _ = stEmpty

ports2stream :: Vertex -> [Vertex] -> [UseStream] -> Stream
ports2stream vport vertices useStreams = foldr stUnion stEmpty stPorts where
 stPorts = [ stPort
              (getAttr vertex)
              (getStream vport useStreams)
              (getStream vertex useStreams)
           | vertex<-vertices
           ]

getNonterminalName (NT nt) = nt
getNonterminalName _       = nullIdent

child_syn2stream :: Vertex -> [Vertex] -> [UseStream] -> Stream
child_syn2stream vport vins useStreams = foldr stUnion stEmpty stPorts where
 stPorts = [ stPort
              (getAttr vin)
              (getStream vport useStreams)
              (getStream vin useStreams)
           | vin<-vins
           ]

smsdtype :: Nonterminal -> String -> String
smsdtype tp post = "T_sm_" ++ getName tp ++ "_" ++ post

smsdtype2 :: Nonterminal -> Constructor -> String -> String
smsdtype2 tp con post = "T_sm_" ++ getName tp ++ getName con ++ "_" ++ post

smcataname ::  String -> Nonterminal -> String
smcataname pre name = cataname ("sm" ++ pre) name

smpcataname ::  String -> Nonterminal -> Constructor -> String
smpcataname pre nt con = smsemname ('p':pre) nt con

smsemname  ::  String -> Nonterminal -> Constructor -> String
smsemname pre nt con = semname ("sm"++pre) nt con

smcompname :: String -> Nonterminal -> Constructor -> String
smcompname pre nt con = pre ++ "_" ++ getName nt ++ "_" ++ getName con ++ "f"

mktuppat :: [String] -> String
mktuppat args = '(' : (foldl1 (\l r -> l ++ ", " ++ r) args) ++ ")"

tupnest       = foldr (\l r -> TupleExpr [l,r]) (SimpleExpr unit)
tupnest'  es  = if null es then TupleExpr [SimpleExpr unit]
                           else foldr1 (\l r -> TupleExpr [l,r]) es
tupnestTp     = foldr (\l r -> TupleType [l,r]) (SimpleType unit)
tupnestTp' es = if null es then TupleType [SimpleType unit]
                           else foldr1 (\l r -> TupleType [l,r]) es

smattrcompnamein :: String -> Nonterminal -> Constructor -> Name -> Name ->String
smattrcompnamein pre nt con attr name = (smcompname pre nt con) ++ "_" ++ getName attr ++ getName name ++ "in"

smattrcompnameout :: String -> Nonterminal -> Constructor -> Name -> String
smattrcompnameout pre nt con attr = (smcompname pre nt con) ++ "_" ++ getName attr ++ "out"

smattrcompnameloc :: String -> Nonterminal -> Constructor -> Name ->String
smattrcompnameloc pre nt con attr = (smcompname pre nt con) ++ "_" ++ getName attr ++ "loc"

fknit :: String
fknit = "knit"

unit :: String
unit = "()"

unittp :: String
unittp = "UnitSMTP"

underscore :: String
underscore = "_"

tup :: String
tup = "(,)"

lazytilde :: String
lazytilde = "~"

mk_def_name n i = "def_" ++ (show n) ++ "_" ++ (show i)

mk_def_nm_decls n = map (mk_def_nm_decl n) [1..n]
mk_def_nm_decl n i = let lhs = Fun (mk_def_name n i) [f, inppat]
                         f   = SimpleExpr "f"
                         l   = SimpleExpr "l"
                         p   = SimpleExpr "p"
                         chpatelems = (map ((++) "ch" . show) [1..n])
                         chpat = tupnest' (map SimpleExpr chpatelems)
                         inppat = TupleExpr [ chpat
                                            , l
                                            , p ]
                         rhs = TupleExpr [ tupnest' chpat'
                                         , l
                                         , p ]
                         chpat' = map (\e -> if e == ("ch" ++ show i)
                                             then App "f" [SimpleExpr e]
                                             else SimpleExpr e)
                                      chpatelems
                     in  Decl lhs rhs

syn_def :: String
syn_def = "syndef"

loc_def :: String
loc_def = "locdef"

extname :: String
extname = "ext"

selectnm :: Nonterminal -> Constructor -> Name -> String
selectnm nt con s = "select_" ++ getName nt ++ "_" ++ getName con ++ "_" ++ getName s

insertnm :: Nonterminal -> Constructor -> Name -> String
insertnm nt con s = "insert_" ++ getName nt ++ "_" ++ getName con ++ "_" ++ getName s

insertinhnm :: Nonterminal -> Constructor -> Name -> Name -> String
insertinhnm nt con nm s = "insert_" ++ getName nt ++ "_" ++ getName con ++ "_" ++ getName nm ++ "_" ++  getName s

mkExtendExpr fnnm defnm insertnm = let extend = "_extend_"
                                       origcomp = "_origcomp_"
                                       newcomp = "_newcomp_"
                                       compinp = "_compinput_"
                                       extendExpr = Lambda [compinp] (App defnm [insertExpr])
                                       insertExpr = App insertnm [App newcomp [SimpleExpr compinp]]
                                       lhs = Fun fnnm [SimpleExpr newcomp, SimpleExpr origcomp]
                                       rhs = Lambda [unit] (App extname [extendExpr, App origcomp [SimpleExpr unit]])
                                   in Decl lhs rhs
makesemnm :: Nonterminal -> Constructor -> String
makesemnm nt con = "make_sem_" ++ getName nt ++ "_" ++ getName con

showAsList = printList "[]" "[" "]" ", "

printList e o c s xs = case xs of
  []     -> [e]
  (x:xs) -> (o ++ x) : map (s ++) xs  ++ [c]

spindent n = map (sp++) where
 sp = replicate n ' '

mkDynValList nm vals = (nm ++ " =")
                       : spindent 4 (showAsList (map datatype vals)) where
 datatype (fident,(fnm,args)) = let args' = map (\v -> "tp_" ++ v) args
                                    arr a b = a ++ " .->. " ++ b
                                in  "(" ++ show fident ++ ", Id " ++ fnm ++ " ::: " ++ foldr1 arr args' ++ ")"

mkDynValList' nm vals = (nm ++ " =")
                       : spindent 4 (showAsList (map datatype vals)) where
 datatype (fident,(fnm,tp)) = "(" ++ show fident ++ ", Id " ++ fnm ++ " ::: " ++ (tpToDyn tp) ++ ")"

tpToDyn (SimpleType tp) = "tp_" ++ tp
tpToDyn (Arr tp1 tp2)   = "(" ++ (tpToDyn tp1) ++ " .->. " ++ (tpToDyn tp2) ++ ")"
tpToDyn _ = error "There may only be simple and arr types when converting to dyn."

mkDynValListExt nm vals = (nm ++ " =")
                       : spindent 4 (showAsList (map datatype vals)) where
 datatype (fident,(ftp,fnm,args)) = let args' = map (\v -> "tp_" ++ v) args
                                        arr a b = a ++ " .->. " ++ b
                                    in  "(" ++ show fident ++ ",( " ++ show ftp ++ ", Id " ++ fnm ++ " ::: " ++ foldr1 arr args' ++ "))"
mkExistList nm vals = (nm ++ " =")
                       : spindent 4 (showAsList (map datatype vals)) where
 datatype (fident,(fnm,ftp)) = "(" ++ show fident 
                                ++ ", (" ++ show fnm
                                ++ ", E " ++ "tp_" ++ ftp ++ "))" 

locname' n = "_loc_" ++ getName n
-- Alternative -------------------------------------------------
{-
   inherited attributes:
      down                 : [UseStream]
      inh                  : Attributes
      nt                   : Identifier
      nts'                 : [Name]
      o_cata               : Bool
      o_newtypes           : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      prefix               : String
      syn                  : Attributes

   chained attributes:

   synthesised attributes:
      cataAlt              : Decl
      comment              : Decl
      dataAlt              : DataAlt
      errors               : Seq Error
      nrChildren           : Int
      semFun               : Decls
      smCataAlt            : Decl
      smCompDyn            : (String,(String,[String]))
      smConstructor        : (String,(String,[String]))
      smDynSels            : [(String,(String,String,[String]))]
      smDynSemFuns         : [(String,(String,[String]))]
      smInputDyn           : (String,(String,String))
      smInsDyns            : [(String,(String,Code.Type))]
      smPrimTypes          : [String]
      smSelFun             : Decls
      smSemFun             : Decls
      smTypeCons           : [String]
      up                   : [UseStream]

-}
{-
   local variables for Alternative.Alternative:
      sFun
      synnames
      inhnames
      attrs
      fieldnames
      up
      smTpSigs
      smCompTpSig
      smComputation
      dynSemFun
      mkSemFun
      smpCataAlt
      synInsDyns
      synInserters
      smInhSelDyns
      inhSelectors
      smChSelDyns
      childSelectors

-}
-- semantic domain
newtype T_Alternative = T_Alternative (([UseStream]) ->
                                       (Attributes) ->
                                       (Identifier) ->
                                       ([Name]) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (String) ->
                                       (Attributes) ->
                                       ( (Decl),(Decl),(DataAlt),(Seq Error),(Int),(Decls),(Decl),((String,(String,[String]))),((String,(String,[String]))),([(String,(String,String,[String]))]),([(String,(String,[String]))]),((String,(String,String))),([(String,(String,Code.Type))]),([String]),(Decls),(Decls),([String]),([UseStream])))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative (_con) (_children) (_rules))) =
    (sem_Alternative_Alternative (_con) ((sem_Children (_children))) ((sem_Rules (_rules))))
data Inh_Alternative = Inh_Alternative {down_Inh_Alternative :: [UseStream],inh_Inh_Alternative :: Attributes,nt_Inh_Alternative :: Identifier,nts'_Inh_Alternative :: [Name],o_cata_Inh_Alternative :: Bool,o_newtypes_Inh_Alternative :: Bool,o_pretty_Inh_Alternative :: Bool,o_rename_Inh_Alternative :: Bool,o_sem_Inh_Alternative :: Bool,o_sig_Inh_Alternative :: Bool,prefix_Inh_Alternative :: String,syn_Inh_Alternative :: Attributes}
data Syn_Alternative = Syn_Alternative {cataAlt_Syn_Alternative :: Decl
                                       ,comment_Syn_Alternative :: Decl
                                       ,dataAlt_Syn_Alternative :: DataAlt
                                       ,errors_Syn_Alternative :: Seq Error
                                       ,nrChildren_Syn_Alternative :: Int
                                       ,semFun_Syn_Alternative :: Decls
                                       ,smCataAlt_Syn_Alternative :: Decl
                                       ,smCompDyn_Syn_Alternative :: (String,(String,[String]))
                                       ,smConstructor_Syn_Alternative :: (String,(String,[String]))
                                       ,smDynSels_Syn_Alternative :: [(String,(String,String,[String]))]
                                       ,smDynSemFuns_Syn_Alternative :: [(String,(String,[String]))]
                                       ,smInputDyn_Syn_Alternative :: (String,(String,String))
                                       ,smInsDyns_Syn_Alternative :: [(String,(String,Code.Type))]
                                       ,smPrimTypes_Syn_Alternative :: [String]
                                       ,smSelFun_Syn_Alternative :: Decls
                                       ,smSemFun_Syn_Alternative :: Decls
                                       ,smTypeCons_Syn_Alternative :: [String]
                                       ,up_Syn_Alternative :: [UseStream]
                                       }
wrap_Alternative :: (T_Alternative) ->
                    (Inh_Alternative) ->
                    (Syn_Alternative)
wrap_Alternative ((T_Alternative (sem))) ((Inh_Alternative (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12))) =
    let ( s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12))
    in  (Syn_Alternative (s1) (s2) (s3) (s4) (s5) (s6) (s7) (s8) (s9) (s10) (s11) (s12) (s13) (s14) (s15) (s16) (s17) (s18))
sem_Alternative_Alternative :: (Constructor) ->
                               (T_Children) ->
                               (T_Rules) ->
                               (T_Alternative)
sem_Alternative_Alternative (con_) ((T_Children (children_))) ((T_Rules (rules_))) =
    (T_Alternative (\ _lhsIdown
                      _lhsIinh
                      _lhsInt
                      _lhsInts'
                      _lhsIo_cata
                      _lhsIo_newtypes
                      _lhsIo_pretty
                      _lhsIo_rename
                      _lhsIo_sem
                      _lhsIo_sig
                      _lhsIprefix
                      _lhsIsyn ->
                        let _lhsOcataAlt :: (Decl)
                            _lhsOcomment :: (Decl)
                            _lhsOdataAlt :: (DataAlt)
                            _lhsOerrors :: (Seq Error)
                            _lhsOnrChildren :: (Int)
                            _lhsOsemFun :: (Decls)
                            _lhsOsmCataAlt :: (Decl)
                            _lhsOsmCompDyn :: ((String,(String,[String])))
                            _lhsOsmConstructor :: ((String,(String,[String])))
                            _lhsOsmDynSels :: ([(String,(String,String,[String]))])
                            _lhsOsmDynSemFuns :: ([(String,(String,[String]))])
                            _lhsOsmInputDyn :: ((String,(String,String)))
                            _lhsOsmInsDyns :: ([(String,(String,Code.Type))])
                            _lhsOsmPrimTypes :: ([String])
                            _lhsOsmSelFun :: (Decls)
                            _lhsOsmSemFun :: (Decls)
                            _lhsOsmTypeCons :: ([String])
                            _lhsOup :: ([UseStream])
                            _childrenIattributes :: ([(Name,Attributes,Attributes)])
                            _childrenIdecls :: (Decls)
                            _childrenIerrors :: (Seq Error)
                            _childrenIfields :: ([(Name,Type)])
                            _childrenIsmInhAttrNames :: ([[String]])
                            _childrenIsmInhFnames :: ([String])
                            _childrenIsmInhInsDyns :: ([(String,(String,Code.Type))])
                            _childrenIsmInhInserters :: (Decls)
                            _childrenIsmSynAttrNames :: ([[String]])
                            _childrenIup :: ([UseStream])
                            _childrenOattrs :: ([(Name,Name)])
                            _childrenOcon :: (Identifier)
                            _childrenOdef_namespace :: ([(Name,(Int, Int))])
                            _childrenOdown :: ([UseStream])
                            _childrenOfieldnames :: ([Name])
                            _childrenOinh :: (Attributes)
                            _childrenOnt :: (Identifier)
                            _childrenOnts' :: ([Name])
                            _childrenOo_rename :: (Bool)
                            _childrenOprefix :: (String)
                            _rulesIdecls :: (Decls)
                            _rulesIdecls' :: (Decls)
                            _rulesIerrors :: (Seq Error)
                            _rulesIlocVars :: ([Name])
                            _rulesIup :: ([UseStream])
                            _rulesOattrs :: ([(Name,Name)])
                            _rulesOcon :: (Identifier)
                            _rulesOdown :: ([UseStream])
                            _rulesOfieldnames :: ([Name])
                            _rulesOfields :: ([(Name,Type)])
                            _rulesOnt :: (Identifier)
                            _rulesOo_pretty :: (Bool)
                            ( _childrenIattributes,_childrenIdecls,_childrenIerrors,_childrenIfields,_childrenIsmInhAttrNames,_childrenIsmInhFnames,_childrenIsmInhInsDyns,_childrenIsmInhInserters,_childrenIsmSynAttrNames,_childrenIup) =
                                (children_ (_childrenOattrs) (_childrenOcon) (_childrenOdef_namespace) (_childrenOdown) (_childrenOfieldnames) (_childrenOinh) (_childrenOnt) (_childrenOnts') (_childrenOo_rename) (_childrenOprefix))
                            ( _rulesIdecls,_rulesIdecls',_rulesIerrors,_rulesIlocVars,_rulesIup) =
                                (rules_ (_rulesOattrs) (_rulesOcon) (_rulesOdown) (_rulesOfieldnames) (_rulesOfields) (_rulesOnt) (_rulesOo_pretty))
                            -- "GenerateCode.ag"(line 54, column 17)
                            (_childrenOcon@_) =
                                con_
                            -- "GenerateCode.ag"(line 56, column 17)
                            (_rulesOcon@_) =
                                con_
                            -- "GenerateCode.ag"(line 227, column 17)
                            (_lhsOdataAlt@_) =
                                DataAlt (conname _lhsIo_rename _lhsInt con_) (map (typeToString _lhsInt .snd) _childrenIfields)
                            -- "GenerateCode.ag"(line 250, column 17)
                            (_lhsOcataAlt@_) =
                                let lhs = Fun (cataname _lhsIprefix _lhsInt) [lhs_pat]
                                    lhs_pat = App (conname _lhsIo_rename _lhsInt con_)
                                                  (map (SimpleExpr . locname . fst) _childrenIfields)
                                    rhs = App (semname _lhsIprefix _lhsInt con_)
                                              (map argument _childrenIfields)
                                    argument (nm,NT tp) = App (cataname _lhsIprefix tp)
                                                              [SimpleExpr (locname nm)]
                                    argument (nm, _)    = SimpleExpr (locname nm)
                                in Decl lhs rhs
                            -- "GenerateCode.ag"(line 312, column 17)
                            (_lhsOsemFun@_) =
                                let tsig = TSig (semname _lhsIprefix _lhsInt con_) semType
                                    semType = foldr argType
                                                    (SimpleType (sdtype _lhsInt))
                                                    (map snd _childrenIfields)
                                    argType (NT tp) rec = SimpleType (sdtype tp) `Arr` rec
                                    argType  tp     rec = SimpleType (typeToString _lhsInt tp) `Arr` rec
                                in if _lhsIo_sig
                                      then [tsig,_sFun    ]
                                      else [_sFun    ]
                            -- "GenerateCode.ag"(line 272, column 17)
                            (_sFun@_) =
                                let lhs = Fun (semname _lhsIprefix _lhsInt con_) lhs_args
                                    lhs_args =  map field _childrenIfields
                                    field (name,NT tp) = let unwrap | _lhsIo_newtypes = \x -> App (sdtype tp) [x]
                                                                    | otherwise       = id
                                                         in unwrap (SimpleExpr (fieldname name))
                                    field (name,_)     =  SimpleExpr (fieldname name)
                                    mkLambda [] e = e
                                    mkLambda xs e = Lambda xs e
                                    wrap = if _lhsIo_newtypes then \x -> App (sdtype _lhsInt) [x] else id
                                    rhs = wrap
                                          (mkLambda [lhsname True x | x <- Map.keys _lhsIinh]
                                            ( Let (typeSigs ++ _childrenIdecls ++ _rulesIdecls)
                                                (TupleExpr $ map (SimpleExpr . lhsname False )  _synnames)
                                            )
                                          )
                                    typeSigs | _lhsIo_sig =
                                                 let findType nm   = Map.findWithDefault _lhsInt nm
                                                                       (Map.fromList ((_LHS,_lhsInt)
                                                                                     : [(nm,nt)
                                                                                       | (nm, NT nt) <- _childrenIfields
                                                                                       ]
                                                                                     )
                                                                        )
                                                     lhs           = attribute False (_LHS,_lhsIsyn)
                                                     children      = concatMap (\(nm,inh,syn) -> attribute True  (nm,syn)
                                                                                              ++ attribute False (nm,inh)
                                                                               )
                                                                               _childrenIattributes
                                                     attribute isIn (nm,as) =
                                                                let nont = (findType nm)
                                                                in [TSig (attrname isIn nm a)
                                                                         (SimpleType (typeToString nont tp))
                                                                   |(a,tp) <- Map.toList as
                                                                   ]
                                                 in lhs++children
                                             | otherwise = []
                                 in Decl lhs rhs
                            -- "GenerateCode.ag"(line 351, column 17)
                            (_synnames@_) =
                                Map.keys _lhsIsyn
                            -- "GenerateCode.ag"(line 351, column 17)
                            (_inhnames@_) =
                                Map.keys _lhsIinh
                            -- "GenerateCode.ag"(line 351, column 17)
                            (_attrs@_) =
                                map ((,) _LOC) _rulesIlocVars ++
                                map ((,) _LHS) _inhnames ++
                                concat [map ((,) nm) (Map.keys as) | (nm,_,as) <- _childrenIattributes]
                            -- "GenerateCode.ag"(line 351, column 17)
                            (_fieldnames@_) =
                                map fst _childrenIfields
                            -- "./Comments.ag"(line 44, column 17)
                            (_lhsOcomment@_) =
                                Comment . unlines $
                                   [ replicate 3 ' ' ++ "local variables for " ++ getName _lhsInt ++ "." ++ getName con_ ++ ":"
                                   , unlines . map ((replicate 6 ' ')++) $ map getName _rulesIlocVars
                                   ]
                            -- "./Dep.ag"(line 97, column 17)
                            (_lhsOup@_) =
                                _up ++ _rulesIup ++ _childrenIup
                            -- "./Dep.ag"(line 94, column 17)
                            (_up@_) =
                                [ ( LHSInh _lhsInt con_ inh, stStart _LHS inh)
                                | inh <- _inhnames
                                ]
                            -- "./GenerateCodeSM.ag"(line 334, column 17)
                            (_lhsOsmConstructor@_) =
                                let constr = conname _lhsIo_rename _lhsInt con_
                                    chs = map snd _childrenIfields
                                    fargs =  (map (typeToString _lhsInt) chs ++ [getName _lhsInt])
                                in  (constr, (constr, fargs))
                            -- "./GenerateCodeSM.ag"(line 322, column 17)
                            (_lhsOsmCataAlt@_) =
                                let lhs = Fun (smcataname _lhsIprefix _lhsInt) [lhs_pat]
                                    lhs_pat = App (conname _lhsIo_rename _lhsInt con_)
                                                  (map (SimpleExpr . locname . fst) _childrenIfields)
                                    rhs = App fknit ([smsem, children_cata])
                                    smsem = App (smcompname _lhsIprefix _lhsInt con_) [(SimpleExpr unit)]
                                    children_cata = if (not . null) _childrenIfields
                                                    then foldr1 (\l r -> TupleExpr [l,r]) (map argument _childrenIfields)
                                                    else Lambda [unit] (SimpleExpr unit)
                                    argument (nm,NT tp) = App (smcataname _lhsIprefix tp)
                                                              [SimpleExpr (locname nm)]
                                    argument (nm,_)     = Lambda [unit] (TupleExpr [SimpleExpr (locname nm), SimpleExpr unit])
                                in  Decl lhs rhs
                            -- "./GenerateCodeSM.ag"(line 378, column 17)
                            (_lhsOnrChildren@_) =
                                length _childrenIfields
                            -- "./GenerateCodeSM.ag"(line 374, column 19)
                            (_childrenOdef_namespace@_) =
                                let n = length _childrenIfields
                                    chnames = map fst _childrenIfields
                                    f name i = (name, (n, i))
                                in  zipWith f chnames [1..n]
                            -- "./GenerateCodeSM.ag"(line 371, column 17)
                            (_lhsOsmPrimTypes@_) =
                                if null _childrenIfields
                                then [unittp]
                                else [t | Haskell t <- map snd _childrenIfields]
                            -- "./GenerateCodeSM.ag"(line 367, column 17)
                            (_lhsOsmInputDyn@_) =
                                let nm = conname _lhsIo_rename _lhsInt con_
                                    varnm = "_gen_var" ++ map toLower nm
                                    tpnm = smsdtype2 _lhsInt  con_ "input"
                                in  (nm, (varnm,tpnm))
                            -- "./GenerateCodeSM.ag"(line 365, column 17)
                            (_lhsOsmCompDyn@_) =
                                let nm = smcompname _lhsIprefix _lhsInt con_
                                in  (conname _lhsIo_rename _lhsInt con_,(nm,[smsdtype2 _lhsInt con_ "f"]))
                            -- "./GenerateCodeSM.ag"(line 363, column 17)
                            (_lhsOsmTypeCons@_) =
                                let mkTpNm post = smsdtype2 _lhsInt con_ post
                                in  [mkTpNm "input", mkTpNm "f"]
                            -- "./GenerateCodeSM.ag"(line 435, column 17)
                            (_smTpSigs@_) =
                                let unitTp = SimpleType unit
                                    inputTp = TupleType [ch_synTp, locTp, inhTp]
                                    outputTp = TupleType [ch_inhTp, locTp, synTp]
                                    emptyTp = TupleType [ ch_emptyTp, unitTp, unitTp]
                                    ch_emptyTp = tupnestTp' (map (const unitTp) _childrenIfields)
                                    ch_synTp = tupnestTp' ((map (\tup -> argTypeSyn (snd tup) "syn")) _childrenIfields)
                                    ch_inhTp = tupnestTp' ((map (\tup -> argTypeInh (snd tup) "inh")) _childrenIfields)
                                    argTypeSyn tp post = case tp of
                                                           NT nt -> SimpleType (smsdtype nt post)
                                                           _     -> TupleType [SimpleType (typeToString _lhsInt tp), SimpleType unit]
                                    argTypeInh tp post = case tp of
                                                           NT nt -> SimpleType (smsdtype nt post)
                                                           _     -> SimpleType unit
                                    locTp = SimpleType (smsdtype _lhsInt "loc")
                                    inhTp = SimpleType (smsdtype _lhsInt "inh")
                                    synTp = SimpleType (smsdtype _lhsInt "syn")
                                    semType = foldr1 Arr [unitTp, inputTp, emptyTp, outputTp]
                                in  [ Code.Type (smsdtype2 _lhsInt con_ "input") inputTp
                                    , Code.Type (smsdtype2 _lhsInt con_ "output") outputTp
                                    , Code.Type (smsdtype2 _lhsInt con_ "f") semType
                                    ]
                            -- "./GenerateCodeSM.ag"(line 433, column 17)
                            (_smCompTpSig@_) =
                                TSig (smcompname _lhsIprefix _lhsInt con_)
                                     (SimpleType (smsdtype2 _lhsInt con_ "f"))
                            -- "./GenerateCodeSM.ag"(line 422, column 17)
                            (_smComputation@_) =
                                let comp_input = let ch  = tupnest' (map (tupnest . (map SimpleExpr)) _childrenIsmSynAttrNames)
                                                     loc = tupnest []
                                                     pi  = tupnest (map (SimpleExpr . lhsname True) _inhnames)
                                                 in  App lazytilde [TupleExpr [ch,loc,pi]]
                                    comp_output = let ch  = tupnest' (map (tupnest . (map SimpleExpr)) _childrenIsmInhAttrNames)
                                                      loc = tupnest []
                                                      pi  = tupnest (map (SimpleExpr . lhsname False) _synnames)
                                                  in App "const" [TupleExpr [ch,loc,pi]]
                                    lhs = Fun (smcompname _lhsIprefix _lhsInt con_) ([SimpleExpr underscore, comp_input])
                                    rhs = Let _rulesIdecls comp_output
                                in Decl lhs rhs
                            -- "./GenerateCodeSM.ag"(line 421, column 17)
                            (_lhsOsmSemFun@_) =
                                _smTpSigs++[_smCompTpSig    , _smComputation]
                            -- "./GenerateCodeSM.ag"(line 654, column 17)
                            (_lhsOsmInsDyns@_) =
                                _childrenIsmInhInsDyns ++ _synInsDyns
                            -- "./GenerateCodeSM.ag"(line 653, column 17)
                            (_lhsOsmDynSemFuns@_) =
                                [_dynSemFun    ]
                            -- "./GenerateCodeSM.ag"(line 652, column 17)
                            (_lhsOsmDynSels@_) =
                                _smChSelDyns     ++ _smInhSelDyns
                            -- "./GenerateCodeSM.ag"(line 650, column 17)
                            (_lhsOsmSelFun@_) =
                                _smpCataAlt     : _mkSemFun     : _childSelectors     ++ _inhSelectors     ++
                                _synInserters     ++ _childrenIsmInhInserters
                            -- "./GenerateCodeSM.ag"(line 641, column 17)
                            (_dynSemFun@_) =
                                let nm = (makesemnm _lhsInt con_)
                                    ident = conname _lhsIo_rename _lhsInt con_
                                    compnm = smsdtype2 _lhsInt con_ "f"
                                    chargs = if null _childrenIfields then [unittp]
                                                                      else map argument _childrenIfields
                                    argument (_,NT tp)     = smsdtype tp ""
                                    argument (_,Haskell t) = t
                                    args = compnm : (chargs ++ [smsdtype _lhsInt ""])
                                in  (ident,(nm,args))
                            -- "./GenerateCodeSM.ag"(line 628, column 17)
                            (_mkSemFun@_) =
                                let newcomp = SimpleExpr "_newcomp_"
                                    lhs = Fun (makesemnm _lhsInt con_) [newcomp]
                                    ch_names = if null _childrenIfields then [unit]
                                               else map (locname . fst) _childrenIfields
                                    newcompapp = App "_newcomp_" [SimpleExpr unit]
                                    knitapp = App fknit [newcompapp, children_args]
                                    children_args = if (not . null) _childrenIfields
                                                    then foldr1 (\l r -> TupleExpr [l,r]) (map argument _childrenIfields)
                                                    else Lambda [unit] (SimpleExpr unit)
                                    argument (nm,NT tp) = SimpleExpr (locname nm)
                                    argument (nm,_)     = Lambda [unit] (TupleExpr [SimpleExpr (locname nm), SimpleExpr unit])
                                    rhs = Lambda ch_names knitapp
                                in  Decl lhs rhs
                            -- "./GenerateCodeSM.ag"(line 618, column 17)
                            (_smpCataAlt@_) =
                                let lhs = Fun (smpcataname _lhsIprefix _lhsInt con_) lhs_pat
                                    lhs_pat = (map (SimpleExpr . locname . fst) _childrenIfields)
                                    rhs = App fknit ([smsem, children_args])
                                    smsem = App (smcompname _lhsIprefix _lhsInt con_) [(SimpleExpr unit)]
                                    children_args = if (not . null) _childrenIfields
                                                    then foldr1 (\l r -> TupleExpr [l,r]) (map argument _childrenIfields)
                                                    else Lambda [unit] (SimpleExpr unit)
                                    argument (nm,NT tp) = SimpleExpr (locname nm)
                                    argument (nm,_)     = Lambda [unit] (TupleExpr [SimpleExpr (locname nm), SimpleExpr unit])
                                in  Decl lhs rhs
                            -- "./GenerateCodeSM.ag"(line 609, column 17)
                            (_synInsDyns@_) =
                                let synAttrs = Map.toList _lhsIsyn
                                    ident a = (conname _lhsIo_rename _lhsInt con_) ++ "_lhs_" ++ getName a
                                    fname a = insertnm _lhsInt con_ a
                                    inpArg t = let tp = typeToString _lhsInt t
                                               in Arr (SimpleType (smsdtype2 _lhsInt  con_ "input"))
                                                    (SimpleType tp)
                                    arg tp = let btp = SimpleType (smsdtype2 _lhsInt con_ "f")
                                             in  Arr (inpArg tp) (Arr btp btp)
                                in  map (\(s,tp) -> (ident s, (fname s, arg tp))) synAttrs
                            -- "./GenerateCodeSM.ag"(line 606, column 17)
                            (_synInserters@_) =
                                let insm syn = insertnm _lhsInt con_ syn
                                    insm' syn = insertnm _lhsInt nullIdent syn
                                in  map (\syn -> mkExtendExpr (insm syn) syn_def (insm' syn)) _synnames
                            -- "./GenerateCodeSM.ag"(line 601, column 17)
                            (_smInhSelDyns@_) =
                                let ident = (conname _lhsIo_rename _lhsInt con_) ++ "_lhs"
                                    nm = selectnm _lhsInt con_ (identifier "inh")
                                    args = [(smsdtype2 _lhsInt con_ "input"),
                                                     (smsdtype _lhsInt "inh")]
                                in  [(ident,(getName _lhsInt,nm,args))]
                            -- "./GenerateCodeSM.ag"(line 596, column 17)
                            (_inhSelectors@_) =
                                let inputPat = TupleExpr [SimpleExpr "_chsyn_", SimpleExpr "_loc_", SimpleExpr "_inh_"]
                                    lhs = Fun (selectnm _lhsInt con_ (identifier "inh" ))
                                              [inputPat]
                                    rhs = SimpleExpr "_inh_"
                                in  [Decl lhs rhs]
                            -- "./GenerateCodeSM.ag"(line 590, column 17)
                            (_smChSelDyns@_) =
                                let fident (ch,tp) = (conname _lhsIo_rename _lhsInt con_) ++ "_" ++ getName ch
                                    fnm (ch,tp) = selectnm _lhsInt con_ ch
                                    fargs (ch,tp) = [(smsdtype2 _lhsInt  con_ "input"),
                                                     (smsdtype tp "syn")]
                                    fchSelDyn tup@(ch,tp) = (fident tup, (getName tp, fnm tup, fargs tup))
                                in  map fchSelDyn [ (ch, tp) | (ch,NT tp)<- _childrenIfields]
                            -- "./GenerateCodeSM.ag"(line 584, column 17)
                            (_childSelectors@_) =
                                let chnames = map fst _childrenIfields
                                    inputPat = TupleExpr [tupnest' (map (SimpleExpr . getName) chnames), SimpleExpr "_loc_", SimpleExpr "_inh_"]
                                    mklhs ch = Fun (selectnm _lhsInt con_ ch)
                                                   [inputPat]
                                    mkrhs ch = SimpleExpr (getName ch)
                                in  map (\ch -> Decl (mklhs ch) (mkrhs ch)) chnames
                            -- use rule
                            (_lhsOerrors@_) =
                                _childrenIerrors Seq.<> _rulesIerrors
                            -- copy rule (from local)
                            (_childrenOattrs@_) =
                                _attrs
                            -- copy rule (down)
                            (_childrenOdown@_) =
                                _lhsIdown
                            -- copy rule (from local)
                            (_childrenOfieldnames@_) =
                                _fieldnames
                            -- copy rule (down)
                            (_childrenOinh@_) =
                                _lhsIinh
                            -- copy rule (down)
                            (_childrenOnt@_) =
                                _lhsInt
                            -- copy rule (down)
                            (_childrenOnts'@_) =
                                _lhsInts'
                            -- copy rule (down)
                            (_childrenOo_rename@_) =
                                _lhsIo_rename
                            -- copy rule (down)
                            (_childrenOprefix@_) =
                                _lhsIprefix
                            -- copy rule (from local)
                            (_rulesOattrs@_) =
                                _attrs
                            -- copy rule (down)
                            (_rulesOdown@_) =
                                _lhsIdown
                            -- copy rule (from local)
                            (_rulesOfieldnames@_) =
                                _fieldnames
                            -- copy rule (chain)
                            (_rulesOfields@_) =
                                _childrenIfields
                            -- copy rule (down)
                            (_rulesOnt@_) =
                                _lhsInt
                            -- copy rule (down)
                            (_rulesOo_pretty@_) =
                                _lhsIo_pretty
                        in  ( _lhsOcataAlt,_lhsOcomment,_lhsOdataAlt,_lhsOerrors,_lhsOnrChildren,_lhsOsemFun,_lhsOsmCataAlt,_lhsOsmCompDyn,_lhsOsmConstructor,_lhsOsmDynSels,_lhsOsmDynSemFuns,_lhsOsmInputDyn,_lhsOsmInsDyns,_lhsOsmPrimTypes,_lhsOsmSelFun,_lhsOsmSemFun,_lhsOsmTypeCons,_lhsOup)))
-- Alternatives ------------------------------------------------
{-
   inherited attributes:
      down                 : [UseStream]
      inh                  : Attributes
      nt                   : Identifier
      nts'                 : [Name]
      o_cata               : Bool
      o_newtypes           : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      prefix               : String
      syn                  : Attributes

   chained attributes:

   synthesised attributes:
      cataAlts             : Decls
      comments             : Decls
      dataAlts             : DataAlts
      errors               : Seq Error
      nrChildren           : Int
      semFuns              : Decls
      smCataAlts           : Decls
      smCompDyns           : [(String,(String,[String]))]
      smConstructors       : [(String,(String,[String]))]
      smDynSels            : [(String,(String,String,[String]))]
      smDynSemFuns         : [(String,(String,[String]))]
      smInputDyns          : [(String,(String,String))]
      smInsDyns            : [(String,(String,Code.Type))]
      smPrimTypes          : [String]
      smSelFuns            : Decls
      smSemFuns            : Decls
      smTypeCons           : [String]
      up                   : [UseStream]

-}
{-
   local variables for Alternatives.Cons:

-}
{-
   local variables for Alternatives.Nil:

-}
-- semantic domain
newtype T_Alternatives = T_Alternatives (([UseStream]) ->
                                         (Attributes) ->
                                         (Identifier) ->
                                         ([Name]) ->
                                         (Bool) ->
                                         (Bool) ->
                                         (Bool) ->
                                         (Bool) ->
                                         (Bool) ->
                                         (Bool) ->
                                         (String) ->
                                         (Attributes) ->
                                         ( (Decls),(Decls),(DataAlts),(Seq Error),(Int),(Decls),(Decls),([(String,(String,[String]))]),([(String,(String,[String]))]),([(String,(String,String,[String]))]),([(String,(String,[String]))]),([(String,(String,String))]),([(String,(String,Code.Type))]),([String]),(Decls),(Decls),([String]),([UseStream])))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
data Inh_Alternatives = Inh_Alternatives {down_Inh_Alternatives :: [UseStream],inh_Inh_Alternatives :: Attributes,nt_Inh_Alternatives :: Identifier,nts'_Inh_Alternatives :: [Name],o_cata_Inh_Alternatives :: Bool,o_newtypes_Inh_Alternatives :: Bool,o_pretty_Inh_Alternatives :: Bool,o_rename_Inh_Alternatives :: Bool,o_sem_Inh_Alternatives :: Bool,o_sig_Inh_Alternatives :: Bool,prefix_Inh_Alternatives :: String,syn_Inh_Alternatives :: Attributes}
data Syn_Alternatives = Syn_Alternatives {cataAlts_Syn_Alternatives :: Decls
                                         ,comments_Syn_Alternatives :: Decls
                                         ,dataAlts_Syn_Alternatives :: DataAlts
                                         ,errors_Syn_Alternatives :: Seq Error
                                         ,nrChildren_Syn_Alternatives :: Int
                                         ,semFuns_Syn_Alternatives :: Decls
                                         ,smCataAlts_Syn_Alternatives :: Decls
                                         ,smCompDyns_Syn_Alternatives :: [(String,(String,[String]))]
                                         ,smConstructors_Syn_Alternatives :: [(String,(String,[String]))]
                                         ,smDynSels_Syn_Alternatives :: [(String,(String,String,[String]))]
                                         ,smDynSemFuns_Syn_Alternatives :: [(String,(String,[String]))]
                                         ,smInputDyns_Syn_Alternatives :: [(String,(String,String))]
                                         ,smInsDyns_Syn_Alternatives :: [(String,(String,Code.Type))]
                                         ,smPrimTypes_Syn_Alternatives :: [String]
                                         ,smSelFuns_Syn_Alternatives :: Decls
                                         ,smSemFuns_Syn_Alternatives :: Decls
                                         ,smTypeCons_Syn_Alternatives :: [String]
                                         ,up_Syn_Alternatives :: [UseStream]
                                         }
wrap_Alternatives :: (T_Alternatives) ->
                     (Inh_Alternatives) ->
                     (Syn_Alternatives)
wrap_Alternatives ((T_Alternatives (sem))) ((Inh_Alternatives (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12))) =
    let ( s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12))
    in  (Syn_Alternatives (s1) (s2) (s3) (s4) (s5) (s6) (s7) (s8) (s9) (s10) (s11) (s12) (s13) (s14) (s15) (s16) (s17) (s18))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons ((T_Alternative (hd_))) ((T_Alternatives (tl_))) =
    (T_Alternatives (\ _lhsIdown
                       _lhsIinh
                       _lhsInt
                       _lhsInts'
                       _lhsIo_cata
                       _lhsIo_newtypes
                       _lhsIo_pretty
                       _lhsIo_rename
                       _lhsIo_sem
                       _lhsIo_sig
                       _lhsIprefix
                       _lhsIsyn ->
                         let _lhsOcataAlts :: (Decls)
                             _lhsOcomments :: (Decls)
                             _lhsOdataAlts :: (DataAlts)
                             _lhsOerrors :: (Seq Error)
                             _lhsOnrChildren :: (Int)
                             _lhsOsemFuns :: (Decls)
                             _lhsOsmCataAlts :: (Decls)
                             _lhsOsmCompDyns :: ([(String,(String,[String]))])
                             _lhsOsmConstructors :: ([(String,(String,[String]))])
                             _lhsOsmDynSels :: ([(String,(String,String,[String]))])
                             _lhsOsmDynSemFuns :: ([(String,(String,[String]))])
                             _lhsOsmInputDyns :: ([(String,(String,String))])
                             _lhsOsmInsDyns :: ([(String,(String,Code.Type))])
                             _lhsOsmPrimTypes :: ([String])
                             _lhsOsmSelFuns :: (Decls)
                             _lhsOsmSemFuns :: (Decls)
                             _lhsOsmTypeCons :: ([String])
                             _lhsOup :: ([UseStream])
                             _hdIcataAlt :: (Decl)
                             _hdIcomment :: (Decl)
                             _hdIdataAlt :: (DataAlt)
                             _hdIerrors :: (Seq Error)
                             _hdInrChildren :: (Int)
                             _hdIsemFun :: (Decls)
                             _hdIsmCataAlt :: (Decl)
                             _hdIsmCompDyn :: ((String,(String,[String])))
                             _hdIsmConstructor :: ((String,(String,[String])))
                             _hdIsmDynSels :: ([(String,(String,String,[String]))])
                             _hdIsmDynSemFuns :: ([(String,(String,[String]))])
                             _hdIsmInputDyn :: ((String,(String,String)))
                             _hdIsmInsDyns :: ([(String,(String,Code.Type))])
                             _hdIsmPrimTypes :: ([String])
                             _hdIsmSelFun :: (Decls)
                             _hdIsmSemFun :: (Decls)
                             _hdIsmTypeCons :: ([String])
                             _hdIup :: ([UseStream])
                             _hdOdown :: ([UseStream])
                             _hdOinh :: (Attributes)
                             _hdOnt :: (Identifier)
                             _hdOnts' :: ([Name])
                             _hdOo_cata :: (Bool)
                             _hdOo_newtypes :: (Bool)
                             _hdOo_pretty :: (Bool)
                             _hdOo_rename :: (Bool)
                             _hdOo_sem :: (Bool)
                             _hdOo_sig :: (Bool)
                             _hdOprefix :: (String)
                             _hdOsyn :: (Attributes)
                             _tlIcataAlts :: (Decls)
                             _tlIcomments :: (Decls)
                             _tlIdataAlts :: (DataAlts)
                             _tlIerrors :: (Seq Error)
                             _tlInrChildren :: (Int)
                             _tlIsemFuns :: (Decls)
                             _tlIsmCataAlts :: (Decls)
                             _tlIsmCompDyns :: ([(String,(String,[String]))])
                             _tlIsmConstructors :: ([(String,(String,[String]))])
                             _tlIsmDynSels :: ([(String,(String,String,[String]))])
                             _tlIsmDynSemFuns :: ([(String,(String,[String]))])
                             _tlIsmInputDyns :: ([(String,(String,String))])
                             _tlIsmInsDyns :: ([(String,(String,Code.Type))])
                             _tlIsmPrimTypes :: ([String])
                             _tlIsmSelFuns :: (Decls)
                             _tlIsmSemFuns :: (Decls)
                             _tlIsmTypeCons :: ([String])
                             _tlIup :: ([UseStream])
                             _tlOdown :: ([UseStream])
                             _tlOinh :: (Attributes)
                             _tlOnt :: (Identifier)
                             _tlOnts' :: ([Name])
                             _tlOo_cata :: (Bool)
                             _tlOo_newtypes :: (Bool)
                             _tlOo_pretty :: (Bool)
                             _tlOo_rename :: (Bool)
                             _tlOo_sem :: (Bool)
                             _tlOo_sig :: (Bool)
                             _tlOprefix :: (String)
                             _tlOsyn :: (Attributes)
                             ( _hdIcataAlt,_hdIcomment,_hdIdataAlt,_hdIerrors,_hdInrChildren,_hdIsemFun,_hdIsmCataAlt,_hdIsmCompDyn,_hdIsmConstructor,_hdIsmDynSels,_hdIsmDynSemFuns,_hdIsmInputDyn,_hdIsmInsDyns,_hdIsmPrimTypes,_hdIsmSelFun,_hdIsmSemFun,_hdIsmTypeCons,_hdIup) =
                                 (hd_ (_hdOdown) (_hdOinh) (_hdOnt) (_hdOnts') (_hdOo_cata) (_hdOo_newtypes) (_hdOo_pretty) (_hdOo_rename) (_hdOo_sem) (_hdOo_sig) (_hdOprefix) (_hdOsyn))
                             ( _tlIcataAlts,_tlIcomments,_tlIdataAlts,_tlIerrors,_tlInrChildren,_tlIsemFuns,_tlIsmCataAlts,_tlIsmCompDyns,_tlIsmConstructors,_tlIsmDynSels,_tlIsmDynSemFuns,_tlIsmInputDyns,_tlIsmInsDyns,_tlIsmPrimTypes,_tlIsmSelFuns,_tlIsmSemFuns,_tlIsmTypeCons,_tlIup) =
                                 (tl_ (_tlOdown) (_tlOinh) (_tlOnt) (_tlOnts') (_tlOo_cata) (_tlOo_newtypes) (_tlOo_pretty) (_tlOo_rename) (_tlOo_sem) (_tlOo_sig) (_tlOprefix) (_tlOsyn))
                             -- "GenerateCode.ag"(line 223, column 17)
                             (_lhsOdataAlts@_) =
                                 _hdIdataAlt : _tlIdataAlts
                             -- "GenerateCode.ag"(line 246, column 10)
                             (_lhsOcataAlts@_) =
                                 _hdIcataAlt : _tlIcataAlts
                             -- "GenerateCode.ag"(line 268, column 10)
                             (_lhsOsemFuns@_) =
                                 _hdIsemFun ++ _tlIsemFuns
                             -- "./Comments.ag"(line 40, column 10)
                             (_lhsOcomments@_) =
                                 _hdIcomment : _tlIcomments
                             -- "./GenerateCodeSM.ag"(line 317, column 10)
                             (_lhsOsmConstructors@_) =
                                 _hdIsmConstructor : _tlIsmConstructors
                             -- "./GenerateCodeSM.ag"(line 316, column 10)
                             (_lhsOsmCataAlts@_) =
                                 _hdIsmCataAlt : _tlIsmCataAlts
                             -- "./GenerateCodeSM.ag"(line 356, column 10)
                             (_lhsOnrChildren@_) =
                                 _hdInrChildren `max` _tlInrChildren
                             -- "./GenerateCodeSM.ag"(line 355, column 10)
                             (_lhsOsmInputDyns@_) =
                                 _hdIsmInputDyn : _tlIsmInputDyns
                             -- "./GenerateCodeSM.ag"(line 354, column 10)
                             (_lhsOsmCompDyns@_) =
                                 _hdIsmCompDyn : _tlIsmCompDyns
                             -- "./GenerateCodeSM.ag"(line 353, column 10)
                             (_lhsOsmSemFuns@_) =
                                 _hdIsmSemFun ++ _tlIsmSemFuns
                             -- "./GenerateCodeSM.ag"(line 580, column 10)
                             (_lhsOsmSelFuns@_) =
                                 _hdIsmSelFun ++ _tlIsmSelFuns
                             -- use rule
                             (_lhsOerrors@_) =
                                 _hdIerrors Seq.<> _tlIerrors
                             -- use rule
                             (_lhsOsmDynSels@_) =
                                 _hdIsmDynSels ++ _tlIsmDynSels
                             -- use rule
                             (_lhsOsmDynSemFuns@_) =
                                 _hdIsmDynSemFuns ++ _tlIsmDynSemFuns
                             -- use rule
                             (_lhsOsmInsDyns@_) =
                                 _hdIsmInsDyns ++ _tlIsmInsDyns
                             -- use rule
                             (_lhsOsmPrimTypes@_) =
                                 _hdIsmPrimTypes ++ _tlIsmPrimTypes
                             -- use rule
                             (_lhsOsmTypeCons@_) =
                                 _hdIsmTypeCons ++ _tlIsmTypeCons
                             -- use rule
                             (_lhsOup@_) =
                                 _hdIup ++ _tlIup
                             -- copy rule (down)
                             (_hdOdown@_) =
                                 _lhsIdown
                             -- copy rule (down)
                             (_hdOinh@_) =
                                 _lhsIinh
                             -- copy rule (down)
                             (_hdOnt@_) =
                                 _lhsInt
                             -- copy rule (down)
                             (_hdOnts'@_) =
                                 _lhsInts'
                             -- copy rule (down)
                             (_hdOo_cata@_) =
                                 _lhsIo_cata
                             -- copy rule (down)
                             (_hdOo_newtypes@_) =
                                 _lhsIo_newtypes
                             -- copy rule (down)
                             (_hdOo_pretty@_) =
                                 _lhsIo_pretty
                             -- copy rule (down)
                             (_hdOo_rename@_) =
                                 _lhsIo_rename
                             -- copy rule (down)
                             (_hdOo_sem@_) =
                                 _lhsIo_sem
                             -- copy rule (down)
                             (_hdOo_sig@_) =
                                 _lhsIo_sig
                             -- copy rule (down)
                             (_hdOprefix@_) =
                                 _lhsIprefix
                             -- copy rule (down)
                             (_hdOsyn@_) =
                                 _lhsIsyn
                             -- copy rule (down)
                             (_tlOdown@_) =
                                 _lhsIdown
                             -- copy rule (down)
                             (_tlOinh@_) =
                                 _lhsIinh
                             -- copy rule (down)
                             (_tlOnt@_) =
                                 _lhsInt
                             -- copy rule (down)
                             (_tlOnts'@_) =
                                 _lhsInts'
                             -- copy rule (down)
                             (_tlOo_cata@_) =
                                 _lhsIo_cata
                             -- copy rule (down)
                             (_tlOo_newtypes@_) =
                                 _lhsIo_newtypes
                             -- copy rule (down)
                             (_tlOo_pretty@_) =
                                 _lhsIo_pretty
                             -- copy rule (down)
                             (_tlOo_rename@_) =
                                 _lhsIo_rename
                             -- copy rule (down)
                             (_tlOo_sem@_) =
                                 _lhsIo_sem
                             -- copy rule (down)
                             (_tlOo_sig@_) =
                                 _lhsIo_sig
                             -- copy rule (down)
                             (_tlOprefix@_) =
                                 _lhsIprefix
                             -- copy rule (down)
                             (_tlOsyn@_) =
                                 _lhsIsyn
                         in  ( _lhsOcataAlts,_lhsOcomments,_lhsOdataAlts,_lhsOerrors,_lhsOnrChildren,_lhsOsemFuns,_lhsOsmCataAlts,_lhsOsmCompDyns,_lhsOsmConstructors,_lhsOsmDynSels,_lhsOsmDynSemFuns,_lhsOsmInputDyns,_lhsOsmInsDyns,_lhsOsmPrimTypes,_lhsOsmSelFuns,_lhsOsmSemFuns,_lhsOsmTypeCons,_lhsOup)))
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil  =
    (T_Alternatives (\ _lhsIdown
                       _lhsIinh
                       _lhsInt
                       _lhsInts'
                       _lhsIo_cata
                       _lhsIo_newtypes
                       _lhsIo_pretty
                       _lhsIo_rename
                       _lhsIo_sem
                       _lhsIo_sig
                       _lhsIprefix
                       _lhsIsyn ->
                         let _lhsOcataAlts :: (Decls)
                             _lhsOcomments :: (Decls)
                             _lhsOdataAlts :: (DataAlts)
                             _lhsOerrors :: (Seq Error)
                             _lhsOnrChildren :: (Int)
                             _lhsOsemFuns :: (Decls)
                             _lhsOsmCataAlts :: (Decls)
                             _lhsOsmCompDyns :: ([(String,(String,[String]))])
                             _lhsOsmConstructors :: ([(String,(String,[String]))])
                             _lhsOsmDynSels :: ([(String,(String,String,[String]))])
                             _lhsOsmDynSemFuns :: ([(String,(String,[String]))])
                             _lhsOsmInputDyns :: ([(String,(String,String))])
                             _lhsOsmInsDyns :: ([(String,(String,Code.Type))])
                             _lhsOsmPrimTypes :: ([String])
                             _lhsOsmSelFuns :: (Decls)
                             _lhsOsmSemFuns :: (Decls)
                             _lhsOsmTypeCons :: ([String])
                             _lhsOup :: ([UseStream])
                             -- "GenerateCode.ag"(line 224, column 17)
                             (_lhsOdataAlts@_) =
                                 []
                             -- "GenerateCode.ag"(line 247, column 10)
                             (_lhsOcataAlts@_) =
                                 []
                             -- "GenerateCode.ag"(line 269, column 10)
                             (_lhsOsemFuns@_) =
                                 []
                             -- "./Comments.ag"(line 41, column 10)
                             (_lhsOcomments@_) =
                                 []
                             -- "./GenerateCodeSM.ag"(line 319, column 10)
                             (_lhsOsmConstructors@_) =
                                 []
                             -- "./GenerateCodeSM.ag"(line 318, column 10)
                             (_lhsOsmCataAlts@_) =
                                 []
                             -- "./GenerateCodeSM.ag"(line 360, column 10)
                             (_lhsOnrChildren@_) =
                                 0
                             -- "./GenerateCodeSM.ag"(line 359, column 10)
                             (_lhsOsmInputDyns@_) =
                                 []
                             -- "./GenerateCodeSM.ag"(line 358, column 10)
                             (_lhsOsmCompDyns@_) =
                                 []
                             -- "./GenerateCodeSM.ag"(line 357, column 10)
                             (_lhsOsmSemFuns@_) =
                                 []
                             -- "./GenerateCodeSM.ag"(line 581, column 10)
                             (_lhsOsmSelFuns@_) =
                                 []
                             -- use rule
                             (_lhsOerrors@_) =
                                 Seq.empty
                             -- use rule
                             (_lhsOsmDynSels@_) =
                                 []
                             -- use rule
                             (_lhsOsmDynSemFuns@_) =
                                 []
                             -- use rule
                             (_lhsOsmInsDyns@_) =
                                 []
                             -- use rule
                             (_lhsOsmPrimTypes@_) =
                                 []
                             -- use rule
                             (_lhsOsmTypeCons@_) =
                                 []
                             -- use rule
                             (_lhsOup@_) =
                                 []
                         in  ( _lhsOcataAlts,_lhsOcomments,_lhsOdataAlts,_lhsOerrors,_lhsOnrChildren,_lhsOsemFuns,_lhsOsmCataAlts,_lhsOsmCompDyns,_lhsOsmConstructors,_lhsOsmDynSels,_lhsOsmDynSemFuns,_lhsOsmInputDyns,_lhsOsmInsDyns,_lhsOsmPrimTypes,_lhsOsmSelFuns,_lhsOsmSemFuns,_lhsOsmTypeCons,_lhsOup)))
-- Child -------------------------------------------------------
{-
   inherited attributes:
      attrs                : [(Name,Name)]
      con                  : Identifier
      def_namespace        : [(Name,(Int,Int))]
      down                 : [UseStream]
      fieldnames           : [Name]
      nt                   : Identifier
      nts'                 : [Name]
      o_rename             : Bool
      prefix               : String

   chained attributes:

   synthesised attributes:
      attributes           : [(Name,Attributes,Attributes)]
      decls                : Decls
      errors               : Seq Error
      field                : (Name,Type)
      smInhAttrNames       : [String]
      smInhFnames          : [String]
      smInhInsDyns         : [(String,(String,Code.Type))]
      smInhInserters       : Decls
      smSynAttrNames       : [String]
      up                   : [UseStream]

-}
{-
   local variables for Child.Child:
      defname

-}
-- semantic domain
newtype T_Child = T_Child (([(Name,Name)]) ->
                           (Identifier) ->
                           ([(Name,(Int,Int))]) ->
                           ([UseStream]) ->
                           ([Name]) ->
                           (Identifier) ->
                           ([Name]) ->
                           (Bool) ->
                           (String) ->
                           ( ([(Name,Attributes,Attributes)]),(Decls),(Seq Error),((Name,Type)),([String]),([String]),([(String,(String,Code.Type))]),(Decls),([String]),([UseStream])))
-- cata
sem_Child :: (Child) ->
             (T_Child)
sem_Child ((Child (_name) (_tp) (_inh) (_syn))) =
    (sem_Child_Child (_name) (_tp) (_inh) (_syn))
data Inh_Child = Inh_Child {attrs_Inh_Child :: [(Name,Name)],con_Inh_Child :: Identifier,def_namespace_Inh_Child :: [(Name,(Int,Int))],down_Inh_Child :: [UseStream],fieldnames_Inh_Child :: [Name],nt_Inh_Child :: Identifier,nts'_Inh_Child :: [Name],o_rename_Inh_Child :: Bool,prefix_Inh_Child :: String}
data Syn_Child = Syn_Child {attributes_Syn_Child :: [(Name,Attributes,Attributes)],decls_Syn_Child :: Decls,errors_Syn_Child :: Seq Error,field_Syn_Child :: (Name,Type),smInhAttrNames_Syn_Child :: [String],smInhFnames_Syn_Child :: [String],smInhInsDyns_Syn_Child :: [(String,(String,Code.Type))],smInhInserters_Syn_Child :: Decls,smSynAttrNames_Syn_Child :: [String],up_Syn_Child :: [UseStream]}
wrap_Child :: (T_Child) ->
              (Inh_Child) ->
              (Syn_Child)
wrap_Child ((T_Child (sem))) ((Inh_Child (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9))) =
    let ( s1,s2,s3,s4,s5,s6,s7,s8,s9,s10) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9))
    in  (Syn_Child (s1) (s2) (s3) (s4) (s5) (s6) (s7) (s8) (s9) (s10))
sem_Child_Child :: (Name) ->
                   (Type) ->
                   (Attributes) ->
                   (Attributes) ->
                   (T_Child)
sem_Child_Child (name_) (tp_) (inh_) (syn_) =
    (T_Child (\ _lhsIattrs
                _lhsIcon
                _lhsIdef_namespace
                _lhsIdown
                _lhsIfieldnames
                _lhsInt
                _lhsInts'
                _lhsIo_rename
                _lhsIprefix ->
                  let _lhsOattributes :: ([(Name,Attributes,Attributes)])
                      _lhsOdecls :: (Decls)
                      _lhsOerrors :: (Seq Error)
                      _lhsOfield :: ((Name,Type))
                      _lhsOsmInhAttrNames :: ([String])
                      _lhsOsmInhFnames :: ([String])
                      _lhsOsmInhInsDyns :: ([(String,(String,Code.Type))])
                      _lhsOsmInhInserters :: (Decls)
                      _lhsOsmSynAttrNames :: ([String])
                      _lhsOup :: ([UseStream])
                      -- "GenerateCode.ag"(line 231, column 11)
                      (_lhsOfield@_) =
                          (name_, tp_)
                      -- "GenerateCode.ag"(line 333, column 11)
                      (_lhsOdecls@_) =
                          let syn = Map.keys syn_
                              inh = Map.keys inh_
                              decl = Decl (TupleLhs              [           (attrname True  name_ a) | a <- syn ])
                                          (App (fieldname name_) [SimpleExpr (attrname False name_ a) | a <- inh ])
                              decls = case tp_ of
                                         NT nt | not(null syn) -> [decl]
                                         _                     -> []
                          in decls
                      -- "GenerateCode.ag"(line 360, column 11)
                      (_lhsOattributes@_) =
                          [(name_, inh_, syn_)]
                      -- "./Dep.ag"(line 116, column 11)
                      (_lhsOup@_) =
                          if null ((Map.keys syn_) ++ (Map.keys inh_))
                           then [(Local _lhsInt _lhsIcon name_,stEmpty)]
                           else [ let stInit = stStart name_ syn
                                      stCopy = ports2stream
                                               (NTSyn (getNonterminalName tp_) syn)
                                               [RHSInh (getNonterminalName tp_) _lhsInt _lhsIcon name_ inh | inh<-(Map.keys inh_)]
                                               (_lhsIdown)
                                      stream = stUnion stInit stCopy
                                  in (RHSSyn (getNonterminalName tp_) _lhsInt _lhsIcon name_ syn,stream)
                                | syn<-(Map.keys syn_)
                                ]
                      -- "./GenerateCodeSM.ag"(line 523, column 11)
                      (_lhsOsmSynAttrNames@_) =
                          case tp_ of
                            NT nt -> map (attrname True name_) (Map.keys syn_)
                            _     -> [fieldname name_]
                      -- "./GenerateCodeSM.ag"(line 527, column 11)
                      (_lhsOsmInhAttrNames@_) =
                          case tp_ of
                            NT nt -> map (attrname False name_) (Map.keys inh_)
                            _     -> []
                      -- "./GenerateCodeSM.ag"(line 553, column 11)
                      (_lhsOsmInhInsDyns@_) =
                          let inhAttrs = Map.toList inh_
                              ident a = (conname _lhsIo_rename _lhsInt _lhsIcon) ++ "_" ++ getName name_ ++ "_" ++ getName a
                              fname a = insertinhnm _lhsInt _lhsIcon name_ a
                              inpArg t = let tp = typeToString _lhsInt t
                                         in Arr (SimpleType (smsdtype2 _lhsInt _lhsIcon "input"))
                                              (SimpleType tp)
                              arg tp = let btp = SimpleType (smsdtype2 _lhsInt  _lhsIcon "f")
                                       in  Arr (inpArg tp) (Arr btp btp)
                          in  map (\(s,tp) -> (ident s, (fname s, arg tp))) inhAttrs
                      -- "./GenerateCodeSM.ag"(line 549, column 11)
                      (_lhsOsmInhInserters@_) =
                          let inhAttrs = Map.keys inh_
                              insm inh = insertinhnm _lhsInt _lhsIcon name_ inh
                              insm' inh = insertnm (case tp_ of NT t -> t ; Haskell t -> identifier t) nullIdent inh
                          in  map (\inh -> mkExtendExpr (insm inh) _defname     (insm' inh)) inhAttrs
                      -- "./GenerateCodeSM.ag"(line 547, column 11)
                      (_lhsOsmInhFnames@_) =
                          let inhAttrs = Map.keys inh_
                          in  map (\inh -> smattrcompnamein _lhsIprefix _lhsInt _lhsIcon inh name_) inhAttrs
                      -- "./GenerateCodeSM.ag"(line 544, column 11)
                      (_defname@_) =
                          let impossible =  error $ "This should not happen: child not found "
                                                          ++ getName name_
                           in maybe impossible (uncurry mk_def_name) $ lookup name_ _lhsIdef_namespace
                      -- use rule
                      (_lhsOerrors@_) =
                          Seq.empty
                  in  ( _lhsOattributes,_lhsOdecls,_lhsOerrors,_lhsOfield,_lhsOsmInhAttrNames,_lhsOsmInhFnames,_lhsOsmInhInsDyns,_lhsOsmInhInserters,_lhsOsmSynAttrNames,_lhsOup)))
-- Children ----------------------------------------------------
{-
   inherited attributes:
      attrs                : [(Name,Name)]
      con                  : Identifier
      def_namespace        : [(Name,(Int, Int))]
      down                 : [UseStream]
      fieldnames           : [Name]
      inh                  : Attributes
      nt                   : Identifier
      nts'                 : [Name]
      o_rename             : Bool
      prefix               : String

   chained attributes:

   synthesised attributes:
      attributes           : [(Name,Attributes,Attributes)]
      decls                : Decls
      errors               : Seq Error
      fields               : [(Name,Type)]
      smInhAttrNames       : [[String]]
      smInhFnames          : [String]
      smInhInsDyns         : [(String,(String,Code.Type))]
      smInhInserters       : Decls
      smSynAttrNames       : [[String]]
      up                   : [UseStream]

-}
{-
   local variables for Children.Cons:

-}
{-
   local variables for Children.Nil:

-}
-- semantic domain
newtype T_Children = T_Children (([(Name,Name)]) ->
                                 (Identifier) ->
                                 ([(Name,(Int, Int))]) ->
                                 ([UseStream]) ->
                                 ([Name]) ->
                                 (Attributes) ->
                                 (Identifier) ->
                                 ([Name]) ->
                                 (Bool) ->
                                 (String) ->
                                 ( ([(Name,Attributes,Attributes)]),(Decls),(Seq Error),([(Name,Type)]),([[String]]),([String]),([(String,(String,Code.Type))]),(Decls),([[String]]),([UseStream])))
-- cata
sem_Children :: (Children) ->
                (T_Children)
sem_Children (list) =
    (foldr (sem_Children_Cons) (sem_Children_Nil) ((map sem_Child list)))
data Inh_Children = Inh_Children {attrs_Inh_Children :: [(Name,Name)],con_Inh_Children :: Identifier,def_namespace_Inh_Children :: [(Name,(Int, Int))],down_Inh_Children :: [UseStream],fieldnames_Inh_Children :: [Name],inh_Inh_Children :: Attributes,nt_Inh_Children :: Identifier,nts'_Inh_Children :: [Name],o_rename_Inh_Children :: Bool,prefix_Inh_Children :: String}
data Syn_Children = Syn_Children {attributes_Syn_Children :: [(Name,Attributes,Attributes)],decls_Syn_Children :: Decls,errors_Syn_Children :: Seq Error,fields_Syn_Children :: [(Name,Type)],smInhAttrNames_Syn_Children :: [[String]],smInhFnames_Syn_Children :: [String],smInhInsDyns_Syn_Children :: [(String,(String,Code.Type))],smInhInserters_Syn_Children :: Decls,smSynAttrNames_Syn_Children :: [[String]],up_Syn_Children :: [UseStream]}
wrap_Children :: (T_Children) ->
                 (Inh_Children) ->
                 (Syn_Children)
wrap_Children ((T_Children (sem))) ((Inh_Children (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10))) =
    let ( s1,s2,s3,s4,s5,s6,s7,s8,s9,s10) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10))
    in  (Syn_Children (s1) (s2) (s3) (s4) (s5) (s6) (s7) (s8) (s9) (s10))
sem_Children_Cons :: (T_Child) ->
                     (T_Children) ->
                     (T_Children)
sem_Children_Cons ((T_Child (hd_))) ((T_Children (tl_))) =
    (T_Children (\ _lhsIattrs
                   _lhsIcon
                   _lhsIdef_namespace
                   _lhsIdown
                   _lhsIfieldnames
                   _lhsIinh
                   _lhsInt
                   _lhsInts'
                   _lhsIo_rename
                   _lhsIprefix ->
                     let _lhsOattributes :: ([(Name,Attributes,Attributes)])
                         _lhsOdecls :: (Decls)
                         _lhsOerrors :: (Seq Error)
                         _lhsOfields :: ([(Name,Type)])
                         _lhsOsmInhAttrNames :: ([[String]])
                         _lhsOsmInhFnames :: ([String])
                         _lhsOsmInhInsDyns :: ([(String,(String,Code.Type))])
                         _lhsOsmInhInserters :: (Decls)
                         _lhsOsmSynAttrNames :: ([[String]])
                         _lhsOup :: ([UseStream])
                         _hdIattributes :: ([(Name,Attributes,Attributes)])
                         _hdIdecls :: (Decls)
                         _hdIerrors :: (Seq Error)
                         _hdIfield :: ((Name,Type))
                         _hdIsmInhAttrNames :: ([String])
                         _hdIsmInhFnames :: ([String])
                         _hdIsmInhInsDyns :: ([(String,(String,Code.Type))])
                         _hdIsmInhInserters :: (Decls)
                         _hdIsmSynAttrNames :: ([String])
                         _hdIup :: ([UseStream])
                         _hdOattrs :: ([(Name,Name)])
                         _hdOcon :: (Identifier)
                         _hdOdef_namespace :: ([(Name,(Int,Int))])
                         _hdOdown :: ([UseStream])
                         _hdOfieldnames :: ([Name])
                         _hdOnt :: (Identifier)
                         _hdOnts' :: ([Name])
                         _hdOo_rename :: (Bool)
                         _hdOprefix :: (String)
                         _tlIattributes :: ([(Name,Attributes,Attributes)])
                         _tlIdecls :: (Decls)
                         _tlIerrors :: (Seq Error)
                         _tlIfields :: ([(Name,Type)])
                         _tlIsmInhAttrNames :: ([[String]])
                         _tlIsmInhFnames :: ([String])
                         _tlIsmInhInsDyns :: ([(String,(String,Code.Type))])
                         _tlIsmInhInserters :: (Decls)
                         _tlIsmSynAttrNames :: ([[String]])
                         _tlIup :: ([UseStream])
                         _tlOattrs :: ([(Name,Name)])
                         _tlOcon :: (Identifier)
                         _tlOdef_namespace :: ([(Name,(Int, Int))])
                         _tlOdown :: ([UseStream])
                         _tlOfieldnames :: ([Name])
                         _tlOinh :: (Attributes)
                         _tlOnt :: (Identifier)
                         _tlOnts' :: ([Name])
                         _tlOo_rename :: (Bool)
                         _tlOprefix :: (String)
                         ( _hdIattributes,_hdIdecls,_hdIerrors,_hdIfield,_hdIsmInhAttrNames,_hdIsmInhFnames,_hdIsmInhInsDyns,_hdIsmInhInserters,_hdIsmSynAttrNames,_hdIup) =
                             (hd_ (_hdOattrs) (_hdOcon) (_hdOdef_namespace) (_hdOdown) (_hdOfieldnames) (_hdOnt) (_hdOnts') (_hdOo_rename) (_hdOprefix))
                         ( _tlIattributes,_tlIdecls,_tlIerrors,_tlIfields,_tlIsmInhAttrNames,_tlIsmInhFnames,_tlIsmInhInsDyns,_tlIsmInhInserters,_tlIsmSynAttrNames,_tlIup) =
                             (tl_ (_tlOattrs) (_tlOcon) (_tlOdef_namespace) (_tlOdown) (_tlOfieldnames) (_tlOinh) (_tlOnt) (_tlOnts') (_tlOo_rename) (_tlOprefix))
                         -- "GenerateCode.ag"(line 234, column 11)
                         (_lhsOfields@_) =
                             _hdIfield : _tlIfields
                         -- "./GenerateCodeSM.ag"(line 519, column 10)
                         (_lhsOsmInhAttrNames@_) =
                             _hdIsmInhAttrNames : _tlIsmInhAttrNames
                         -- "./GenerateCodeSM.ag"(line 518, column 10)
                         (_lhsOsmSynAttrNames@_) =
                             _hdIsmSynAttrNames : _tlIsmSynAttrNames
                         -- use rule
                         (_lhsOattributes@_) =
                             _hdIattributes ++ _tlIattributes
                         -- use rule
                         (_lhsOdecls@_) =
                             _hdIdecls ++ _tlIdecls
                         -- use rule
                         (_lhsOerrors@_) =
                             _hdIerrors Seq.<> _tlIerrors
                         -- use rule
                         (_lhsOsmInhFnames@_) =
                             _hdIsmInhFnames ++ _tlIsmInhFnames
                         -- use rule
                         (_lhsOsmInhInsDyns@_) =
                             _hdIsmInhInsDyns ++ _tlIsmInhInsDyns
                         -- use rule
                         (_lhsOsmInhInserters@_) =
                             _hdIsmInhInserters ++ _tlIsmInhInserters
                         -- use rule
                         (_lhsOup@_) =
                             _hdIup ++ _tlIup
                         -- copy rule (down)
                         (_hdOattrs@_) =
                             _lhsIattrs
                         -- copy rule (down)
                         (_hdOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_hdOdef_namespace@_) =
                             _lhsIdef_namespace
                         -- copy rule (down)
                         (_hdOdown@_) =
                             _lhsIdown
                         -- copy rule (down)
                         (_hdOfieldnames@_) =
                             _lhsIfieldnames
                         -- copy rule (down)
                         (_hdOnt@_) =
                             _lhsInt
                         -- copy rule (down)
                         (_hdOnts'@_) =
                             _lhsInts'
                         -- copy rule (down)
                         (_hdOo_rename@_) =
                             _lhsIo_rename
                         -- copy rule (down)
                         (_hdOprefix@_) =
                             _lhsIprefix
                         -- copy rule (down)
                         (_tlOattrs@_) =
                             _lhsIattrs
                         -- copy rule (down)
                         (_tlOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_tlOdef_namespace@_) =
                             _lhsIdef_namespace
                         -- copy rule (down)
                         (_tlOdown@_) =
                             _lhsIdown
                         -- copy rule (down)
                         (_tlOfieldnames@_) =
                             _lhsIfieldnames
                         -- copy rule (down)
                         (_tlOinh@_) =
                             _lhsIinh
                         -- copy rule (down)
                         (_tlOnt@_) =
                             _lhsInt
                         -- copy rule (down)
                         (_tlOnts'@_) =
                             _lhsInts'
                         -- copy rule (down)
                         (_tlOo_rename@_) =
                             _lhsIo_rename
                         -- copy rule (down)
                         (_tlOprefix@_) =
                             _lhsIprefix
                     in  ( _lhsOattributes,_lhsOdecls,_lhsOerrors,_lhsOfields,_lhsOsmInhAttrNames,_lhsOsmInhFnames,_lhsOsmInhInsDyns,_lhsOsmInhInserters,_lhsOsmSynAttrNames,_lhsOup)))
sem_Children_Nil :: (T_Children)
sem_Children_Nil  =
    (T_Children (\ _lhsIattrs
                   _lhsIcon
                   _lhsIdef_namespace
                   _lhsIdown
                   _lhsIfieldnames
                   _lhsIinh
                   _lhsInt
                   _lhsInts'
                   _lhsIo_rename
                   _lhsIprefix ->
                     let _lhsOattributes :: ([(Name,Attributes,Attributes)])
                         _lhsOdecls :: (Decls)
                         _lhsOerrors :: (Seq Error)
                         _lhsOfields :: ([(Name,Type)])
                         _lhsOsmInhAttrNames :: ([[String]])
                         _lhsOsmInhFnames :: ([String])
                         _lhsOsmInhInsDyns :: ([(String,(String,Code.Type))])
                         _lhsOsmInhInserters :: (Decls)
                         _lhsOsmSynAttrNames :: ([[String]])
                         _lhsOup :: ([UseStream])
                         -- "GenerateCode.ag"(line 235, column 11)
                         (_lhsOfields@_) =
                             []
                         -- "./GenerateCodeSM.ag"(line 521, column 10)
                         (_lhsOsmInhAttrNames@_) =
                             []
                         -- "./GenerateCodeSM.ag"(line 520, column 10)
                         (_lhsOsmSynAttrNames@_) =
                             []
                         -- use rule
                         (_lhsOattributes@_) =
                             []
                         -- use rule
                         (_lhsOdecls@_) =
                             []
                         -- use rule
                         (_lhsOerrors@_) =
                             Seq.empty
                         -- use rule
                         (_lhsOsmInhFnames@_) =
                             []
                         -- use rule
                         (_lhsOsmInhInsDyns@_) =
                             []
                         -- use rule
                         (_lhsOsmInhInserters@_) =
                             []
                         -- use rule
                         (_lhsOup@_) =
                             []
                     in  ( _lhsOattributes,_lhsOdecls,_lhsOerrors,_lhsOfields,_lhsOsmInhAttrNames,_lhsOsmInhFnames,_lhsOsmInhInsDyns,_lhsOsmInhInserters,_lhsOsmSynAttrNames,_lhsOup)))
-- Expression --------------------------------------------------
{-
   inherited attributes:
      attrs                : [(Name,Name)]
      con                  : Name
      fieldnames           : [Name]
      nt                   : Name

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      pos                  : Pos
      pp                   : PP_Doc
      usedAttrs            : [(Name,Name)]
      usedLocals           : [Name]

-}
{-
   local variables for Expression.Expression:
      errors
      pp
      usedAttrs
      usedLocals

-}
-- semantic domain
newtype T_Expression = T_Expression (([(Name,Name)]) ->
                                     (Name) ->
                                     ([Name]) ->
                                     (Name) ->
                                     ( (Seq Error),(Pos),(PP_Doc),([(Name,Name)]),([Name])))
-- cata
sem_Expression :: (Expression) ->
                  (T_Expression)
sem_Expression ((Expression (_pos) (_txt))) =
    (sem_Expression_Expression (_pos) (_txt))
data Inh_Expression = Inh_Expression {attrs_Inh_Expression :: [(Name,Name)],con_Inh_Expression :: Name,fieldnames_Inh_Expression :: [Name],nt_Inh_Expression :: Name}
data Syn_Expression = Syn_Expression {errors_Syn_Expression :: Seq Error,pos_Syn_Expression :: Pos,pp_Syn_Expression :: PP_Doc,usedAttrs_Syn_Expression :: [(Name,Name)],usedLocals_Syn_Expression :: [Name]}
wrap_Expression :: (T_Expression) ->
                   (Inh_Expression) ->
                   (Syn_Expression)
wrap_Expression ((T_Expression (sem))) ((Inh_Expression (i1) (i2) (i3) (i4))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2) (i3) (i4))
    in  (Syn_Expression (s1) (s2) (s3) (s4) (s5))
sem_Expression_Expression :: (Pos) ->
                             (String) ->
                             (T_Expression)
sem_Expression_Expression (pos_) (txt_) =
    (T_Expression (\ _lhsIattrs
                     _lhsIcon
                     _lhsIfieldnames
                     _lhsInt ->
                       let _lhsOerrors :: (Seq Error)
                           _lhsOpos :: (Pos)
                           _lhsOpp :: (PP_Doc)
                           _lhsOusedAttrs :: ([(Name,Name)])
                           _lhsOusedLocals :: ([Name])
                           -- "./ExpressionAttr.ag"(line 31, column 21)
                           ((_errors@_,_pp@_,_usedAttrs@_,_usedLocals@_)) =
                               let inherited = Inh_HsTokensRoot
                                               { attrs_Inh_HsTokensRoot   = _lhsIattrs
                                               , con_Inh_HsTokensRoot     = _lhsIcon
                                               , fieldnames_Inh_HsTokensRoot  = _lhsIfieldnames
                                               , nt_Inh_HsTokensRoot      = _lhsInt
                                               }
                                   synthesized = wrap_HsTokensRoot (sem_HsTokensRoot (HsTokensRoot $ lexTokens pos_ txt_)) inherited
                               in case synthesized of
                                    Syn_HsTokensRoot
                                     { errors_Syn_HsTokensRoot     = errors
                                     , pp_Syn_HsTokensRoot         = pp
                                     , usedAttrs_Syn_HsTokensRoot  = usedAttrs
                                     , usedLocals_Syn_HsTokensRoot = usedLocals
                                     }  -> (errors,pp,usedAttrs,usedLocals)
                           -- "./Dep.ag"(line 181, column 16)
                           (_lhsOpos@_) =
                               pos_
                           -- copy rule (from local)
                           (_lhsOerrors@_) =
                               _errors
                           -- copy rule (from local)
                           (_lhsOpp@_) =
                               _pp
                           -- copy rule (from local)
                           (_lhsOusedAttrs@_) =
                               _usedAttrs
                           -- copy rule (from local)
                           (_lhsOusedLocals@_) =
                               _usedLocals
                       in  ( _lhsOerrors,_lhsOpos,_lhsOpp,_lhsOusedAttrs,_lhsOusedLocals)))
-- Grammar -----------------------------------------------------
{-
   inherited attributes:
      options              : Options

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      prog                 : Program
      smdynlists           : ([String], [String])

-}
{-
   local variables for Grammar.Grammar:
      o_pretty
      errors
      smDefinitions
      smTypeReps
      defnmdecls
      tpConstants
      instanceShowF
      instanceTypeDescr
      dataTypeCon
      types
      dynInsFuns
      dynSemFuns
      selDynVals
      selDyns
      inputDyns
      compDyns
      constructors
      imports
      allTypes
      allTypesTop
      smUnitDecl
      smPrimTypes

-}
-- semantic domain
newtype T_Grammar = T_Grammar ((Options) ->
                               ( (Seq Error),(Program),(([String], [String]))))
-- cata
sem_Grammar :: (Grammar) ->
               (T_Grammar)
sem_Grammar ((Grammar (_typeSyns) (_useMap) (_derivings) (_wrappers) (_prods))) =
    (sem_Grammar_Grammar (_typeSyns) (_useMap) (_derivings) (_wrappers) ((sem_Productions (_prods))))
data Inh_Grammar = Inh_Grammar {options_Inh_Grammar :: Options}
data Syn_Grammar = Syn_Grammar {errors_Syn_Grammar :: Seq Error,prog_Syn_Grammar :: Program,smdynlists_Syn_Grammar :: ([String], [String])}
wrap_Grammar :: (T_Grammar) ->
                (Inh_Grammar) ->
                (Syn_Grammar)
wrap_Grammar ((T_Grammar (sem))) ((Inh_Grammar (i1))) =
    let ( s1,s2,s3) =
            (sem (i1))
    in  (Syn_Grammar (s1) (s2) (s3))
sem_Grammar_Grammar :: (TypeSyns) ->
                       (UseMap) ->
                       (Derivings) ->
                       (Set Nonterminal) ->
                       (T_Productions) ->
                       (T_Grammar)
sem_Grammar_Grammar (typeSyns_) (useMap_) (derivings_) (wrappers_) ((T_Productions (prods_))) =
    (T_Grammar (\ _lhsIoptions ->
                    let _lhsOerrors :: (Seq Error)
                        _lhsOprog :: (Program)
                        _lhsOsmdynlists :: (([String], [String]))
                        _prodsIdecls :: (Decls)
                        _prodsIerrors :: (Seq Error)
                        _prodsInrChildren :: (Int)
                        _prodsInts :: ([Name])
                        _prodsIsmCompDyns :: ([(String,(String,[String]))])
                        _prodsIsmConstructors :: ([(String,(String,[String]))])
                        _prodsIsmDynSels :: ([(String,(String,String,[String]))])
                        _prodsIsmDynSemFuns :: ([(String,(String,[String]))])
                        _prodsIsmInputDyns :: ([(String,(String,String))])
                        _prodsIsmInsDynsFuns :: ([(String, (String,Code.Type))])
                        _prodsIsmPrimTypes :: ([String])
                        _prodsIsmSelDynVals :: ([(String,(String,[String]))])
                        _prodsIsmTypeCons :: ([String])
                        _prodsIsmTypeConsTop :: ([String])
                        _prodsIsmdecls :: (Decls)
                        _prodsIup :: ([UseStream])
                        _prodsOderivings :: (Derivings)
                        _prodsOdown :: ([UseStream])
                        _prodsOnts' :: ([Name])
                        _prodsOo_cata :: (Bool)
                        _prodsOo_data :: (Bool)
                        _prodsOo_newtypes :: (Bool)
                        _prodsOo_pretty :: (Bool)
                        _prodsOo_rename :: (Bool)
                        _prodsOo_sem :: (Bool)
                        _prodsOo_sig :: (Bool)
                        _prodsOprefix :: (String)
                        _prodsOtypeSyns :: (TypeSyns)
                        _prodsOwrappers :: (Set Nonterminal)
                        ( _prodsIdecls,_prodsIerrors,_prodsInrChildren,_prodsInts,_prodsIsmCompDyns,_prodsIsmConstructors,_prodsIsmDynSels,_prodsIsmDynSemFuns,_prodsIsmInputDyns,_prodsIsmInsDynsFuns,_prodsIsmPrimTypes,_prodsIsmSelDynVals,_prodsIsmTypeCons,_prodsIsmTypeConsTop,_prodsIsmdecls,_prodsIup) =
                            (prods_ (_prodsOderivings) (_prodsOdown) (_prodsOnts') (_prodsOo_cata) (_prodsOo_data) (_prodsOo_newtypes) (_prodsOo_pretty) (_prodsOo_rename) (_prodsOo_sem) (_prodsOo_sig) (_prodsOprefix) (_prodsOtypeSyns) (_prodsOwrappers))
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOprefix@_) =
                            prefix    _lhsIoptions
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOo_newtypes@_) =
                            newtypes  _lhsIoptions
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOo_rename@_) =
                            rename    _lhsIoptions
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOo_sem@_) =
                            semfuns   _lhsIoptions
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOo_sig@_) =
                            typeSigs  _lhsIoptions
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOo_data@_) =
                            dataTypes _lhsIoptions
                        -- "GenerateCode.ag"(line 75, column 17)
                        (_prodsOo_cata@_) =
                            folds     _lhsIoptions
                        -- "GenerateCode.ag"(line 91, column 16)
                        (_lhsOprog@_) =
                            if smacro _lhsIoptions
                             then Program (_prodsIdecls ++ _smUnitDecl     ++ _prodsIsmdecls ++ _defnmdecls    )
                             else Program _prodsIdecls
                        -- "GenerateCode.ag"(line 143, column 13)
                        (_prodsOwrappers@_) =
                            wrappers_
                        -- "GenerateCode.ag"(line 143, column 13)
                        (_prodsOderivings@_) =
                            derivings_
                        -- "GenerateCode.ag"(line 143, column 13)
                        (_prodsOtypeSyns@_) =
                            typeSyns_
                        -- "GenerateCode.ag"(line 373, column 17)
                        (_prodsOnts'@_) =
                            _prodsInts
                        -- "./Comments.ag"(line 18, column 17)
                        (_o_pretty@_) =
                            attrInfo _lhsIoptions
                        -- "./Dep.ag"(line 58, column 13)
                        (_lhsOerrors@_) =
                            _errors Seq.<> _prodsIerrors
                        -- "./Dep.ag"(line 52, column 13)
                        (_errors@_) =
                            if withCycle _lhsIoptions
                             then getResult
                                . transpose
                                . map (\(vertex,stream) -> zip (repeat vertex) stream)
                                $ _prodsIup
                             else Seq.empty
                        -- "./Dep.ag"(line 51, column 13)
                        (_prodsOdown@_) =
                            _prodsIup
                        -- "./GenerateCodeSM.ag"(line 201, column 16)
                        (_lhsOsmdynlists@_) =
                            if   smacro _lhsIoptions
                            then (_imports    , _smTypeReps     ++ _smDefinitions    )
                            else ([],[])
                        -- "./GenerateCodeSM.ag"(line 198, column 16)
                        (_smDefinitions@_) =
                            _constructors     ++ _compDyns     ++ _inputDyns
                                      ++ _selDyns     ++ _selDynVals     ++ _dynSemFuns
                                      ++ _dynInsFuns
                        -- "./GenerateCodeSM.ag"(line 196, column 16)
                        (_smTypeReps@_) =
                            _types     ++ _dataTypeCon     ++ _instanceTypeDescr
                                        ++ _instanceShowF     ++ _tpConstants
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_defnmdecls@_) =
                            let n = _prodsInrChildren
                            in concat (map mk_def_nm_decls [1..n])
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_tpConstants@_) =
                            let datatype  tp    = "tp_" ++ tp ++ " = " ++ "TpCon (" ++ tp ++ "_tp  equal)"
                            in  map datatype _allTypes
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_instanceShowF@_) =
                            let datatype  tp    = "  showF (" ++ tp ++ "_tp  _) = " ++ show tp
                                inst            = "instance ShowF TypeCon where"
                            in  inst : map datatype _allTypes
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_instanceTypeDescr@_) =
                            let datatype tp     = "  match (" ++ tp ++ "_tp  x) (" ++ tp ++ "_tp  y) = Just (transInv x y)"
                                inst            = "instance TypeDescr TypeCon where"
                                noMatch         = "  match _        _        = Nothing"
                            in  inst : (map datatype _allTypes     ++ [noMatch])
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_dataTypeCon@_) =
                            let datatype tp     = tp++"_tp" ++ " (Equal a " ++  tpName tp ++ ")"
                                toText   alts   = let sp = map (const ' ') dataTp
                                                      dataTp = "data TypeCon a "
                                                  in printList dataTp (dataTp ++ "= ") "" (sp ++ "| ") alts
                                tpName tp = tp
                            in  toText (map datatype _allTypes    )
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_types@_) =
                            let datatype tp  = "(" ++ show tp ++ ", " ++ "E tp_" ++ argument tp ++ ")"
                                argument tp | identifier tp `elem` _prodsInts = smsdtype (identifier tp) ""
                                            | otherwise            = tp
                            in  "types ="
                                : spindent 4 (showAsList (map datatype _allTypesTop    ))
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_dynInsFuns@_) =
                            mkDynValList' "attr_inserters" _prodsIsmInsDynsFuns
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_dynSemFuns@_) =
                            mkDynValList "sem_constructors" _prodsIsmDynSemFuns
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_selDynVals@_) =
                            mkDynValList "attr_selectors" _prodsIsmSelDynVals
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_selDyns@_) =
                            mkDynValListExt "input_selectors" _prodsIsmDynSels
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_inputDyns@_) =
                            mkExistList "comp_inputs" _prodsIsmInputDyns
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_compDyns@_) =
                            mkDynValList "attr_computations" _prodsIsmCompDyns
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_constructors@_) =
                            mkDynValList "constructors" ((unit, (unit, [unittp])) : _prodsIsmConstructors)
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_imports@_) =
                            ["import DynamicTyping (Equal(..), TypeDescr(..), ShowF(..), Dynamic((:::))"
                            ,"                     , (.->.), equal, Type(..),transInv)"
                            ,"import SimpleStuff(Id (Id), Exists(E))"
                            ,"import UU.Pretty"
                            ,"import KnitCartNested"
                            ]
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_allTypes@_) =
                            nub (_smPrimTypes     ++ _prodsIsmTypeCons)
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_allTypesTop@_) =
                            nub (_smPrimTypes     ++ _prodsIsmTypeConsTop)
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_smUnitDecl@_) =
                            [Code.Type unittp (SimpleType unit)]
                        -- "./GenerateCodeSM.ag"(line 156, column 16)
                        (_smPrimTypes@_) =
                            nub (unittp : _prodsIsmPrimTypes)
                        -- copy rule (from local)
                        (_prodsOo_pretty@_) =
                            _o_pretty
                    in  ( _lhsOerrors,_lhsOprog,_lhsOsmdynlists)))
-- Pattern -----------------------------------------------------
{-
   inherited attributes:
      con                  : Identifier
      fields               : [(Name,Type)]
      nt                   : Identifier

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      locVars              : [Name]
      pp                   : PP_Doc
      pp'                  : PP_Doc
      vertices             : [Vertex]

-}
{-
   local variables for Pattern.Alias:

-}
{-
   local variables for Pattern.Constr:

-}
{-
   local variables for Pattern.Product:

-}
{-
   local variables for Pattern.Underscore:

-}
-- semantic domain
newtype T_Pattern = T_Pattern ((Identifier) ->
                               ([(Name,Type)]) ->
                               (Identifier) ->
                               ( (Seq Error),([Name]),(PP_Doc),(PP_Doc),([Vertex])))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Alias (_field) (_attr) (_pat))) =
    (sem_Pattern_Alias (_field) (_attr) ((sem_Pattern (_pat))))
sem_Pattern ((Constr (_name) (_pats))) =
    (sem_Pattern_Constr (_name) ((sem_Patterns (_pats))))
sem_Pattern ((Product (_pos) (_pats))) =
    (sem_Pattern_Product (_pos) ((sem_Patterns (_pats))))
sem_Pattern ((Underscore (_pos))) =
    (sem_Pattern_Underscore (_pos))
data Inh_Pattern = Inh_Pattern {con_Inh_Pattern :: Identifier,fields_Inh_Pattern :: [(Name,Type)],nt_Inh_Pattern :: Identifier}
data Syn_Pattern = Syn_Pattern {errors_Syn_Pattern :: Seq Error,locVars_Syn_Pattern :: [Name],pp_Syn_Pattern :: PP_Doc,pp'_Syn_Pattern :: PP_Doc,vertices_Syn_Pattern :: [Vertex]}
wrap_Pattern :: (T_Pattern) ->
                (Inh_Pattern) ->
                (Syn_Pattern)
wrap_Pattern ((T_Pattern (sem))) ((Inh_Pattern (i1) (i2) (i3))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2) (i3))
    in  (Syn_Pattern (s1) (s2) (s3) (s4) (s5))
sem_Pattern_Alias :: (Name) ->
                     (Name) ->
                     (T_Pattern) ->
                     (T_Pattern)
sem_Pattern_Alias (field_) (attr_) ((T_Pattern (pat_))) =
    (T_Pattern (\ _lhsIcon
                  _lhsIfields
                  _lhsInt ->
                    let _lhsOerrors :: (Seq Error)
                        _lhsOlocVars :: ([Name])
                        _lhsOpp :: (PP_Doc)
                        _lhsOpp' :: (PP_Doc)
                        _lhsOvertices :: ([Vertex])
                        _patIerrors :: (Seq Error)
                        _patIlocVars :: ([Name])
                        _patIpp :: (PP_Doc)
                        _patIpp' :: (PP_Doc)
                        _patIvertices :: ([Vertex])
                        _patOcon :: (Identifier)
                        _patOfields :: ([(Name,Type)])
                        _patOnt :: (Identifier)
                        ( _patIerrors,_patIlocVars,_patIpp,_patIpp',_patIvertices) =
                            (pat_ (_patOcon) (_patOfields) (_patOnt))
                        -- "GenerateCode.ag"(line 386, column 13)
                        (_lhsOpp@_) =
                            attrname False field_ attr_ >|< "@" >|< _patIpp
                        -- "./Comments.ag"(line 54, column 14)
                        (_lhsOlocVars@_) =
                            if field_ == _LOC
                               then [attr_]
                               else []
                        -- "./Dep.ag"(line 168, column 12)
                        (_lhsOvertices@_) =
                            let vertex | field_==_LHS = LHSSyn _lhsInt _lhsIcon attr_
                                       | field_==_LOC || field_ == nullIdent = Local _lhsInt  _lhsIcon attr_
                                       | otherwise    = RHSInh fieldType _lhsInt _lhsIcon field_ attr_
                                fieldType = maybe nullIdent getNonterminalName (lookup field_ _lhsIfields)
                            in [vertex]
                        -- "./GenerateCodeSM.ag"(line 410, column 13)
                        (_lhsOpp'@_) =
                            let attribute | field_ == _LOC || field_ == nullIdent = locname' attr_
                                          | otherwise                             = attrname False field_ attr_
                            in attribute >|< "@" >|< _patIpp'
                        -- use rule
                        (_lhsOerrors@_) =
                            _patIerrors
                        -- copy rule (down)
                        (_patOcon@_) =
                            _lhsIcon
                        -- copy rule (down)
                        (_patOfields@_) =
                            _lhsIfields
                        -- copy rule (down)
                        (_patOnt@_) =
                            _lhsInt
                    in  ( _lhsOerrors,_lhsOlocVars,_lhsOpp,_lhsOpp',_lhsOvertices)))
sem_Pattern_Constr :: (Constructor) ->
                      (T_Patterns) ->
                      (T_Pattern)
sem_Pattern_Constr (name_) ((T_Patterns (pats_))) =
    (T_Pattern (\ _lhsIcon
                  _lhsIfields
                  _lhsInt ->
                    let _lhsOerrors :: (Seq Error)
                        _lhsOlocVars :: ([Name])
                        _lhsOpp :: (PP_Doc)
                        _lhsOpp' :: (PP_Doc)
                        _lhsOvertices :: ([Vertex])
                        _patsIerrors :: (Seq Error)
                        _patsIlocVars :: ([Name])
                        _patsIpps :: ([PP_Doc])
                        _patsIpps' :: ([PP_Doc])
                        _patsIvertices :: ([Vertex])
                        _patsOcon :: (Identifier)
                        _patsOfields :: ([(Name,Type)])
                        _patsOnt :: (Identifier)
                        ( _patsIerrors,_patsIlocVars,_patsIpps,_patsIpps',_patsIvertices) =
                            (pats_ (_patsOcon) (_patsOfields) (_patsOnt))
                        -- "GenerateCode.ag"(line 384, column 13)
                        (_lhsOpp@_) =
                            pp_parens $ name_ >#< hv (map pp_parens _patsIpps)
                        -- "./GenerateCodeSM.ag"(line 408, column 13)
                        (_lhsOpp'@_) =
                            pp_parens $ name_ >#< hv (map pp_parens _patsIpps')
                        -- use rule
                        (_lhsOerrors@_) =
                            _patsIerrors
                        -- use rule
                        (_lhsOlocVars@_) =
                            _patsIlocVars
                        -- use rule
                        (_lhsOvertices@_) =
                            _patsIvertices
                        -- copy rule (down)
                        (_patsOcon@_) =
                            _lhsIcon
                        -- copy rule (down)
                        (_patsOfields@_) =
                            _lhsIfields
                        -- copy rule (down)
                        (_patsOnt@_) =
                            _lhsInt
                    in  ( _lhsOerrors,_lhsOlocVars,_lhsOpp,_lhsOpp',_lhsOvertices)))
sem_Pattern_Product :: (Pos) ->
                       (T_Patterns) ->
                       (T_Pattern)
sem_Pattern_Product (pos_) ((T_Patterns (pats_))) =
    (T_Pattern (\ _lhsIcon
                  _lhsIfields
                  _lhsInt ->
                    let _lhsOerrors :: (Seq Error)
                        _lhsOlocVars :: ([Name])
                        _lhsOpp :: (PP_Doc)
                        _lhsOpp' :: (PP_Doc)
                        _lhsOvertices :: ([Vertex])
                        _patsIerrors :: (Seq Error)
                        _patsIlocVars :: ([Name])
                        _patsIpps :: ([PP_Doc])
                        _patsIpps' :: ([PP_Doc])
                        _patsIvertices :: ([Vertex])
                        _patsOcon :: (Identifier)
                        _patsOfields :: ([(Name,Type)])
                        _patsOnt :: (Identifier)
                        ( _patsIerrors,_patsIlocVars,_patsIpps,_patsIpps',_patsIvertices) =
                            (pats_ (_patsOcon) (_patsOfields) (_patsOnt))
                        -- "GenerateCode.ag"(line 385, column 13)
                        (_lhsOpp@_) =
                            pp_block "(" ")" "," _patsIpps
                        -- "./GenerateCodeSM.ag"(line 409, column 13)
                        (_lhsOpp'@_) =
                            pp_block "(" ")" "," _patsIpps'
                        -- use rule
                        (_lhsOerrors@_) =
                            _patsIerrors
                        -- use rule
                        (_lhsOlocVars@_) =
                            _patsIlocVars
                        -- use rule
                        (_lhsOvertices@_) =
                            _patsIvertices
                        -- copy rule (down)
                        (_patsOcon@_) =
                            _lhsIcon
                        -- copy rule (down)
                        (_patsOfields@_) =
                            _lhsIfields
                        -- copy rule (down)
                        (_patsOnt@_) =
                            _lhsInt
                    in  ( _lhsOerrors,_lhsOlocVars,_lhsOpp,_lhsOpp',_lhsOvertices)))
sem_Pattern_Underscore :: (Pos) ->
                          (T_Pattern)
sem_Pattern_Underscore (pos_) =
    (T_Pattern (\ _lhsIcon
                  _lhsIfields
                  _lhsInt ->
                    let _lhsOerrors :: (Seq Error)
                        _lhsOlocVars :: ([Name])
                        _lhsOpp :: (PP_Doc)
                        _lhsOpp' :: (PP_Doc)
                        _lhsOvertices :: ([Vertex])
                        -- "GenerateCode.ag"(line 387, column 16)
                        (_lhsOpp@_) =
                            text "_"
                        -- "./GenerateCodeSM.ag"(line 413, column 16)
                        (_lhsOpp'@_) =
                            text "_"
                        -- use rule
                        (_lhsOerrors@_) =
                            Seq.empty
                        -- use rule
                        (_lhsOlocVars@_) =
                            []
                        -- use rule
                        (_lhsOvertices@_) =
                            []
                    in  ( _lhsOerrors,_lhsOlocVars,_lhsOpp,_lhsOpp',_lhsOvertices)))
-- Patterns ----------------------------------------------------
{-
   inherited attributes:
      con                  : Identifier
      fields               : [(Name,Type)]
      nt                   : Identifier

   chained attributes:

   synthesised attributes:
      errors               : Seq Error
      locVars              : [Name]
      pps                  : [PP_Doc]
      pps'                 : [PP_Doc]
      vertices             : [Vertex]

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
newtype T_Patterns = T_Patterns ((Identifier) ->
                                 ([(Name,Type)]) ->
                                 (Identifier) ->
                                 ( (Seq Error),([Name]),([PP_Doc]),([PP_Doc]),([Vertex])))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
data Inh_Patterns = Inh_Patterns {con_Inh_Patterns :: Identifier,fields_Inh_Patterns :: [(Name,Type)],nt_Inh_Patterns :: Identifier}
data Syn_Patterns = Syn_Patterns {errors_Syn_Patterns :: Seq Error,locVars_Syn_Patterns :: [Name],pps_Syn_Patterns :: [PP_Doc],pps'_Syn_Patterns :: [PP_Doc],vertices_Syn_Patterns :: [Vertex]}
wrap_Patterns :: (T_Patterns) ->
                 (Inh_Patterns) ->
                 (Syn_Patterns)
wrap_Patterns ((T_Patterns (sem))) ((Inh_Patterns (i1) (i2) (i3))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2) (i3))
    in  (Syn_Patterns (s1) (s2) (s3) (s4) (s5))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons ((T_Pattern (hd_))) ((T_Patterns (tl_))) =
    (T_Patterns (\ _lhsIcon
                   _lhsIfields
                   _lhsInt ->
                     let _lhsOerrors :: (Seq Error)
                         _lhsOlocVars :: ([Name])
                         _lhsOpps :: ([PP_Doc])
                         _lhsOpps' :: ([PP_Doc])
                         _lhsOvertices :: ([Vertex])
                         _hdIerrors :: (Seq Error)
                         _hdIlocVars :: ([Name])
                         _hdIpp :: (PP_Doc)
                         _hdIpp' :: (PP_Doc)
                         _hdIvertices :: ([Vertex])
                         _hdOcon :: (Identifier)
                         _hdOfields :: ([(Name,Type)])
                         _hdOnt :: (Identifier)
                         _tlIerrors :: (Seq Error)
                         _tlIlocVars :: ([Name])
                         _tlIpps :: ([PP_Doc])
                         _tlIpps' :: ([PP_Doc])
                         _tlIvertices :: ([Vertex])
                         _tlOcon :: (Identifier)
                         _tlOfields :: ([(Name,Type)])
                         _tlOnt :: (Identifier)
                         ( _hdIerrors,_hdIlocVars,_hdIpp,_hdIpp',_hdIvertices) =
                             (hd_ (_hdOcon) (_hdOfields) (_hdOnt))
                         ( _tlIerrors,_tlIlocVars,_tlIpps,_tlIpps',_tlIvertices) =
                             (tl_ (_tlOcon) (_tlOfields) (_tlOnt))
                         -- "GenerateCode.ag"(line 380, column 10)
                         (_lhsOpps@_) =
                             _hdIpp : _tlIpps
                         -- "./GenerateCodeSM.ag"(line 404, column 10)
                         (_lhsOpps'@_) =
                             _hdIpp' : _tlIpps'
                         -- use rule
                         (_lhsOerrors@_) =
                             _hdIerrors Seq.<> _tlIerrors
                         -- use rule
                         (_lhsOlocVars@_) =
                             _hdIlocVars ++ _tlIlocVars
                         -- use rule
                         (_lhsOvertices@_) =
                             _hdIvertices ++ _tlIvertices
                         -- copy rule (down)
                         (_hdOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_hdOfields@_) =
                             _lhsIfields
                         -- copy rule (down)
                         (_hdOnt@_) =
                             _lhsInt
                         -- copy rule (down)
                         (_tlOcon@_) =
                             _lhsIcon
                         -- copy rule (down)
                         (_tlOfields@_) =
                             _lhsIfields
                         -- copy rule (down)
                         (_tlOnt@_) =
                             _lhsInt
                     in  ( _lhsOerrors,_lhsOlocVars,_lhsOpps,_lhsOpps',_lhsOvertices)))
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil  =
    (T_Patterns (\ _lhsIcon
                   _lhsIfields
                   _lhsInt ->
                     let _lhsOerrors :: (Seq Error)
                         _lhsOlocVars :: ([Name])
                         _lhsOpps :: ([PP_Doc])
                         _lhsOpps' :: ([PP_Doc])
                         _lhsOvertices :: ([Vertex])
                         -- "GenerateCode.ag"(line 381, column 10)
                         (_lhsOpps@_) =
                             []
                         -- "./GenerateCodeSM.ag"(line 405, column 10)
                         (_lhsOpps'@_) =
                             []
                         -- use rule
                         (_lhsOerrors@_) =
                             Seq.empty
                         -- use rule
                         (_lhsOlocVars@_) =
                             []
                         -- use rule
                         (_lhsOvertices@_) =
                             []
                     in  ( _lhsOerrors,_lhsOlocVars,_lhsOpps,_lhsOpps',_lhsOvertices)))
-- Production --------------------------------------------------
{-
   inherited attributes:
      derivings            : Derivings
      down                 : [UseStream]
      nts'                 : [Name]
      o_cata               : Bool
      o_data               : Bool
      o_newtypes           : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      prefix               : String
      typeSyns             : TypeSyns
      wrappers             : Set Nonterminal

   chained attributes:

   synthesised attributes:
      decls                : Decls
      errors               : Seq Error
      nrChildren           : Int
      nts                  : [Name]
      smCompDyns           : [(String,(String,[String]))]
      smConstructors       : [(String,(String,[String]))]
      smDynSels            : [(String,(String,String,[String]))]
      smDynSemFuns         : [(String,(String,[String]))]
      smInputDyns          : [(String,(String,String))]
      smInsDynsFuns        : [(String, (String,Code.Type))]
      smPrimTypes          : [String]
      smSelDynVals         : [(String,(String,[String]))]
      smTypeCons           : [String]
      smTypeConsTop        : [String]
      smdecls              : Decls
      up                   : [UseStream]

-}
{-
   local variables for Production.Production:
      semWrapper
      dataDef
      semDom
      cataFun
      comment
      si
      is
      smTpCons
      smSemDom
      smCataFun
      smSelInsFuns
      smInputDyn
      inhInsDyns
      synInsDyns
      synInsComp
      inhInsComp
      smInhSelDyn
      smSynSelDyn
      synTupSel
      inhTupSel
      inhSelDynVals
      synSelDynVals
      inhSel
      synSel
      inhIns
      synIns

-}
-- semantic domain
newtype T_Production = T_Production ((Derivings) ->
                                     ([UseStream]) ->
                                     ([Name]) ->
                                     (Bool) ->
                                     (Bool) ->
                                     (Bool) ->
                                     (Bool) ->
                                     (Bool) ->
                                     (Bool) ->
                                     (Bool) ->
                                     (String) ->
                                     (TypeSyns) ->
                                     (Set Nonterminal) ->
                                     ( (Decls),(Seq Error),(Int),([Name]),([(String,(String,[String]))]),([(String,(String,[String]))]),([(String,(String,String,[String]))]),([(String,(String,[String]))]),([(String,(String,String))]),([(String, (String,Code.Type))]),([String]),([(String,(String,[String]))]),([String]),([String]),(Decls),([UseStream])))
-- cata
sem_Production :: (Production) ->
                  (T_Production)
sem_Production ((Production (_nt) (_inh) (_syn) (_alts))) =
    (sem_Production_Production (_nt) (_inh) (_syn) ((sem_Alternatives (_alts))))
data Inh_Production = Inh_Production {derivings_Inh_Production :: Derivings
                                     ,down_Inh_Production :: [UseStream]
                                     ,nts'_Inh_Production :: [Name]
                                     ,o_cata_Inh_Production :: Bool
                                     ,o_data_Inh_Production :: Bool
                                     ,o_newtypes_Inh_Production :: Bool
                                     ,o_pretty_Inh_Production :: Bool
                                     ,o_rename_Inh_Production :: Bool
                                     ,o_sem_Inh_Production :: Bool
                                     ,o_sig_Inh_Production :: Bool
                                     ,prefix_Inh_Production :: String
                                     ,typeSyns_Inh_Production :: TypeSyns
                                     ,wrappers_Inh_Production :: Set Nonterminal
                                     }
data Syn_Production = Syn_Production {decls_Syn_Production :: Decls
                                     ,errors_Syn_Production :: Seq Error
                                     ,nrChildren_Syn_Production :: Int
                                     ,nts_Syn_Production :: [Name]
                                     ,smCompDyns_Syn_Production :: [(String,(String,[String]))]
                                     ,smConstructors_Syn_Production :: [(String,(String,[String]))]
                                     ,smDynSels_Syn_Production :: [(String,(String,String,[String]))]
                                     ,smDynSemFuns_Syn_Production :: [(String,(String,[String]))]
                                     ,smInputDyns_Syn_Production :: [(String,(String,String))]
                                     ,smInsDynsFuns_Syn_Production :: [(String, (String,Code.Type))]
                                     ,smPrimTypes_Syn_Production :: [String]
                                     ,smSelDynVals_Syn_Production :: [(String,(String,[String]))]
                                     ,smTypeCons_Syn_Production :: [String]
                                     ,smTypeConsTop_Syn_Production :: [String]
                                     ,smdecls_Syn_Production :: Decls
                                     ,up_Syn_Production :: [UseStream]
                                     }
wrap_Production :: (T_Production) ->
                   (Inh_Production) ->
                   (Syn_Production)
wrap_Production ((T_Production (sem))) ((Inh_Production (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12) (i13))) =
    let ( s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12) (i13))
    in  (Syn_Production (s1) (s2) (s3) (s4) (s5) (s6) (s7) (s8) (s9) (s10) (s11) (s12) (s13) (s14) (s15) (s16))
sem_Production_Production :: (Nonterminal) ->
                             (Attributes) ->
                             (Attributes) ->
                             (T_Alternatives) ->
                             (T_Production)
sem_Production_Production (nt_) (inh_) (syn_) ((T_Alternatives (alts_))) =
    (T_Production (\ _lhsIderivings
                     _lhsIdown
                     _lhsInts'
                     _lhsIo_cata
                     _lhsIo_data
                     _lhsIo_newtypes
                     _lhsIo_pretty
                     _lhsIo_rename
                     _lhsIo_sem
                     _lhsIo_sig
                     _lhsIprefix
                     _lhsItypeSyns
                     _lhsIwrappers ->
                       let _lhsOdecls :: (Decls)
                           _lhsOerrors :: (Seq Error)
                           _lhsOnrChildren :: (Int)
                           _lhsOnts :: ([Name])
                           _lhsOsmCompDyns :: ([(String,(String,[String]))])
                           _lhsOsmConstructors :: ([(String,(String,[String]))])
                           _lhsOsmDynSels :: ([(String,(String,String,[String]))])
                           _lhsOsmDynSemFuns :: ([(String,(String,[String]))])
                           _lhsOsmInputDyns :: ([(String,(String,String))])
                           _lhsOsmInsDynsFuns :: ([(String, (String,Code.Type))])
                           _lhsOsmPrimTypes :: ([String])
                           _lhsOsmSelDynVals :: ([(String,(String,[String]))])
                           _lhsOsmTypeCons :: ([String])
                           _lhsOsmTypeConsTop :: ([String])
                           _lhsOsmdecls :: (Decls)
                           _lhsOup :: ([UseStream])
                           _altsIcataAlts :: (Decls)
                           _altsIcomments :: (Decls)
                           _altsIdataAlts :: (DataAlts)
                           _altsIerrors :: (Seq Error)
                           _altsInrChildren :: (Int)
                           _altsIsemFuns :: (Decls)
                           _altsIsmCataAlts :: (Decls)
                           _altsIsmCompDyns :: ([(String,(String,[String]))])
                           _altsIsmConstructors :: ([(String,(String,[String]))])
                           _altsIsmDynSels :: ([(String,(String,String,[String]))])
                           _altsIsmDynSemFuns :: ([(String,(String,[String]))])
                           _altsIsmInputDyns :: ([(String,(String,String))])
                           _altsIsmInsDyns :: ([(String,(String,Code.Type))])
                           _altsIsmPrimTypes :: ([String])
                           _altsIsmSelFuns :: (Decls)
                           _altsIsmSemFuns :: (Decls)
                           _altsIsmTypeCons :: ([String])
                           _altsIup :: ([UseStream])
                           _altsOdown :: ([UseStream])
                           _altsOinh :: (Attributes)
                           _altsOnt :: (Identifier)
                           _altsOnts' :: ([Name])
                           _altsOo_cata :: (Bool)
                           _altsOo_newtypes :: (Bool)
                           _altsOo_pretty :: (Bool)
                           _altsOo_rename :: (Bool)
                           _altsOo_sem :: (Bool)
                           _altsOo_sig :: (Bool)
                           _altsOprefix :: (String)
                           _altsOsyn :: (Attributes)
                           ( _altsIcataAlts,_altsIcomments,_altsIdataAlts,_altsIerrors,_altsInrChildren,_altsIsemFuns,_altsIsmCataAlts,_altsIsmCompDyns,_altsIsmConstructors,_altsIsmDynSels,_altsIsmDynSemFuns,_altsIsmInputDyns,_altsIsmInsDyns,_altsIsmPrimTypes,_altsIsmSelFuns,_altsIsmSemFuns,_altsIsmTypeCons,_altsIup) =
                               (alts_ (_altsOdown) (_altsOinh) (_altsOnt) (_altsOnts') (_altsOo_cata) (_altsOo_newtypes) (_altsOo_pretty) (_altsOo_rename) (_altsOo_sem) (_altsOo_sig) (_altsOprefix) (_altsOsyn))
                           -- "GenerateCode.ag"(line 58, column 16)
                           (_altsOnt@_) =
                               nt_
                           -- "GenerateCode.ag"(line 63, column 16)
                           (_altsOsyn@_) =
                               syn_
                           -- "GenerateCode.ag"(line 62, column 16)
                           (_altsOinh@_) =
                               inh_
                           -- "GenerateCode.ag"(line 97, column 17)
                           (_lhsOdecls@_) =
                               Comment (getName nt_ ++ " " ++ replicate (60 - length (getName nt_)) '-') :
                               (if _lhsIo_pretty then _comment     : _altsIcomments else []) ++
                               (if _lhsIo_data then [_dataDef    ] else []) ++
                               (if _lhsIo_sig || _lhsIo_sem then _semDom      else []) ++
                               (if _lhsIo_cata then _cataFun     else []) ++
                               (if Set.member nt_ _lhsIwrappers then _semWrapper     else []) ++
                               (if _lhsIo_sem  then _altsIsemFuns else [])
                           -- "GenerateCode.ag"(line 114, column 16)
                           (_semWrapper@_) =
                               let inhAttrs = Map.toList inh_
                                   synAttrs = Map.toList syn_
                                   inhNT = "Inh" ++ "_" ++ getName nt_
                                   synNT = "Syn" ++ "_" ++ getName nt_
                                   wrapNT = "wrap" ++ "_" ++ getName nt_
                                   mkdata n attrs = Data n [Record n [(getName f++"_"++n,typeToString nt_ t) | (f,t) <- attrs]] []
                                   datas = [mkdata inhNT inhAttrs, mkdata synNT synAttrs]
                                   typeSig = TSig wrapNT (SimpleType (sdtype nt_) `Arr` (SimpleType inhNT `Arr` SimpleType synNT))
                                   function = let var = "sem"
                                                  varPat = if _lhsIo_newtypes
                                                              then App (sdtype nt_) [SimpleExpr var]
                                                              else SimpleExpr var
                                                  inhVars = [ SimpleExpr ("i" ++ show x) | x <- take (length inhAttrs) [1..]]
                                                  synVarsN = [ ("s" ++ show x) | x <- take (length synAttrs) [1..]]
                                                  synVarsE = map SimpleExpr synVarsN
                                              in Decl (Fun wrapNT [varPat, App inhNT inhVars])
                                                      (Let [Decl (TupleLhs synVarsN) (App var inhVars) | not(null synVarsN)]
                                                       (App synNT synVarsE))
                               in datas ++ (if _lhsIo_sig then [typeSig] else []) ++ [function]
                           -- "GenerateCode.ag"(line 148, column 16)
                           (_dataDef@_) =
                               let typeSyn tp = let theType =
                                                     case tp of
                                                       CommonTypes.Maybe t  -> SimpleType ("Maybe (" ++ typeToString nt_ t ++")")
                                                       CommonTypes.List t   -> Code.List $ SimpleType (typeToString nt_ t)
                                                       CommonTypes.Tuple ts -> Code.TupleType [SimpleType (typeToString nt_ t)
                                                                                              | (_,t) <- ts
                                                                                              ]
                                                in Code.Type (getName nt_) theType
                                   derivings  = maybe [] (map getName . Set.toList) (Map.lookup nt_ _lhsIderivings)
                                   dataDef    = Data (getName nt_) _altsIdataAlts derivings
                               in maybe dataDef typeSyn $ lookup nt_ _lhsItypeSyns
                           -- "GenerateCode.ag"(line 165, column 17)
                           (_semDom@_) =
                               let tp = foldr Arr synTps inhTps
                                   synTps = TupleType [SimpleType (typeToString nt_ tp) |  tp <- Map.elems syn_]
                                   inhTps = [SimpleType (typeToString nt_ tp) |  tp <- Map.elems inh_]
                               in [ Comment "semantic domain"
                                  , if _lhsIo_newtypes
                                       then NewType (sdtype nt_) (sdtype nt_) tp
                                       else Code.Type (sdtype nt_) tp
                                  ]
                           -- "GenerateCode.ag"(line 177, column 16)
                           (_cataFun@_) =
                               let tSig = TSig (cataname _lhsIprefix nt_)
                                               (SimpleType (getName nt_) `Arr` SimpleType (sdtype nt_))
                                   special typ = case typ of
                                                 CommonTypes.List tp ->
                                                     let cons = SimpleExpr (semname _lhsIprefix nt_ (identifier "Cons"))
                                                         nil  = SimpleExpr (semname _lhsIprefix nt_ (identifier "Nil" ))
                                                         arg  = SimpleExpr "list"
                                                         rarg = case tp of
                                                                  NT t  -> SimpleExpr ("(map " ++ (cataname _lhsIprefix t) ++ " list)")
                                                                  _     -> arg
                                                         lhs = Fun (cataname _lhsIprefix nt_) [arg]
                                                         rhs = (App "foldr" [cons,nil,rarg])
                                                     in  [Decl lhs rhs]
                                                 CommonTypes.Maybe tp ->
                                                     let just    = semname _lhsIprefix nt_ (identifier "Just")
                                                         nothing = semname _lhsIprefix nt_ (identifier "Nothing" )
                                                         arg  = SimpleExpr "x"
                                                         rarg = case tp of
                                                                  NT t  -> App (cataname _lhsIprefix t) [arg]
                                                                  _     -> arg
                                                         lhs a = Fun (cataname _lhsIprefix nt_) [a]
                                                     in  [Decl (lhs (App "Just" [arg]))     (App just [rarg])
                                                         ,Decl (lhs (SimpleExpr "Nothing")) (SimpleExpr nothing)
                                                         ]
                                                 CommonTypes.Tuple tps ->
                                                     let con  = semname _lhsIprefix nt_ (identifier "Tuple")
                                                         tps' = [ (SimpleExpr (getName x),y) | (x,y) <- tps]
                                                         rargs = map rarg tps'
                                                         rarg (n, tp) = case tp of
                                                                  NT t  -> App (cataname _lhsIprefix t) [n]
                                                                  _     -> n
                                                         lhs = Fun (cataname _lhsIprefix nt_) [TupleExpr (map fst tps')]
                                                         rhs = App con rargs
                                                     in  [Decl lhs rhs]
                               in  Comment "cata" :
                                   (if _lhsIo_sig then [tSig] else []) ++
                                   maybe _altsIcataAlts special (lookup nt_ _lhsItypeSyns)
                           -- "GenerateCode.ag"(line 370, column 17)
                           (_lhsOnts@_) =
                               [nt_]
                           -- "./Comments.ag"(line 21, column 17)
                           (_comment@_) =
                               let syn'     = map toString (Map.toList syn_)
                                   inh'     = map toString (Map.toList inh_)
                                   toString (a,t) = (getName a, case t of (NT nt) -> getName nt; Haskell t -> t)
                                   chnn     = inh' `intersect` syn'
                                   inhn     = inh' \\ chnn
                                   synn     = syn' \\ chnn
                               in Comment . unlines $
                                  [ replicate 3 ' ' ++ "inherited attributes:"
                                  , unlines . map ((replicate 6 ' ')++) .
                                        map (\(x,y) -> x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) $ inhn
                                  , replicate 3 ' ' ++ "chained attributes:"
                                  , unlines . map ((replicate 6 ' ')++) .
                                        map (\(x,y) -> x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) $ chnn
                                  , replicate 3 ' ' ++ "synthesised attributes:"
                                  , unlines . map ((replicate 6 ' ')++) .
                                        map (\(x,y) -> x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) $ synn
                                  ]
                           -- "./Dep.ag"(line 80, column 16)
                           (_lhsOup@_) =
                               _altsIup ++ _is ++ _si
                           -- "./Dep.ag"(line 78, column 16)
                           (_si@_) =
                               [let v = NTInh nt_ inh in (v, prod2stream v _lhsIdown) | inh<-(Map.keys inh_)]
                           -- "./Dep.ag"(line 78, column 16)
                           (_is@_) =
                               [let v = NTSyn nt_ syn in (v, prod2stream v _lhsIdown) | syn<-(Map.keys syn_)]
                           -- "./GenerateCodeSM.ag"(line 236, column 17)
                           (_lhsOsmdecls@_) =
                               Comment (getName nt_ ++ " " ++ replicate (60 - length (getName nt_)) '-') :
                               (_smCataFun    ) ++
                               (_altsIsmSemFuns) ++
                               (_smSemDom    ) ++
                               [Comment (getName nt_ ++ " SM Functions" ++ replicate (60 - length (getName nt_)) '-')] ++
                               (_smSelInsFuns    )
                           -- "./GenerateCodeSM.ag"(line 263, column 17)
                           (_lhsOsmPrimTypes@_) =
                               _altsIsmPrimTypes
                           -- "./GenerateCodeSM.ag"(line 262, column 17)
                           (_lhsOsmTypeConsTop@_) =
                               getName nt_ : map (typeToString nt_)  (Map.elems syn_ ++ Map.elems inh_)
                           -- "./GenerateCodeSM.ag"(line 261, column 17)
                           (_lhsOsmTypeCons@_) =
                               _smTpCons     ++ _altsIsmTypeCons ++ map (typeToString nt_)(Map.elems syn_ ++ Map.elems inh_)
                           -- "./GenerateCodeSM.ag"(line 259, column 17)
                           (_smTpCons@_) =
                               let mkTpNm post = smsdtype nt_ post
                               in  [mkTpNm "syn", mkTpNm "inh", mkTpNm "input", mkTpNm "", getName nt_]
                           -- "./GenerateCodeSM.ag"(line 247, column 17)
                           (_smSemDom@_) =
                               let tp = Arr inhTps synTps
                                   synTps = tupnestTp [SimpleType (typeToString nt_ tp) |  tp <- Map.elems syn_]
                                   inhTps = tupnestTp [SimpleType (typeToString nt_ tp) |  tp <- Map.elems inh_]
                                   inputTp = TupleType [inhTps, synTps]
                                   mkTp tp post = Code.Type (smsdtype nt_ post) tp
                               in [ Comment "sm semantic domain"
                                  , mkTp tp ""
                                  , mkTp synTps "syn"
                                  , mkTp inhTps "inh"
                                  , mkTp inputTp "input"
                                  , mkTp (SimpleType unit) "loc"
                                  ]
                           -- "./GenerateCodeSM.ag"(line 269, column 16)
                           (_smCataFun@_) =
                               let tSig = TSig (smcataname _lhsIprefix nt_)
                                             (SimpleType (getName nt_) `Arr` SimpleType (smsdtype nt_ ""))
                                   special typ = case typ of
                                               CommonTypes.List tp ->
                                                   let cons = SimpleExpr (semname _lhsIprefix nt_ (identifier "Cons"))
                                                       nil  = SimpleExpr (semname _lhsIprefix nt_ (identifier "Nil" ))
                                                       arg  = SimpleExpr "list"
                                                       rarg = case tp of
                                                                NT t  -> SimpleExpr ("(map " ++ (smcataname _lhsIprefix t) ++ " list)")
                                                                _     -> arg
                                                       lhs = Fun (smcataname _lhsIprefix nt_) [arg]
                                                       rhs = (App "foldr" [cons,nil,rarg])
                                                   in  [Decl lhs rhs]
                                               CommonTypes.Maybe tp ->
                                                   let just    = semname _lhsIprefix nt_ (identifier "Just")
                                                       nothing = semname _lhsIprefix nt_ (identifier "Nothing" )
                                                       arg  = SimpleExpr "x"
                                                       rarg = case tp of
                                                                NT t  -> App (smcataname _lhsIprefix t) [arg]
                                                                _     -> arg
                                                       lhs a = Fun (smcataname _lhsIprefix nt_) [a]
                                                   in  [Decl (lhs (App "Just" [arg]))     (App just [rarg])
                                                       ,Decl (lhs (SimpleExpr "Nothing")) (SimpleExpr nothing)
                                                       ]
                                               CommonTypes.Tuple tps ->
                                                   let con  = semname _lhsIprefix nt_ (identifier "Tuple")
                                                       tps' = [ (SimpleExpr (getName x),y) | (x,y) <- tps]
                                                       rargs = map rarg tps'
                                                       rarg (n, tp) = case tp of
                                                                NT t  -> App (smcataname _lhsIprefix t) [n]
                                                                _     -> n
                                                       lhs = Fun (smcataname _lhsIprefix nt_) [TupleExpr (map fst tps')]
                                                       rhs = App con rargs
                                                   in  [Decl lhs rhs]
                               in  Comment "sm cata" :
                                   (if _lhsIo_sig then [tSig] else []) ++
                                    maybe _altsIsmCataAlts special (lookup nt_ _lhsItypeSyns)
                           -- "./GenerateCodeSM.ag"(line 787, column 28)
                           (_lhsOsmInsDynsFuns@_) =
                               _altsIsmInsDyns ++ _inhInsDyns     ++ _synInsDyns
                           -- "./GenerateCodeSM.ag"(line 786, column 16)
                           (_lhsOsmSelDynVals@_) =
                               _inhSelDynVals     ++ _synSelDynVals
                           -- "./GenerateCodeSM.ag"(line 785, column 28)
                           (_lhsOsmDynSels@_) =
                               _smSynSelDyn     : _smInhSelDyn     : _altsIsmDynSels
                           -- "./GenerateCodeSM.ag"(line 782, column 16)
                           (_smSelInsFuns@_) =
                               _inhTupSel     ++ _synTupSel     ++ _synInsComp     ++
                               _inhInsComp     ++ _synIns     ++ _inhIns     ++ _synSel
                                ++ _inhSel     ++ _altsIsmSelFuns
                           -- "./GenerateCodeSM.ag"(line 781, column 16)
                           (_lhsOsmInputDyns@_) =
                               _smInputDyn     : _altsIsmInputDyns
                           -- "./GenerateCodeSM.ag"(line 777, column 16)
                           (_smInputDyn@_) =
                               let nm = smsdtype nt_ ""
                                   varnm = "_gen_var_prod_" ++ map toLower nm
                                   tpnm = smsdtype nt_ "input"
                                in (nm, (varnm,tpnm))
                           -- "./GenerateCodeSM.ag"(line 767, column 17)
                           (_inhInsDyns@_) =
                               let inhAttrs = zip (Map.keys inh_) (Map.elems inh_)
                                   ident a = (smsdtype nt_ "") ++ "_inh_" ++ getName a
                                   fname a = insertnm nt_ (identifier "comp") a
                                   inpArg t  = let tp = typeToString nt_ t
                                               in Arr (SimpleType (smsdtype nt_ "input"))
                                                   (SimpleType tp)
                                   arg tp = let btp = SimpleType (smsdtype nt_ "")
                                            in  Arr (inpArg tp) (Arr btp btp)
                               in  map (\(s,tp) -> (ident s, (fname s, arg tp))) inhAttrs
                           -- "./GenerateCodeSM.ag"(line 758, column 17)
                           (_synInsDyns@_) =
                               let synAttrs = zip (Map.keys syn_) (Map.elems syn_)
                                   ident a = (smsdtype nt_ "") ++ "_lhs_" ++ getName a
                                   fname a = insertnm nt_ (identifier "comp") a
                                   inpArg t = let tp = typeToString nt_ t
                                              in Arr (SimpleType (smsdtype nt_ "input"))
                                                   (SimpleType tp)
                                   arg tp = let btp = SimpleType (smsdtype nt_ "")
                                            in  Arr (inpArg tp) (Arr btp btp)
                               in  map (\(s,tp) -> (ident s, (fname s, arg tp))) synAttrs
                           -- "./GenerateCodeSM.ag"(line 739, column 16)
                           (_synInsComp@_) =
                               let mklhs syn = Fun (insertnm nt_ (identifier "comp") syn) funargs
                                   synAttrs = Map.keys syn_
                                   inhsyn = "_inh2syn_"
                                   funargs = [ SimpleExpr "_syn_", SimpleExpr inhsyn ]
                                   mkrhs syn = let rhsbody = Let [decl] letbody
                                                   decl = Decl (Fun syn' [])
                                                               (App inhsyn [SimpleExpr pi])
                                                   letbody = App (insertnm nt_ nullIdent syn)
                                                                 [ App "_syn_"
                                                                    [TupleExpr [ SimpleExpr pi
                                                                               , SimpleExpr syn'
                                                                               ]
                                                                    ]
                                                                  , SimpleExpr syn'
                                                                 ]
                                                   syn' = "_syn_new"
                                                   pi = "_parent_in"
                                               in  Lambda [pi] rhsbody
                               in  map (\s -> Decl (mklhs s) (mkrhs s)) synAttrs
                           -- "./GenerateCodeSM.ag"(line 717, column 16)
                           (_inhInsComp@_) =
                               let mklhs inh = Fun (insertnm nt_ (identifier "comp") inh) funargs
                                   inhAttrs = Map.keys inh_
                                   inhsyn = "_inh2syn_"
                                   funargs = [ SimpleExpr "_inh_", SimpleExpr inhsyn ]
                                   mkrhs inh = let rhsbody = Let [decl, decl'] letbody
                                                   decl = Decl (Fun inh' [])
                                                               (App (insertnm nt_ nullIdent inh)
                                                                    [ App "_inh_"
                                                                      [TupleExpr [ SimpleExpr pi
                                                                                 , SimpleExpr syn'
                                                                                 ]
                                                                      ]
                                                                    , SimpleExpr pi]
                                                               )
                                                   decl' = Decl (Fun syn' [])
                                                                (App inhsyn [SimpleExpr pi])
                                                   letbody = App inhsyn [SimpleExpr inh']
                                                   inh' = "_inh_new"
                                                   syn' = "_syn_old"
                                                   pi = "_parent_in"
                                               in  Lambda [pi] rhsbody
                               in  map (\s -> Decl (mklhs s) (mkrhs s)) inhAttrs
                           -- "./GenerateCodeSM.ag"(line 712, column 16)
                           (_smInhSelDyn@_) =
                               let ident = (smsdtype nt_ "") ++ "_inh"
                                   nm = selectnm nt_ nullIdent (identifier "inhAttrTuple")
                                   args = [(smsdtype nt_ "input"),
                                                     (smsdtype nt_ "inh")]
                               in  (ident,(getName nt_,nm,args))
                           -- "./GenerateCodeSM.ag"(line 707, column 16)
                           (_smSynSelDyn@_) =
                               let ident = (smsdtype nt_ "") ++ "_syn"
                                   nm = selectnm nt_ nullIdent (identifier "synAttrTuple")
                                   args = [(smsdtype nt_ "input"),
                                                     (smsdtype nt_ "syn")]
                               in  (ident,(getName nt_,nm,args))
                           -- "./GenerateCodeSM.ag"(line 704, column 16)
                           (_synTupSel@_) =
                               let lhs = Fun (selectnm nt_ nullIdent (identifier "synAttrTuple")) []
                                   rhs = SimpleExpr "snd"
                               in  [Decl lhs rhs]
                           -- "./GenerateCodeSM.ag"(line 701, column 16)
                           (_inhTupSel@_) =
                               let lhs = Fun (selectnm nt_ nullIdent (identifier "inhAttrTuple")) []
                                   rhs = SimpleExpr "fst"
                               in  [Decl lhs rhs]
                           -- "./GenerateCodeSM.ag"(line 694, column 16)
                           (_inhSelDynVals@_) =
                               let fident a = getName nt_ ++ "_" ++ getName a
                                   fnm a = selectnm nt_ nullIdent a
                                   fargs atp = [smsdtype nt_ "inh",
                                                (typeToString nt_ atp)]
                                   fdyn (a,atp) = (fident a, (fnm a, fargs atp))
                                   inhAttrs = zip (Map.keys inh_) (Map.elems inh_)
                                                               in  map fdyn inhAttrs
                           -- "./GenerateCodeSM.ag"(line 687, column 16)
                           (_synSelDynVals@_) =
                               let fident a = getName nt_ ++ "_" ++ getName a
                                   fnm a = selectnm nt_ nullIdent a
                                   fargs atp = [smsdtype nt_ "syn",
                                                (typeToString nt_ atp)]
                                   fdyn (a,atp) = (fident a, (fnm a, fargs atp))
                                   synAttrs = zip (Map.keys syn_) (Map.elems syn_)
                                                               in  map fdyn synAttrs
                           -- "./GenerateCodeSM.ag"(line 681, column 16)
                           (_inhSel@_) =
                               let mklhs inh = Fun (selectnm nt_ nullIdent inh) funargs
                                   inhAttrs = Map.keys inh_
                                   nestedProd = tupnest (map (SimpleExpr . getName) inhAttrs)
                                   funargs = [ nestedProd ]
                                   mkrhs inh = SimpleExpr (getName inh)
                               in  map (\s -> Decl (mklhs s) (mkrhs s)) inhAttrs
                           -- "./GenerateCodeSM.ag"(line 675, column 16)
                           (_synSel@_) =
                               let mklhs syn = Fun (selectnm nt_ nullIdent syn) funargs
                                   synAttrs = Map.keys syn_
                                   nestedProd = tupnest (map (SimpleExpr . getName) synAttrs)
                                   funargs = [ nestedProd ]
                                   mkrhs syn = SimpleExpr (getName syn)
                               in  map (\s -> Decl (mklhs s) (mkrhs s)) synAttrs
                           -- "./GenerateCodeSM.ag"(line 666, column 16)
                           (_inhIns@_) =
                               let mklhs inh = Fun (insertnm nt_ nullIdent inh) funargs
                                   inhAttrs = Map.keys inh_
                                   nestedProd = tupnest (map (SimpleExpr . getName) inhAttrs)
                                   funargs = [ SimpleExpr "_inh_", nestedProd ]
                                   mkrhs inh = tupnest (map (\inh' -> if inh == inh'
                                                                      then SimpleExpr "_inh_"
                                                                      else SimpleExpr (getName inh'))
                                                            inhAttrs)
                               in  map (\s -> Decl (mklhs s) (mkrhs s)) inhAttrs
                           -- "./GenerateCodeSM.ag"(line 657, column 16)
                           (_synIns@_) =
                               let mklhs syn = Fun (insertnm nt_ nullIdent syn) funargs
                                   synAttrs = Map.keys syn_
                                   nestedProd = tupnest (map (SimpleExpr . getName) synAttrs)
                                   funargs = [ SimpleExpr "_syn_", nestedProd ]
                                   mkrhs syn = tupnest (map (\syn' -> if syn == syn'
                                                                      then SimpleExpr "_syn_"
                                                                      else SimpleExpr (getName syn'))
                                                            synAttrs)
                               in  map (\s -> Decl (mklhs s) (mkrhs s)) synAttrs
                           -- use rule
                           (_lhsOerrors@_) =
                               _altsIerrors
                           -- copy rule (up)
                           (_lhsOnrChildren@_) =
                               _altsInrChildren
                           -- copy rule (up)
                           (_lhsOsmCompDyns@_) =
                               _altsIsmCompDyns
                           -- copy rule (up)
                           (_lhsOsmConstructors@_) =
                               _altsIsmConstructors
                           -- copy rule (up)
                           (_lhsOsmDynSemFuns@_) =
                               _altsIsmDynSemFuns
                           -- copy rule (down)
                           (_altsOdown@_) =
                               _lhsIdown
                           -- copy rule (down)
                           (_altsOnts'@_) =
                               _lhsInts'
                           -- copy rule (down)
                           (_altsOo_cata@_) =
                               _lhsIo_cata
                           -- copy rule (down)
                           (_altsOo_newtypes@_) =
                               _lhsIo_newtypes
                           -- copy rule (down)
                           (_altsOo_pretty@_) =
                               _lhsIo_pretty
                           -- copy rule (down)
                           (_altsOo_rename@_) =
                               _lhsIo_rename
                           -- copy rule (down)
                           (_altsOo_sem@_) =
                               _lhsIo_sem
                           -- copy rule (down)
                           (_altsOo_sig@_) =
                               _lhsIo_sig
                           -- copy rule (down)
                           (_altsOprefix@_) =
                               _lhsIprefix
                       in  ( _lhsOdecls,_lhsOerrors,_lhsOnrChildren,_lhsOnts,_lhsOsmCompDyns,_lhsOsmConstructors,_lhsOsmDynSels,_lhsOsmDynSemFuns,_lhsOsmInputDyns,_lhsOsmInsDynsFuns,_lhsOsmPrimTypes,_lhsOsmSelDynVals,_lhsOsmTypeCons,_lhsOsmTypeConsTop,_lhsOsmdecls,_lhsOup)))
-- Productions -------------------------------------------------
{-
   inherited attributes:
      derivings            : Derivings
      down                 : [UseStream]
      nts'                 : [Name]
      o_cata               : Bool
      o_data               : Bool
      o_newtypes           : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      prefix               : String
      typeSyns             : TypeSyns
      wrappers             : Set Nonterminal

   chained attributes:

   synthesised attributes:
      decls                : Decls
      errors               : Seq Error
      nrChildren           : Int
      nts                  : [Name]
      smCompDyns           : [(String,(String,[String]))]
      smConstructors       : [(String,(String,[String]))]
      smDynSels            : [(String,(String,String,[String]))]
      smDynSemFuns         : [(String,(String,[String]))]
      smInputDyns          : [(String,(String,String))]
      smInsDynsFuns        : [(String, (String,Code.Type))]
      smPrimTypes          : [String]
      smSelDynVals         : [(String,(String,[String]))]
      smTypeCons           : [String]
      smTypeConsTop        : [String]
      smdecls              : Decls
      up                   : [UseStream]

-}
{-
   local variables for Productions.Cons:

-}
{-
   local variables for Productions.Nil:

-}
-- semantic domain
newtype T_Productions = T_Productions ((Derivings) ->
                                       ([UseStream]) ->
                                       ([Name]) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (Bool) ->
                                       (String) ->
                                       (TypeSyns) ->
                                       (Set Nonterminal) ->
                                       ( (Decls),(Seq Error),(Int),([Name]),([(String,(String,[String]))]),([(String,(String,[String]))]),([(String,(String,String,[String]))]),([(String,(String,[String]))]),([(String,(String,String))]),([(String, (String,Code.Type))]),([String]),([(String,(String,[String]))]),([String]),([String]),(Decls),([UseStream])))
-- cata
sem_Productions :: (Productions) ->
                   (T_Productions)
sem_Productions (list) =
    (foldr (sem_Productions_Cons) (sem_Productions_Nil) ((map sem_Production list)))
data Inh_Productions = Inh_Productions {derivings_Inh_Productions :: Derivings
                                       ,down_Inh_Productions :: [UseStream]
                                       ,nts'_Inh_Productions :: [Name]
                                       ,o_cata_Inh_Productions :: Bool
                                       ,o_data_Inh_Productions :: Bool
                                       ,o_newtypes_Inh_Productions :: Bool
                                       ,o_pretty_Inh_Productions :: Bool
                                       ,o_rename_Inh_Productions :: Bool
                                       ,o_sem_Inh_Productions :: Bool
                                       ,o_sig_Inh_Productions :: Bool
                                       ,prefix_Inh_Productions :: String
                                       ,typeSyns_Inh_Productions :: TypeSyns
                                       ,wrappers_Inh_Productions :: Set Nonterminal
                                       }
data Syn_Productions = Syn_Productions {decls_Syn_Productions :: Decls
                                       ,errors_Syn_Productions :: Seq Error
                                       ,nrChildren_Syn_Productions :: Int
                                       ,nts_Syn_Productions :: [Name]
                                       ,smCompDyns_Syn_Productions :: [(String,(String,[String]))]
                                       ,smConstructors_Syn_Productions :: [(String,(String,[String]))]
                                       ,smDynSels_Syn_Productions :: [(String,(String,String,[String]))]
                                       ,smDynSemFuns_Syn_Productions :: [(String,(String,[String]))]
                                       ,smInputDyns_Syn_Productions :: [(String,(String,String))]
                                       ,smInsDynsFuns_Syn_Productions :: [(String, (String,Code.Type))]
                                       ,smPrimTypes_Syn_Productions :: [String]
                                       ,smSelDynVals_Syn_Productions :: [(String,(String,[String]))]
                                       ,smTypeCons_Syn_Productions :: [String]
                                       ,smTypeConsTop_Syn_Productions :: [String]
                                       ,smdecls_Syn_Productions :: Decls
                                       ,up_Syn_Productions :: [UseStream]
                                       }
wrap_Productions :: (T_Productions) ->
                    (Inh_Productions) ->
                    (Syn_Productions)
wrap_Productions ((T_Productions (sem))) ((Inh_Productions (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12) (i13))) =
    let ( s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7) (i8) (i9) (i10) (i11) (i12) (i13))
    in  (Syn_Productions (s1) (s2) (s3) (s4) (s5) (s6) (s7) (s8) (s9) (s10) (s11) (s12) (s13) (s14) (s15) (s16))
sem_Productions_Cons :: (T_Production) ->
                        (T_Productions) ->
                        (T_Productions)
sem_Productions_Cons ((T_Production (hd_))) ((T_Productions (tl_))) =
    (T_Productions (\ _lhsIderivings
                      _lhsIdown
                      _lhsInts'
                      _lhsIo_cata
                      _lhsIo_data
                      _lhsIo_newtypes
                      _lhsIo_pretty
                      _lhsIo_rename
                      _lhsIo_sem
                      _lhsIo_sig
                      _lhsIprefix
                      _lhsItypeSyns
                      _lhsIwrappers ->
                        let _lhsOdecls :: (Decls)
                            _lhsOerrors :: (Seq Error)
                            _lhsOnrChildren :: (Int)
                            _lhsOnts :: ([Name])
                            _lhsOsmCompDyns :: ([(String,(String,[String]))])
                            _lhsOsmConstructors :: ([(String,(String,[String]))])
                            _lhsOsmDynSels :: ([(String,(String,String,[String]))])
                            _lhsOsmDynSemFuns :: ([(String,(String,[String]))])
                            _lhsOsmInputDyns :: ([(String,(String,String))])
                            _lhsOsmInsDynsFuns :: ([(String, (String,Code.Type))])
                            _lhsOsmPrimTypes :: ([String])
                            _lhsOsmSelDynVals :: ([(String,(String,[String]))])
                            _lhsOsmTypeCons :: ([String])
                            _lhsOsmTypeConsTop :: ([String])
                            _lhsOsmdecls :: (Decls)
                            _lhsOup :: ([UseStream])
                            _hdIdecls :: (Decls)
                            _hdIerrors :: (Seq Error)
                            _hdInrChildren :: (Int)
                            _hdInts :: ([Name])
                            _hdIsmCompDyns :: ([(String,(String,[String]))])
                            _hdIsmConstructors :: ([(String,(String,[String]))])
                            _hdIsmDynSels :: ([(String,(String,String,[String]))])
                            _hdIsmDynSemFuns :: ([(String,(String,[String]))])
                            _hdIsmInputDyns :: ([(String,(String,String))])
                            _hdIsmInsDynsFuns :: ([(String, (String,Code.Type))])
                            _hdIsmPrimTypes :: ([String])
                            _hdIsmSelDynVals :: ([(String,(String,[String]))])
                            _hdIsmTypeCons :: ([String])
                            _hdIsmTypeConsTop :: ([String])
                            _hdIsmdecls :: (Decls)
                            _hdIup :: ([UseStream])
                            _hdOderivings :: (Derivings)
                            _hdOdown :: ([UseStream])
                            _hdOnts' :: ([Name])
                            _hdOo_cata :: (Bool)
                            _hdOo_data :: (Bool)
                            _hdOo_newtypes :: (Bool)
                            _hdOo_pretty :: (Bool)
                            _hdOo_rename :: (Bool)
                            _hdOo_sem :: (Bool)
                            _hdOo_sig :: (Bool)
                            _hdOprefix :: (String)
                            _hdOtypeSyns :: (TypeSyns)
                            _hdOwrappers :: (Set Nonterminal)
                            _tlIdecls :: (Decls)
                            _tlIerrors :: (Seq Error)
                            _tlInrChildren :: (Int)
                            _tlInts :: ([Name])
                            _tlIsmCompDyns :: ([(String,(String,[String]))])
                            _tlIsmConstructors :: ([(String,(String,[String]))])
                            _tlIsmDynSels :: ([(String,(String,String,[String]))])
                            _tlIsmDynSemFuns :: ([(String,(String,[String]))])
                            _tlIsmInputDyns :: ([(String,(String,String))])
                            _tlIsmInsDynsFuns :: ([(String, (String,Code.Type))])
                            _tlIsmPrimTypes :: ([String])
                            _tlIsmSelDynVals :: ([(String,(String,[String]))])
                            _tlIsmTypeCons :: ([String])
                            _tlIsmTypeConsTop :: ([String])
                            _tlIsmdecls :: (Decls)
                            _tlIup :: ([UseStream])
                            _tlOderivings :: (Derivings)
                            _tlOdown :: ([UseStream])
                            _tlOnts' :: ([Name])
                            _tlOo_cata :: (Bool)
                            _tlOo_data :: (Bool)
                            _tlOo_newtypes :: (Bool)
                            _tlOo_pretty :: (Bool)
                            _tlOo_rename :: (Bool)
                            _tlOo_sem :: (Bool)
                            _tlOo_sig :: (Bool)
                            _tlOprefix :: (String)
                            _tlOtypeSyns :: (TypeSyns)
                            _tlOwrappers :: (Set Nonterminal)
                            ( _hdIdecls,_hdIerrors,_hdInrChildren,_hdInts,_hdIsmCompDyns,_hdIsmConstructors,_hdIsmDynSels,_hdIsmDynSemFuns,_hdIsmInputDyns,_hdIsmInsDynsFuns,_hdIsmPrimTypes,_hdIsmSelDynVals,_hdIsmTypeCons,_hdIsmTypeConsTop,_hdIsmdecls,_hdIup) =
                                (hd_ (_hdOderivings) (_hdOdown) (_hdOnts') (_hdOo_cata) (_hdOo_data) (_hdOo_newtypes) (_hdOo_pretty) (_hdOo_rename) (_hdOo_sem) (_hdOo_sig) (_hdOprefix) (_hdOtypeSyns) (_hdOwrappers))
                            ( _tlIdecls,_tlIerrors,_tlInrChildren,_tlInts,_tlIsmCompDyns,_tlIsmConstructors,_tlIsmDynSels,_tlIsmDynSemFuns,_tlIsmInputDyns,_tlIsmInsDynsFuns,_tlIsmPrimTypes,_tlIsmSelDynVals,_tlIsmTypeCons,_tlIsmTypeConsTop,_tlIsmdecls,_tlIup) =
                                (tl_ (_tlOderivings) (_tlOdown) (_tlOnts') (_tlOo_cata) (_tlOo_data) (_tlOo_newtypes) (_tlOo_pretty) (_tlOo_rename) (_tlOo_sem) (_tlOo_sig) (_tlOprefix) (_tlOtypeSyns) (_tlOwrappers))
                            -- "./GenerateCodeSM.ag"(line 231, column 10)
                            (_lhsOnrChildren@_) =
                                _hdInrChildren `max` _tlInrChildren
                            -- use rule
                            (_lhsOdecls@_) =
                                _hdIdecls ++ _tlIdecls
                            -- use rule
                            (_lhsOerrors@_) =
                                _hdIerrors Seq.<> _tlIerrors
                            -- use rule
                            (_lhsOnts@_) =
                                _hdInts ++ _tlInts
                            -- use rule
                            (_lhsOsmCompDyns@_) =
                                _hdIsmCompDyns ++ _tlIsmCompDyns
                            -- use rule
                            (_lhsOsmConstructors@_) =
                                _hdIsmConstructors ++ _tlIsmConstructors
                            -- use rule
                            (_lhsOsmDynSels@_) =
                                _hdIsmDynSels ++ _tlIsmDynSels
                            -- use rule
                            (_lhsOsmDynSemFuns@_) =
                                _hdIsmDynSemFuns ++ _tlIsmDynSemFuns
                            -- use rule
                            (_lhsOsmInputDyns@_) =
                                _hdIsmInputDyns ++ _tlIsmInputDyns
                            -- use rule
                            (_lhsOsmInsDynsFuns@_) =
                                _hdIsmInsDynsFuns ++ _tlIsmInsDynsFuns
                            -- use rule
                            (_lhsOsmPrimTypes@_) =
                                _hdIsmPrimTypes ++ _tlIsmPrimTypes
                            -- use rule
                            (_lhsOsmSelDynVals@_) =
                                _hdIsmSelDynVals ++ _tlIsmSelDynVals
                            -- use rule
                            (_lhsOsmTypeCons@_) =
                                _hdIsmTypeCons ++ _tlIsmTypeCons
                            -- use rule
                            (_lhsOsmTypeConsTop@_) =
                                _hdIsmTypeConsTop ++ _tlIsmTypeConsTop
                            -- use rule
                            (_lhsOsmdecls@_) =
                                _hdIsmdecls ++ _tlIsmdecls
                            -- use rule
                            (_lhsOup@_) =
                                _hdIup ++ _tlIup
                            -- copy rule (down)
                            (_hdOderivings@_) =
                                _lhsIderivings
                            -- copy rule (down)
                            (_hdOdown@_) =
                                _lhsIdown
                            -- copy rule (down)
                            (_hdOnts'@_) =
                                _lhsInts'
                            -- copy rule (down)
                            (_hdOo_cata@_) =
                                _lhsIo_cata
                            -- copy rule (down)
                            (_hdOo_data@_) =
                                _lhsIo_data
                            -- copy rule (down)
                            (_hdOo_newtypes@_) =
                                _lhsIo_newtypes
                            -- copy rule (down)
                            (_hdOo_pretty@_) =
                                _lhsIo_pretty
                            -- copy rule (down)
                            (_hdOo_rename@_) =
                                _lhsIo_rename
                            -- copy rule (down)
                            (_hdOo_sem@_) =
                                _lhsIo_sem
                            -- copy rule (down)
                            (_hdOo_sig@_) =
                                _lhsIo_sig
                            -- copy rule (down)
                            (_hdOprefix@_) =
                                _lhsIprefix
                            -- copy rule (down)
                            (_hdOtypeSyns@_) =
                                _lhsItypeSyns
                            -- copy rule (down)
                            (_hdOwrappers@_) =
                                _lhsIwrappers
                            -- copy rule (down)
                            (_tlOderivings@_) =
                                _lhsIderivings
                            -- copy rule (down)
                            (_tlOdown@_) =
                                _lhsIdown
                            -- copy rule (down)
                            (_tlOnts'@_) =
                                _lhsInts'
                            -- copy rule (down)
                            (_tlOo_cata@_) =
                                _lhsIo_cata
                            -- copy rule (down)
                            (_tlOo_data@_) =
                                _lhsIo_data
                            -- copy rule (down)
                            (_tlOo_newtypes@_) =
                                _lhsIo_newtypes
                            -- copy rule (down)
                            (_tlOo_pretty@_) =
                                _lhsIo_pretty
                            -- copy rule (down)
                            (_tlOo_rename@_) =
                                _lhsIo_rename
                            -- copy rule (down)
                            (_tlOo_sem@_) =
                                _lhsIo_sem
                            -- copy rule (down)
                            (_tlOo_sig@_) =
                                _lhsIo_sig
                            -- copy rule (down)
                            (_tlOprefix@_) =
                                _lhsIprefix
                            -- copy rule (down)
                            (_tlOtypeSyns@_) =
                                _lhsItypeSyns
                            -- copy rule (down)
                            (_tlOwrappers@_) =
                                _lhsIwrappers
                        in  ( _lhsOdecls,_lhsOerrors,_lhsOnrChildren,_lhsOnts,_lhsOsmCompDyns,_lhsOsmConstructors,_lhsOsmDynSels,_lhsOsmDynSemFuns,_lhsOsmInputDyns,_lhsOsmInsDynsFuns,_lhsOsmPrimTypes,_lhsOsmSelDynVals,_lhsOsmTypeCons,_lhsOsmTypeConsTop,_lhsOsmdecls,_lhsOup)))
sem_Productions_Nil :: (T_Productions)
sem_Productions_Nil  =
    (T_Productions (\ _lhsIderivings
                      _lhsIdown
                      _lhsInts'
                      _lhsIo_cata
                      _lhsIo_data
                      _lhsIo_newtypes
                      _lhsIo_pretty
                      _lhsIo_rename
                      _lhsIo_sem
                      _lhsIo_sig
                      _lhsIprefix
                      _lhsItypeSyns
                      _lhsIwrappers ->
                        let _lhsOdecls :: (Decls)
                            _lhsOerrors :: (Seq Error)
                            _lhsOnrChildren :: (Int)
                            _lhsOnts :: ([Name])
                            _lhsOsmCompDyns :: ([(String,(String,[String]))])
                            _lhsOsmConstructors :: ([(String,(String,[String]))])
                            _lhsOsmDynSels :: ([(String,(String,String,[String]))])
                            _lhsOsmDynSemFuns :: ([(String,(String,[String]))])
                            _lhsOsmInputDyns :: ([(String,(String,String))])
                            _lhsOsmInsDynsFuns :: ([(String, (String,Code.Type))])
                            _lhsOsmPrimTypes :: ([String])
                            _lhsOsmSelDynVals :: ([(String,(String,[String]))])
                            _lhsOsmTypeCons :: ([String])
                            _lhsOsmTypeConsTop :: ([String])
                            _lhsOsmdecls :: (Decls)
                            _lhsOup :: ([UseStream])
                            -- "./GenerateCodeSM.ag"(line 232, column 10)
                            (_lhsOnrChildren@_) =
                                0
                            -- use rule
                            (_lhsOdecls@_) =
                                []
                            -- use rule
                            (_lhsOerrors@_) =
                                Seq.empty
                            -- use rule
                            (_lhsOnts@_) =
                                []
                            -- use rule
                            (_lhsOsmCompDyns@_) =
                                []
                            -- use rule
                            (_lhsOsmConstructors@_) =
                                []
                            -- use rule
                            (_lhsOsmDynSels@_) =
                                []
                            -- use rule
                            (_lhsOsmDynSemFuns@_) =
                                []
                            -- use rule
                            (_lhsOsmInputDyns@_) =
                                []
                            -- use rule
                            (_lhsOsmInsDynsFuns@_) =
                                []
                            -- use rule
                            (_lhsOsmPrimTypes@_) =
                                []
                            -- use rule
                            (_lhsOsmSelDynVals@_) =
                                []
                            -- use rule
                            (_lhsOsmTypeCons@_) =
                                []
                            -- use rule
                            (_lhsOsmTypeConsTop@_) =
                                []
                            -- use rule
                            (_lhsOsmdecls@_) =
                                []
                            -- use rule
                            (_lhsOup@_) =
                                []
                        in  ( _lhsOdecls,_lhsOerrors,_lhsOnrChildren,_lhsOnts,_lhsOsmCompDyns,_lhsOsmConstructors,_lhsOsmDynSels,_lhsOsmDynSemFuns,_lhsOsmInputDyns,_lhsOsmInsDynsFuns,_lhsOsmPrimTypes,_lhsOsmSelDynVals,_lhsOsmTypeCons,_lhsOsmTypeConsTop,_lhsOsmdecls,_lhsOup)))
-- Rule --------------------------------------------------------
{-
   inherited attributes:
      attrs                : [(Name,Name)]
      con                  : Identifier
      down                 : [UseStream]
      fieldnames           : [Name]
      fields               : [(Name,Type)]
      nt                   : Identifier
      o_pretty             : Bool

   chained attributes:

   synthesised attributes:
      decl                 : Decls
      decls'               : Decls
      errors               : Seq Error
      locVars              : [Name]
      up                   : [UseStream]

-}
{-
   local variables for Rule.Rule:
      up
      usedInAttrs
      usedOutAttrs
      usedLocals
      locAttrs
      inAttrs
      outAttrs

-}
-- semantic domain
newtype T_Rule = T_Rule (([(Name,Name)]) ->
                         (Identifier) ->
                         ([UseStream]) ->
                         ([Name]) ->
                         ([(Name,Type)]) ->
                         (Identifier) ->
                         (Bool) ->
                         ( (Decls),(Decls),(Seq Error),([Name]),([UseStream])))
-- cata
sem_Rule :: (Rule) ->
            (T_Rule)
sem_Rule ((Rule (_pattern) (_rhs) (_owrt) (_origin))) =
    (sem_Rule_Rule ((sem_Pattern (_pattern))) ((sem_Expression (_rhs))) (_owrt) (_origin))
data Inh_Rule = Inh_Rule {attrs_Inh_Rule :: [(Name,Name)],con_Inh_Rule :: Identifier,down_Inh_Rule :: [UseStream],fieldnames_Inh_Rule :: [Name],fields_Inh_Rule :: [(Name,Type)],nt_Inh_Rule :: Identifier,o_pretty_Inh_Rule :: Bool}
data Syn_Rule = Syn_Rule {decl_Syn_Rule :: Decls,decls'_Syn_Rule :: Decls,errors_Syn_Rule :: Seq Error,locVars_Syn_Rule :: [Name],up_Syn_Rule :: [UseStream]}
wrap_Rule :: (T_Rule) ->
             (Inh_Rule) ->
             (Syn_Rule)
wrap_Rule ((T_Rule (sem))) ((Inh_Rule (i1) (i2) (i3) (i4) (i5) (i6) (i7))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7))
    in  (Syn_Rule (s1) (s2) (s3) (s4) (s5))
sem_Rule_Rule :: (T_Pattern) ->
                 (T_Expression) ->
                 (Bool) ->
                 (String) ->
                 (T_Rule)
sem_Rule_Rule ((T_Pattern (pattern_))) ((T_Expression (rhs_))) (owrt_) (origin_) =
    (T_Rule (\ _lhsIattrs
               _lhsIcon
               _lhsIdown
               _lhsIfieldnames
               _lhsIfields
               _lhsInt
               _lhsIo_pretty ->
                 let _lhsOdecl :: (Decls)
                     _lhsOdecls' :: (Decls)
                     _lhsOerrors :: (Seq Error)
                     _lhsOlocVars :: ([Name])
                     _lhsOup :: ([UseStream])
                     _patternIerrors :: (Seq Error)
                     _patternIlocVars :: ([Name])
                     _patternIpp :: (PP_Doc)
                     _patternIpp' :: (PP_Doc)
                     _patternIvertices :: ([Vertex])
                     _patternOcon :: (Identifier)
                     _patternOfields :: ([(Name,Type)])
                     _patternOnt :: (Identifier)
                     _rhsIerrors :: (Seq Error)
                     _rhsIpos :: (Pos)
                     _rhsIpp :: (PP_Doc)
                     _rhsIusedAttrs :: ([(Name,Name)])
                     _rhsIusedLocals :: ([Name])
                     _rhsOattrs :: ([(Name,Name)])
                     _rhsOcon :: (Name)
                     _rhsOfieldnames :: ([Name])
                     _rhsOnt :: (Name)
                     ( _patternIerrors,_patternIlocVars,_patternIpp,_patternIpp',_patternIvertices) =
                         (pattern_ (_patternOcon) (_patternOfields) (_patternOnt))
                     ( _rhsIerrors,_rhsIpos,_rhsIpp,_rhsIusedAttrs,_rhsIusedLocals) =
                         (rhs_ (_rhsOattrs) (_rhsOcon) (_rhsOfieldnames) (_rhsOnt))
                     -- "GenerateCode.ag"(line 327, column 10)
                     (_lhsOdecl@_) =
                         (if _lhsIo_pretty then (Comment origin_:) else id)
                            [Decl (Pattern _patternIpp) (PP _rhsIpp)]
                     -- "./Dep.ag"(line 134, column 10)
                     (_up@_) =
                         [ let (nt2,field)= case vertex of
                                             Local _ _ _       -> (nullIdent,nullIdent)
                                             LHSSyn nt _ _     -> (nt       ,_LHS)
                                             RHSInh nt _ _ f _ -> (nt       ,f)
                               rhsstreams = [ addTraceElem
                                               (TE { lineNr  = line _rhsIpos
                                                   , nt      = _lhsInt
                                                   , prod    = _lhsIcon
                                                   , lhsNt   = nt2
                                                   , lhsFld  = field
                                                   , lhsAttr = getAttr vertex
                                                   , rhsFld  = getField usedVertex
                                                   , rhsAttr = getAttr usedVertex
                                                   }
                                               )
                                               (getStream usedVertex _lhsIdown)
                                            | usedVertex <- (_usedLocals ++ _usedOutAttrs ++ _usedInAttrs)
                                            ]
                           in (vertex,([],[]) : (foldr stUnion stEmpty rhsstreams))
                         | vertex <- (_patternIvertices)
                         ]
                     -- "./Dep.ag"(line 134, column 10)
                     (_usedInAttrs@_) =
                         map (\(fld,attr) -> LHSInh   _lhsInt _lhsIcon     attr) _inAttrs
                     -- "./Dep.ag"(line 134, column 10)
                     (_usedOutAttrs@_) =
                         map (\(fld,attr) -> ShRHSSyn _lhsInt _lhsIcon fld attr) _outAttrs
                     -- "./Dep.ag"(line 134, column 10)
                     (_usedLocals@_) =
                         map (\attr       -> Local    _lhsInt _lhsIcon     attr) (_locAttrs ++ _rhsIusedLocals)
                     -- "./Dep.ag"(line 134, column 14)
                     ((_locAttrs@_,(_inAttrs@_,_outAttrs@_))) =
                         let (locs,rest) = partition (\(fld,attr) -> fld==_LOC) _rhsIusedAttrs
                         in (map snd locs, partition (\(fld,attr) -> fld==_LHS) rest)
                     -- "./GenerateCodeSM.ag"(line 397, column 10)
                     (_lhsOdecls'@_) =
                         (if _lhsIo_pretty then (Comment origin_:) else id)
                          [Decl (Pattern _patternIpp') (PP _rhsIpp)]
                     -- use rule
                     (_lhsOerrors@_) =
                         _patternIerrors Seq.<> _rhsIerrors
                     -- use rule
                     (_lhsOlocVars@_) =
                         _patternIlocVars
                     -- copy rule (from local)
                     (_lhsOup@_) =
                         _up
                     -- copy rule (down)
                     (_patternOcon@_) =
                         _lhsIcon
                     -- copy rule (down)
                     (_patternOfields@_) =
                         _lhsIfields
                     -- copy rule (down)
                     (_patternOnt@_) =
                         _lhsInt
                     -- copy rule (down)
                     (_rhsOattrs@_) =
                         _lhsIattrs
                     -- copy rule (down)
                     (_rhsOcon@_) =
                         _lhsIcon
                     -- copy rule (down)
                     (_rhsOfieldnames@_) =
                         _lhsIfieldnames
                     -- copy rule (down)
                     (_rhsOnt@_) =
                         _lhsInt
                 in  ( _lhsOdecl,_lhsOdecls',_lhsOerrors,_lhsOlocVars,_lhsOup)))
-- Rules -------------------------------------------------------
{-
   inherited attributes:
      attrs                : [(Name,Name)]
      con                  : Identifier
      down                 : [UseStream]
      fieldnames           : [Name]
      fields               : [(Name,Type)]
      nt                   : Identifier
      o_pretty             : Bool

   chained attributes:

   synthesised attributes:
      decls                : Decls
      decls'               : Decls
      errors               : Seq Error
      locVars              : [Name]
      up                   : [UseStream]

-}
{-
   local variables for Rules.Cons:

-}
{-
   local variables for Rules.Nil:

-}
-- semantic domain
newtype T_Rules = T_Rules (([(Name,Name)]) ->
                           (Identifier) ->
                           ([UseStream]) ->
                           ([Name]) ->
                           ([(Name,Type)]) ->
                           (Identifier) ->
                           (Bool) ->
                           ( (Decls),(Decls),(Seq Error),([Name]),([UseStream])))
-- cata
sem_Rules :: (Rules) ->
             (T_Rules)
sem_Rules (list) =
    (foldr (sem_Rules_Cons) (sem_Rules_Nil) ((map sem_Rule list)))
data Inh_Rules = Inh_Rules {attrs_Inh_Rules :: [(Name,Name)],con_Inh_Rules :: Identifier,down_Inh_Rules :: [UseStream],fieldnames_Inh_Rules :: [Name],fields_Inh_Rules :: [(Name,Type)],nt_Inh_Rules :: Identifier,o_pretty_Inh_Rules :: Bool}
data Syn_Rules = Syn_Rules {decls_Syn_Rules :: Decls,decls'_Syn_Rules :: Decls,errors_Syn_Rules :: Seq Error,locVars_Syn_Rules :: [Name],up_Syn_Rules :: [UseStream]}
wrap_Rules :: (T_Rules) ->
              (Inh_Rules) ->
              (Syn_Rules)
wrap_Rules ((T_Rules (sem))) ((Inh_Rules (i1) (i2) (i3) (i4) (i5) (i6) (i7))) =
    let ( s1,s2,s3,s4,s5) =
            (sem (i1) (i2) (i3) (i4) (i5) (i6) (i7))
    in  (Syn_Rules (s1) (s2) (s3) (s4) (s5))
sem_Rules_Cons :: (T_Rule) ->
                  (T_Rules) ->
                  (T_Rules)
sem_Rules_Cons ((T_Rule (hd_))) ((T_Rules (tl_))) =
    (T_Rules (\ _lhsIattrs
                _lhsIcon
                _lhsIdown
                _lhsIfieldnames
                _lhsIfields
                _lhsInt
                _lhsIo_pretty ->
                  let _lhsOdecls :: (Decls)
                      _lhsOdecls' :: (Decls)
                      _lhsOerrors :: (Seq Error)
                      _lhsOlocVars :: ([Name])
                      _lhsOup :: ([UseStream])
                      _hdIdecl :: (Decls)
                      _hdIdecls' :: (Decls)
                      _hdIerrors :: (Seq Error)
                      _hdIlocVars :: ([Name])
                      _hdIup :: ([UseStream])
                      _hdOattrs :: ([(Name,Name)])
                      _hdOcon :: (Identifier)
                      _hdOdown :: ([UseStream])
                      _hdOfieldnames :: ([Name])
                      _hdOfields :: ([(Name,Type)])
                      _hdOnt :: (Identifier)
                      _hdOo_pretty :: (Bool)
                      _tlIdecls :: (Decls)
                      _tlIdecls' :: (Decls)
                      _tlIerrors :: (Seq Error)
                      _tlIlocVars :: ([Name])
                      _tlIup :: ([UseStream])
                      _tlOattrs :: ([(Name,Name)])
                      _tlOcon :: (Identifier)
                      _tlOdown :: ([UseStream])
                      _tlOfieldnames :: ([Name])
                      _tlOfields :: ([(Name,Type)])
                      _tlOnt :: (Identifier)
                      _tlOo_pretty :: (Bool)
                      ( _hdIdecl,_hdIdecls',_hdIerrors,_hdIlocVars,_hdIup) =
                          (hd_ (_hdOattrs) (_hdOcon) (_hdOdown) (_hdOfieldnames) (_hdOfields) (_hdOnt) (_hdOo_pretty))
                      ( _tlIdecls,_tlIdecls',_tlIerrors,_tlIlocVars,_tlIup) =
                          (tl_ (_tlOattrs) (_tlOcon) (_tlOdown) (_tlOfieldnames) (_tlOfields) (_tlOnt) (_tlOo_pretty))
                      -- "GenerateCode.ag"(line 323, column 10)
                      (_lhsOdecls@_) =
                          _hdIdecl ++ _tlIdecls
                      -- use rule
                      (_lhsOdecls'@_) =
                          _hdIdecls' ++ _tlIdecls'
                      -- use rule
                      (_lhsOerrors@_) =
                          _hdIerrors Seq.<> _tlIerrors
                      -- use rule
                      (_lhsOlocVars@_) =
                          _hdIlocVars ++ _tlIlocVars
                      -- use rule
                      (_lhsOup@_) =
                          _hdIup ++ _tlIup
                      -- copy rule (down)
                      (_hdOattrs@_) =
                          _lhsIattrs
                      -- copy rule (down)
                      (_hdOcon@_) =
                          _lhsIcon
                      -- copy rule (down)
                      (_hdOdown@_) =
                          _lhsIdown
                      -- copy rule (down)
                      (_hdOfieldnames@_) =
                          _lhsIfieldnames
                      -- copy rule (down)
                      (_hdOfields@_) =
                          _lhsIfields
                      -- copy rule (down)
                      (_hdOnt@_) =
                          _lhsInt
                      -- copy rule (down)
                      (_hdOo_pretty@_) =
                          _lhsIo_pretty
                      -- copy rule (down)
                      (_tlOattrs@_) =
                          _lhsIattrs
                      -- copy rule (down)
                      (_tlOcon@_) =
                          _lhsIcon
                      -- copy rule (down)
                      (_tlOdown@_) =
                          _lhsIdown
                      -- copy rule (down)
                      (_tlOfieldnames@_) =
                          _lhsIfieldnames
                      -- copy rule (down)
                      (_tlOfields@_) =
                          _lhsIfields
                      -- copy rule (down)
                      (_tlOnt@_) =
                          _lhsInt
                      -- copy rule (down)
                      (_tlOo_pretty@_) =
                          _lhsIo_pretty
                  in  ( _lhsOdecls,_lhsOdecls',_lhsOerrors,_lhsOlocVars,_lhsOup)))
sem_Rules_Nil :: (T_Rules)
sem_Rules_Nil  =
    (T_Rules (\ _lhsIattrs
                _lhsIcon
                _lhsIdown
                _lhsIfieldnames
                _lhsIfields
                _lhsInt
                _lhsIo_pretty ->
                  let _lhsOdecls :: (Decls)
                      _lhsOdecls' :: (Decls)
                      _lhsOerrors :: (Seq Error)
                      _lhsOlocVars :: ([Name])
                      _lhsOup :: ([UseStream])
                      -- "GenerateCode.ag"(line 324, column 10)
                      (_lhsOdecls@_) =
                          []
                      -- use rule
                      (_lhsOdecls'@_) =
                          []
                      -- use rule
                      (_lhsOerrors@_) =
                          Seq.empty
                      -- use rule
                      (_lhsOlocVars@_) =
                          []
                      -- use rule
                      (_lhsOup@_) =
                          []
                  in  ( _lhsOdecls,_lhsOdecls',_lhsOerrors,_lhsOlocVars,_lhsOup)))


